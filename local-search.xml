<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>离散积分传播的几种方式</title>
    <link href="/2021/04/20/2021-04-20-propagation/"/>
    <url>/2021/04/20/2021-04-20-propagation/</url>
    
    <content type="html"><![CDATA[<p><a href="#%E6%AC%A7%E6%8B%89%E7%A7%AF%E5%88%86">欧拉积分</a></p><p><a href="%E4%B8%AD%E5%80%BC%E7%A7%AF%E5%88%86">中值积分</a></p><p><a href="#%E9%BE%99%E6%A0%BC%E5%BA%93%E5%A1%94%E7%A7%AF%E5%88%86">龙格库塔积分</a></p><blockquote><p>主要的应用场景一般是类似imu的积分传播中，为了更清楚的表达各种积分方式的主要思路，下面都会以简化的速度的传播进行举例。测量的到n时刻的加速度为$a_1$，n+1时刻的加速度为$a_2$，已知n时刻的速度$v_1$，目标是通过积分传播得到n+1时刻的速度$v_2$。（以下不考虑姿态重力等因素对加速度的影响）</p></blockquote><h2 id="欧拉积分"><a href="#欧拉积分" class="headerlink" title="欧拉积分"></a>欧拉积分</h2><blockquote><p>欧拉积分一般假设导数恒定，使用初始时刻的导数来进行积分传播，此处速度的，积分为：</p></blockquote><p>$$<br>v_2 &#x3D; v_1 + a_1 * \Delta t<br>$$</p><h2 id="中值积分"><a href="#中值积分" class="headerlink" title="中值积分"></a>中值积分</h2><blockquote><p>中值积分一般也是假设导数恒定，但是为了使得导数的值更加精确，使用中值处的导数积分，公式为：</p></blockquote><p>$$<br>v_2 &#x3D; v_1 + \frac{a_1 + a_2}{2} \Delta t<br>$$</p><h2 id="龙格库塔积分"><a href="#龙格库塔积分" class="headerlink" title="龙格库塔积分"></a>龙格库塔积分</h2><blockquote><p>一般常用的是4阶龙格库塔积分，也叫rk4积分。上面的速度传播太简单，不能很好说明。下面$t_0$为初始时刻，$y_0$为初始时刻的状态，$f$为导数函数（确定某一时刻，某个状态后，可以确定其导数。类比在imu传播中，获得加速度后，是需要将其转换到全局坐标系下，然后再减去重力向量才得到最终的加速度，也就是速度的导数是与系统状态–姿态相关的），主要思路如下：</p></blockquote><p>$$<br>{k_1} &#x3D; f({t_0}, y_0) \Delta t  \<br>{k_2} &#x3D; f( {t_0}+{\Delta t \over 2}, y_0 + {1 \over 2}{k_1} ) \Delta t \<br>{k_3} &#x3D; f( {t_0}+{\Delta t \over 2}, y_0 + {1 \over 2}{k_2} ) \Delta t \<br>{k_4} &#x3D; f( {t_0} + {\Delta t}, y_0 + {k_3} ) \Delta t \<br>y_{0+\Delta t} &#x3D; y_0 + \left( {\frac{1}{6} {k_1} + {1 \over 3}{k_2} + {1 \over 3}{k_3} + \frac{1}{6} {k_4}} \right)<br>$$</p><p>其中：</p><ul><li>$k_1$为以时间段开始时刻$t_0$下的导数进行积分得到的状态改变量；</li><li>$k_2$: 按照$k_1$计算中值时刻${t_0}+{\Delta t \over 2}$时的系统状态为$y_0 + {1 \over 2}{k_1} $，则在此中值时刻与状态下的导数进行积分得到的状态改变量为$k_2$;</li><li>$k_3$: 按照$k_2$计算中值时刻${t_0}+{\Delta t \over 2}$时的系统状态为$y_0 + {1 \over 2}{k_2} $，则在此中值时刻与状态下的导数进行积分得到的状态改变量为$k_3$;</li><li>$k_4$: 按照$k_3$计算的终值时刻${t_0}+{\Delta t }$时的系统状态为$y_0 + {k_3} $，则以此状态下积分终点时刻的导数进行积分得到的状态改变量为$k_4$；</li><li>最终的积分结果为上述的加权叠加，其中中点处的导数权重更大，两端处的导数权重更小。</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] openvins源码：<code>Propagtor.h</code>文件中的<code>predict_mean_rk4</code>函数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cuda编程的基础概念总结</title>
    <link href="/2021/03/14/2021-03-16-cuda-basic/"/>
    <url>/2021/03/14/2021-03-16-cuda-basic/</url>
    
    <content type="html"><![CDATA[<h1 id="GPU的基础介绍"><a href="#GPU的基础介绍" class="headerlink" title="GPU的基础介绍"></a>GPU的基础介绍</h1><p>首先上一张显卡主板构造图。</p><p><img src="/img/cuda/00.png" alt="dfs"></p><p>其中GPU芯片是重点，其结构图如下，它一般有很多核心，这些核的学术名字叫流多处理器（stream multiprocessor，SM），每个SM根据GPU型号的不同由若干个流处理器（stream processor，SP）组成，SP的功能只有计算。</p><p><img src="/img/cuda/04.png" alt="cuda"></p><h1 id="cuda编程的基本概念"><a href="#cuda编程的基本概念" class="headerlink" title="cuda编程的基本概念"></a>cuda编程的基本概念</h1><h2 id="主机端host与设备端device"><a href="#主机端host与设备端device" class="headerlink" title="主机端host与设备端device"></a>主机端host与设备端device</h2><blockquote><p>一个工程，我们想要有的代码在cpu上执行，有的代码在gpu上执行。因此就需要有host与device的概念。</p></blockquote><p>GPU是完全不同于CPU的处理器，为了方便地同时为CPU和GPU编写代码，处理好两种处理器间各自计算、内存、数据传递等任务，CUDA使用C语言作为CPU端的开发环境，并在GPU端使用几乎与CPU端一致的语法进行开发，只是使用一些特定的关键字来区分CPU端和GPU端的代码。</p><p>CUDA中，为了更好的区分CPU和GPU，将CPU作为主机端（Host），GPU作为设备端（Device），每个进程（process）中，通过一个Host控制一个或多个Device协同工作。通过这种方式，CPU负责进行逻辑性强的事务性处理和串行计算，而GPU则专注于执行高度线程化的并行处理任务。</p><p>通过这种方式，首先实现了CUDA中最上层的并行：Host与Device的并行。也可以理解为将计算任务分解成若干子任务分别交给CPU和GPU。如下图所示，Host和Device有各自的流水线，计算和内存等均彼此独立，不过Device依然由Host控制，控制Device的工作也是Host流水线上的一部分。</p><p>虽然在大多数时候，为了结果的正确性需要经常在必要处进行Host与Device同步（往往是CPU、GPU间的数据通信），此时CPU或GPU会空等另一边执行到同步出再继续计算。但在此基础上进行进一步优化往往可以带来很好的优化效果，比如采用通信隐藏、或者插入无关计算等方法。</p><p><img src="/img/cuda/01.png" alt="dfs"></p><blockquote><p> 在正常c语言中，设备端函数用<code>__global__</code>来修饰。在执行时需要使用特定的调用格式。</p></blockquote><h2 id="设备端代码的执行"><a href="#设备端代码的执行" class="headerlink" title="设备端代码的执行"></a>设备端代码的执行</h2><blockquote><p>一般从主机代码中启动设备代码叫做<strong>内核调用</strong>。内核调用有固定的语法<code>func &lt;&lt; &lt;block数量，每个block中线程数量，共享内存大小  &gt;&gt; &gt;(参数列表)</code></p></blockquote><p>CUDA中，运行在GPU上的并行计算函数称为kernel函数。</p><p><strong>内核调用是以线程网格（grid）的形式组织的，每个grid由若干个线程块（block）组成，而每个block又由若干个线程（thread）组成</strong>。block的数量只要小于$2^{31}-1$就好，thread的数量现在一般都是1024了。</p><p><img src="/img/cuda/02.png" alt="dfs"></p><blockquote><p>一般block数量是GPU的流多处理器数量的两倍时，GPU会给出最佳性能。</p></blockquote><h2 id="cuda编程时的内存结构"><a href="#cuda编程时的内存结构" class="headerlink" title="cuda编程时的内存结构"></a>cuda编程时的内存结构</h2><p><img src="/img/cuda/03.png" alt="dfs"></p><blockquote><p>除了表格中的，其实还有L1和L2缓存。其中L1缓存一般是每个流多处理器（gpu的核）都有的，一般与shared memory使用相同的存储硬件，L2缓存是整个gpu中所有的流多处理器共享的，所有的global memory和local memory都使用这些缓存。同时，所有的global memory访问通过L2缓存进行。</p></blockquote><p>在<code>__global__</code>修饰的设备函数中声明的局部变量肯定使用的是local memory或者是register（一开始会优先使用register，如果register装不下，就会使用local memory）；而使用<code>cudaMalloc</code>分配的内存都是global memory</p><p>此处说的<strong>global memory</strong>对应的物理结构也就是本文开头的显卡主板构造中的显存芯片，这是在gpu芯片之外的，因此访问速度会比较慢。</p><p>上面的<strong>shared memory</strong>是在gpu芯片内部，因此速度比global memory快很多。一般在设备函数中使用<code>__shared__</code>修饰声明的变量存储在shared memory中，供同一个block中的所有线程使用。</p><p>上面的<strong>constant memory</strong>也是占用的显存，并且逻辑上分配64kb大小的常量内存空间，这部分内存是只读的。其中的变量一般在全局程序中使用<code>__constant__</code>关键字修饰，对常量内存中的变量进行初始化需要使用<code>cudaMemcpyToSymbol</code>函数。在设备函数中常量内存是只读的，因此每个线程在访问常量内存时不是单独访问，而是统一一次访问，然后广播给所有的线程，因此在频繁访问同一块常量内存时可以节省时间。</p><p>上面的<strong>texture memory</strong>是另外一种当数据访问具有特定模式的时候可以加速程序执行、减少显存带宽的只读存储器。纹理内存也是在显存芯片中，和常量内存一样都在芯片内部被cache缓冲。当每个线程的读取位置都与其他线程的读取位置临近时，使用纹理内存会很高效。</p><p>CUDA对于显存中常见的大数据量的存储方式有两种，一种是普通的线性存储（cudaMalloc申请），可以直接用指针访问。另一种则是cuda数组（一般与纹理内存绑定），对用户不透明，不能在内核里直接用指针访问，需要通过texture或surface的相应函数访问。</p><h4 id="主机内存"><a href="#主机内存" class="headerlink" title="主机内存"></a>主机内存</h4><p>一般cuda编程都会涉及到主机与设备之间的内存交换，而主机内存需要注意的是：</p><ol><li>使用<code>malloc</code>函数在cpu上分配的内存是可换页的标准内存；</li><li>CUDA提供了<code>cudaHostAlloc</code>函数可以分配锁定页面的内存，也叫Pinned内存；操作系统会保证永远不会将这种内存换页到磁盘上，总在物理内存中，因此系统内的所有设备都可以直接用该段内存缓冲区的物理地址来访问，此属性可以帮助GPU通过直接内存访问（DMA）将数据复制到主机或从主机复制数据，无需cpu干预（cuda流中的传输需要使用页面锁定内存）；</li></ol><h2 id="CUDA流"><a href="#CUDA流" class="headerlink" title="CUDA流"></a>CUDA流</h2><p>GPU作为一种专用的并行计算设备，可以同时支持多个内核调用，为了使得这个内核调用互不干扰，独立运行，可以使用CUDA流来组织不同的任务。每个流中的工作是串行的（比如从cpu拷贝内存，内核调用，拷贝内存回cpu，依次执行），而流与流之间则是默认不保证顺序的（并行互不干扰的）。</p><h2 id="cu程序编译"><a href="#cu程序编译" class="headerlink" title=".cu程序编译"></a><code>.cu</code>程序编译</h2><p>带有cuda编程的源文件一般是<code>.cu</code>结尾的，这种源文件的编译使用<code>nvcc</code>编译器，使用方法与<code>gcc</code>一致。</p>]]></content>
    
    
    
    <tags>
      
      <tag>c与c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++并发编程中的锁---互斥元</title>
    <link href="/2021/03/03/2021-03-03-mutex/"/>
    <url>/2021/03/03/2021-03-03-mutex/</url>
    
    <content type="html"><![CDATA[<p>说到并发编程就离不开锁的概念。锁其实是一种操作，这种操作可以避免竞争问题的出现。在c++中可以使用互斥元来实现锁的操作。</p><h1 id="互斥元"><a href="#互斥元" class="headerlink" title="互斥元"></a>互斥元</h1><blockquote><p>互斥元也叫互斥量，在c++11中被命名为Mutex，所有其相关的类和函数都在头文件<mutex>中。</p></blockquote><p>在头文件<code>mutex</code>中一共有四种互斥元类，分别是：</p><ol><li><code>std::mutex</code>，最基本的互斥元类。</li><li><code>std::recursive_mutex</code>，递归Mutex类（同一线程可以对互斥量多次上锁，来获得对互斥量对象的多层所有权）。</li><li><code>std::time_mutex</code>，定时Mutex类。</li><li><code>std::recursive_timed_mutex</code>，定时递归Mutex类。</li></ol><blockquote><p>上述四种互斥元类都有一个成员函数<code>lock</code>和一个<code>unlock</code>来实现锁定与解锁的操作。</p></blockquote><p>除此之外，还有两种Lock类，分别是</p><ol><li><code>std::lock_guard</code>，这个类的使用类似智能指针，可以销毁时自动解锁；</li><li><code>std::unique_lock</code>，这个类与1用法相同，但提供了更灵活的上锁和解锁控制，同时也更占资源；</li></ol><blockquote><p>lock类的作用类似智能指针，可以在销毁时自动解锁，不至于出现一个互斥元被一直锁住。</p></blockquote><p>其他类型</p><ul><li>std::once_flag</li><li>std::adopt_lock_t</li><li>std::defer_lock_t</li><li>std::try_to_lock_t</li></ul><p>函数：</p><ul><li>std::try_lock，尝试同时对多个互斥量上锁。</li><li>std::lock，可以同时对多个互斥量上锁。</li><li>std::call_once，如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次。</li></ul><h2 id="重点1：std-mutex类"><a href="#重点1：std-mutex类" class="headerlink" title="重点1：std::mutex类"></a>重点1：std::mutex类</h2><ul><li>构造函数，<code>std::mutex</code>不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。</li><li><code>lock()</code>，调用线程将锁住该互斥量。线程调用该函数会发生下面 <strong>3 种情况</strong>：<ol><li>如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。</li><li>如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。</li><li>如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</li></ol></li><li><code>unlock()</code>， 解锁，释放对互斥量的所有权。</li><li><code>try_lock()</code>，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 <strong>3 种情况</strong>：<ol><li>如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。</li><li>如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。</li><li>如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>       <span class="hljs-comment">// std::cout</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span>         <span class="hljs-comment">// std::thread</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span>          <span class="hljs-comment">// std::mutex</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-title">counter</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// non-atomic counter</span><br>std::mutex mtx;           <span class="hljs-comment">// locks access to counter</span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">attempt_10k_increases</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10000</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (mtx.<span class="hljs-built_in">try_lock</span>()) &#123;   <span class="hljs-comment">// only increase if currently not locked:</span><br>            ++counter;<br>            mtx.<span class="hljs-built_in">unlock</span>();<br>        &#125;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    std::thread threads[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; ++i)<br>        threads[i] = std::<span class="hljs-built_in">thread</span>(attempt_10k_increases);<br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; th : threads) th.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; counter &lt;&lt; <span class="hljs-string">&quot; successful increases of the counter.\n&quot;</span>;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="重点2：lock类的使用"><a href="#重点2：lock类的使用" class="headerlink" title="重点2：lock类的使用"></a>重点2：lock类的使用</h2><ul><li><code>std::lock_guard</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>       <span class="hljs-comment">// std::cout</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span>         <span class="hljs-comment">// std::thread</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span>          <span class="hljs-comment">// std::mutex, std::lock_guard</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span>      <span class="hljs-comment">// std::logic_error</span></span><br> <br>std::mutex mtx;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_even</span> <span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; is even\n&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">throw</span> (std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;not even&quot;</span>));<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_thread_id</span> <span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// using a local lock_guard to lock mtx guarantees unlocking on destruction / exception:</span><br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lck</span> <span class="hljs-params">(mtx)</span></span>;<br>        <span class="hljs-built_in">print_even</span>(id);<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::logic_error&amp;) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[exception caught]\n&quot;</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::thread threads[<span class="hljs-number">10</span>];<br>    <span class="hljs-comment">// spawn 10 threads:</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; ++i)<br>        threads[i] = std::<span class="hljs-built_in">thread</span>(print_thread_id,i+<span class="hljs-number">1</span>);<br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; th : threads) th.<span class="hljs-built_in">join</span>();<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>lock_guard的缺点是使用其锁住一个信号量之后，只有等到该lock_guard对象销毁后才能解锁。</p></blockquote><ul><li><code>std::unique_lock</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>       <span class="hljs-comment">// std::cout</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span>         <span class="hljs-comment">// std::thread</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span>          <span class="hljs-comment">// std::mutex, std::unique_lock</span></span><br> <br>std::mutex mtx;           <span class="hljs-comment">// mutex for critical section</span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_block</span> <span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> c)</span> </span>&#123;<br>    <span class="hljs-comment">// critical section (exclusive access to std::cout signaled by lifetime of lck):</span><br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span> <span class="hljs-params">(mtx)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; ++i) &#123;<br>        std::cout &lt;&lt; c;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">th1</span> <span class="hljs-params">(print_block,<span class="hljs-number">50</span>,<span class="hljs-string">&#x27;*&#x27;</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">th2</span> <span class="hljs-params">(print_block,<span class="hljs-number">50</span>,<span class="hljs-string">&#x27;$&#x27;</span>)</span></span>;<br> <br>    th1.<span class="hljs-built_in">join</span>();<br>    th2.<span class="hljs-built_in">join</span>();<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>unique_lock比lock_guard使用灵活很多，具体可以自行查阅。</p></blockquote><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><blockquote><p>死锁其实就是说线程被阻塞并且一直被阻塞无法跳出执行。举一个多个线程造成死锁的例子，两个线程A和B都需要做一个操作，这个操作需要同时涉及两个互斥元a和b才能完成。则当A锁定了互斥元a，B锁定了互斥元b，则此时A会一直阻塞，知道b解锁，B会一直阻塞，直到a解锁。因此最终导致A与B都一直被阻塞不能执行。</p></blockquote><p>上述多个线程造成的死锁的解决方案：</p><ol><li><p>始终使用相同的顺序锁定两个互斥元。</p></li><li><p>c++标准库的<code>std::lock</code>可以同时锁定两个或更多的互斥元。</p></li></ol><p>1个线程造成的死锁其实就是上面提到的在当前线程已经锁住一个互斥量的前提下继续尝试加锁。</p><h1 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h1><blockquote><p>锁粒度是一个文字术语，用来描述由单个锁所保护的数据量。细粒度锁保护着少量数据，粗粒度锁保护着大量的数据。锁粒度够大才能确保所需的数据都被保护，但同时会降低时效性。</p></blockquote><p>可以使用<code>std::unique_lock</code>来灵活的确定锁粒度。一般来说，只应该以执行要求的操作所需的最小可能时间而去持有锁。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] C++并发编程实战. Anthony Williams 著；</li><li>[2] <a href="https://www.cnblogs.com/haippy/p/3237213.html">https://www.cnblogs.com/haippy/p/3237213.html</a>;</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c与c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图片分割之最大流最小割</title>
    <link href="/2021/01/24/2021-01-24-graph-cut/"/>
    <url>/2021/01/24/2021-01-24-graph-cut/</url>
    
    <content type="html"><![CDATA[<p>在图像分割领域，最近几年基于深度学习的方法占据了绝对领先的地位。但是相对于黑匣子的深度学习，传统的方法更有几分味道。这次要介绍的是图割算法，这是一种基于能量优化的方法，在前景背景分割上很有效果。</p><h1 id="1-最大流与最小割"><a href="#1-最大流与最小割" class="headerlink" title="1. 最大流与最小割"></a>1. 最大流与最小割</h1><blockquote><p>在了解图割之前，首先需要了解最大流与最小割的概念。</p></blockquote><h2 id="1-1-最小割min-cut"><a href="#1-1-最小割min-cut" class="headerlink" title="1.1 最小割min-cut"></a>1.1 最小割min-cut</h2><p>举例说明，如下一个有向加权图所示，从顶点<code>S(source)</code>到顶点<code>T(sink)</code>有三条路径，每条路径的代价<code>c(cost)</code>是该路径上所有边的权重之和。最小割的意思就是说通过割断边将图中所有节点划分为两个不相交的集合，<code>S</code>与<code>T</code>分别在其中一个集合中。并且最小割保证所割断的边的权重之和最小：</p><p><img src="/img/graph_cut/graphcut001.jpg" alt="gc"></p><p>可以很明显的发现割断的边是<code>s-&gt;a</code>与<code>b-&gt;t</code>时是最小割。</p><h2 id="1-2-最大流max-flow"><a href="#1-2-最大流max-flow" class="headerlink" title="1.2 最大流max-flow"></a>1.2 最大流max-flow</h2><p>我们将边想象成管道，权重表示流量，那么从<code>S</code>能流入<code>T</code>的最大流量就是<code>2+3=5</code>，而在计算最大流量的过程中，我们可以发现起到约束作用的边是<code>s-&gt;a</code>与<code>b-&gt;t</code>。这也就是最大流。</p><blockquote><p>可以发现，最大流与最小割结果是一致的，其实有人已经证明过（福特-福克森定理）这两者等价。因此可以将最小割问题转化成最大流问题来进行求解。</p></blockquote><h2 id="1-3-最大流问题的求解"><a href="#1-3-最大流问题的求解" class="headerlink" title="1.3 最大流问题的求解"></a>1.3 最大流问题的求解</h2><p>传统求解最大流问题的方法是增广路径算法，原理是利用广度优先搜索在图中搜索所有从<code>S</code>到<code>T</code>的路径，最终找到最大流路径。这种方法几乎是需要遍历图中所有的节点，因此效率很低。因此目前大多是使用基于优化的方法。</p><h1 id="2-图割graph-cut"><a href="#2-图割graph-cut" class="headerlink" title="2. 图割graph-cut"></a>2. 图割graph-cut</h1><blockquote><p>图割算法其实就是将最大流最小割的理论应用到了图像分割的领域。</p></blockquote><p>比如说前景背景分割问题，可以将图像表示为一张无向图<code>G=(V,E)</code>，其中<code>V</code>是顶点集合，<code>E</code>是边集合。在这个图上多添加两个顶点，一个代表前景的<code>S(Source,源)</code>节点，一个代表背景的<code>T(Sink,汇)</code>节点。在初始构造的图中，每个像素顶点都和<code>S</code>与<code>T</code>连接，并且它们之间的边被叫做<code>t-links</code>。如下图：</p><p><img src="/img/graph_cut/graphcut002.jpg" alt="gc"></p><ul><li><p><code>t-links</code>：每个像素节点与类别节点（<code>S/T</code>，t是terminal的缩写）相连的边；</p></li><li><p><code>n-links</code>：像素节点之间边（上面图中每个像素节点只与自身周围的四个像素节点相连，n是neighbour的缩写）；</p></li><li><p><code>Cuts</code>：一组边的集合，<code>Cuts</code>的断开会使得节点<code>S</code>与<code>T</code>之间没有通路，即每个像素只会与<code>S</code>或<code>T</code>中的一个相连接。其中<code>t-links</code>的断裂实现了像素的分类，而<code>n-links</code>的断裂实现了分割；另外！<code>Cuts</code>是最大流或者最小割的结果，其权重之和最小；</p></li></ul><h2 id="2-1-权重costs"><a href="#2-1-权重costs" class="headerlink" title="2.1 权重costs"></a>2.1 权重costs</h2><blockquote><p>由上可知图割算法中如何确定<code>costs</code>至关重要。</p></blockquote><p>在前景背景的分割领域中，前景与背景是有一些外观差异的，这个体现在像素值上。因此<code>t-links</code>对应的权重可以是像素值与目标像素的相似度（因此此类算法可能需要手工给定前景背景的像素初始值），相似度越大，对应的割断代价也越大。</p><p>而对于<code>n-links</code>，上面每个像素节点都只与相邻的四个像素节点相连（<code>n-links</code>），表示临近像素之间属于同一类的概率，同时临近像素之间会有邻域相似性，而相似性较差的区域往往是前景和背景的交界处。即如果相邻的两个像素像素值相似，那么断开该边的代价就会高。</p><h3 id="2-1-1-t-links的权重"><a href="#2-1-1-t-links的权重" class="headerlink" title="2.1.1 t-links的权重"></a>2.1.1 <code>t-links</code>的权重</h3><p>对于一个像素点，其有两条<code>t-links</code>边，分别是连接前景节点S与背景节点T的边。边的权重可以是终端节点的颜色差异。</p><h3 id="2-1-2-n-links的权重"><a href="#2-1-2-n-links的权重" class="headerlink" title="2.1.2 n-links的权重"></a>2.1.2 <code>n-links</code>的权重</h3><p>对于一个像素点，其有周围相邻的像素点之间存在<code>n-links</code>边，在图像分割任务时边的权重一般也是用颜色差异来确定的。</p><blockquote><p>其实上面讲述的还是图的建立，关于图割进行时的能量最小化算法其实也非常重要，但是这个我现在没想到如何简短的说明白，之后再补充。</p></blockquote><h2 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h2><p>如下，对于一个<code>3x3</code>的图，</p><ol><li>首先取两个种子点（即人为指定分别属于前景背景的两个像素点）；</li><li>建立一个图，图中边的粗细表示对应权重的大小；</li><li>找到最大流或最小割的边的组合，完成图像分割；</li></ol><p><img src="/img/graph_cut/graphcut004.jpg" alt="gc"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><p>[1] Boykov Y ,  Kolmogorov V . An experimental comparison of min-cut/max-  flow algorithms for energy minimization in vision[J]. IEEE Transactions  on Pattern Analysis and Machine Intelligence, 2004, 26(9):1124-1137.</p></li><li><p>[2] <a href="https://pengyizhang.github.io/2020/04/07/graphcut/">https://pengyizhang.github.io/2020/04/07/graphcut/</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>镜头的参数与成像</title>
    <link href="/2021/01/17/2021-01-17-lens-camera/"/>
    <url>/2021/01/17/2021-01-17-lens-camera/</url>
    
    <content type="html"><![CDATA[<h1 id="镜头的参数与成像"><a href="#镜头的参数与成像" class="headerlink" title="镜头的参数与成像"></a>镜头的参数与成像</h1><blockquote><p>最近几天手头刚好有一个闲置的变焦镜头，在把玩的同时对相机的成像特点又有了一些理解。为了不让这些理解被丢进记忆的垃圾堆，打算做一些记录和梳理。</p></blockquote><h2 id="镜头"><a href="#镜头" class="headerlink" title="镜头"></a>镜头</h2><p>镜头的参数其实是很多的，主要有</p><ul><li>焦距：可以分为物理焦距与摄影焦距。</li><li>光圈：大小决定了图像的亮度，在拍摄高斯运动物体、曝光时间很短的应用中，应该选用大光圈镜头，以提高亮度。</li><li>景深：指的是在理想对焦状态下物体允许的前后方向的移动量。（在此范围内可以认为成像是清晰地）</li><li>视野范围：比较简单的理解就是有多少度（手头这个最大110°）的视场；</li><li>对应最大ccd尺寸（靶面尺寸）：镜头成像直径可以覆盖的最大CCD芯片的尺寸；<ul><li>镜头的靶面尺寸应该是大于等于镜头的，不然成像会出现黑边；</li><li>该参数一般使用英寸来衡量的，最小的一般是1/4‘’，最大的是1‘’；</li></ul></li><li>接口：比如C、CS等，只要可以和相机接口匹配安装即可；</li></ul><h3 id="焦距"><a href="#焦距" class="headerlink" title="焦距"></a>焦距</h3><ul><li>物理焦距：一个单片凸透镜的焦距指的是<strong>平行光线经过凸透镜汇聚后的一点到透镜中心的距离（如下图所示）</strong>。一般来说，物理焦距在镜片制作完成后就固定了，是不可变的性质。</li></ul><p><img src="/img/lens/phsic_fl.png" alt="camera"></p><p>当然，现在很多镜头其实是<strong>变焦镜头</strong>，这些镜头一般由多片透镜组成，可以通过调节多个透镜之间的相对距离，来对整体的物理焦距进行调整。</p><p><img src="/img/lens/change_fl.png" alt="camera"></p><ul><li>摄影焦距：相信很多人都有对着单片的定焦镜头进行旋转的调焦经历，其实此处调节的不是物理焦距，而是<strong>摄影焦距—即相距，成像平面（cmos芯片）与镜头之间的距离</strong>。</li></ul><p><img src="/img/lens/distance.jpeg" alt="camera"></p><p>通过对相距的调节，使得其与焦距匹配，可以获得清晰的成像。</p><h3 id="调焦的原因"><a href="#调焦的原因" class="headerlink" title="调焦的原因"></a>调焦的原因</h3><p>谈到调焦的原因，首先需要谈到凸透镜的两个光学性质。</p><ul><li>同一个三维点发出的各个方向的光线，经过镜头后必定汇聚于同一点；</li><li>与透镜切面平行的平面上不同的点发出的光线，经过镜头后，汇聚于不同的点；</li></ul><p><img src="/img/lens/image.png" alt="camera"></p><p>上述的两个性质使得：对于与透镜切面平行的一个面，通过调整相距，可以通过透镜清晰成像。如果摄影焦距不当，则会导致一个点不同方向的光线会投影到成像平面上的不同点，出现混叠。</p><h3 id="焦距与距离的关系"><a href="#焦距与距离的关系" class="headerlink" title="焦距与距离的关系"></a>焦距与距离的关系</h3><p>有的时候，我们使用相机拍摄经常会拍摄出如下的照片，只有某个距离的成像是清晰地，更近或者更远的场景成像是模糊的。</p><p><img src="/img/lens/sence_depth1.png" alt="camera"></p><p>这个现象的原因是，<strong>对于距离镜头切面不同距离的点，摄影焦距是不一样的。</strong>如下图所示，A1与A2的摄影焦距显然不同。</p><p><img src="/img/lens/distance2.png" alt="camera"></p><p>因此，根据我们想要拍摄的物体到镜头的距离，我们需要调出一个合适的相距，才能使得该物体在cmos芯片上得到清晰的成像。</p><h3 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h3><p>看到这里，很多人陷入了疑惑：之前我看到的那些清晰的照片都是怎么来的呢？这就要提及景深的概念了。</p><p>事实上，人眼的分辨能力是有限的，因此即使相距与摄影焦距不是完全相同，只要在某个阈值以内，我们看到的成像都是清晰地。而这就带来了景深的概念。<strong>景深指的是某个距离范围</strong>，在这个范围内成的像都可以看作是清晰的。如下图所示。</p><p><img src="/img/lens/sence_depth.png" alt="camera"></p><p>可以想象，如果景深很大的话，随便拍一张图片，也基本都是清楚的。一般来说，景深随着镜头的光圈值、焦距、拍摄距离而变化。</p><ul><li>光圈越小，景深越大；</li><li>物理焦距越小，景深越大；（后两个需要测试确定）</li><li>摄影焦距越大，景深越大；</li></ul><h3 id="光圈"><a href="#光圈" class="headerlink" title="光圈"></a>光圈</h3><p>镜头的光圈影响了进光量，也影响了景深。一般光圈的大小可以用f值来表示，表示开了几分之几。比如说f/2.0表示开了1/2，如下：</p><p><img src="/img/lens/optical.png" alt="camera"></p><p>一般来说，光圈越大，代表进光量越大，那么曝光时间相应的就可以设置的短一点，比较适合用来拍摄快速运动的物体。</p><p>同时，光圈越大，会使得景深变小（如下图），因此也不能无限扩大光圈。</p><p><img src="/img/lens/optical_depth.png" alt="camera"></p><h3 id="镜头的选择"><a href="#镜头的选择" class="headerlink" title="镜头的选择"></a>镜头的选择</h3><ul><li>接口：需要和相机接口匹配（比如当前手头的就是C接口的）；</li><li>CCD尺寸：镜头可支持的最大CCD尺寸应大于选配相机的CCD尺寸（不然最后图像四周会出现黑边）；</li><li>镜头焦距：可以根据相机CCD尺寸(相机型号尺寸)、工作距离、视场大小（也就是物体的高宽等）计算所需的镜头焦距；</li></ul><p><img src="/img/lens/calcu.png" alt="camera"></p><ul><li>镜头光圈范围：根据所需曝光时间、景深等联合决定；</li></ul><h1 id="相机的参数"><a href="#相机的参数" class="headerlink" title="相机的参数"></a>相机的参数</h1><p>上面谈论的主要是镜头的一些参数，但是获得图像的质量不仅仅是由镜头决定的，相机的素质也很重要。下面总结一些相机的比较关键的性质。</p><ul><li>曝光：<ul><li>自动曝光：相机根据图像亮暗程度自动调节曝光时间；<ul><li>这种方式其实如果自动曝光控制的好的话很不错，但是实际使用发现很容易出现过曝的情况；</li></ul></li><li>固定曝光：为相机设置固定的曝光时间；<ul><li>优点：可以根据需要合理设置曝光时间，提高时间戳的准确度等；</li><li>缺点：在不同光源图像亮暗差异会很大，需要一些后处理；</li></ul></li><li>全局曝光（测量学常用）</li><li>卷帘曝光（容易出现运动模糊）</li></ul></li><li>相机靶面尺寸：如果这个尺寸太小，镜头的大视角成像只能投影上去一部分，不利于大视角成像；太大超过镜头的靶面尺寸，会导致出现黑边；</li><li>相机分辨率</li><li>触发方式<ul><li>硬件触发：脉冲触发</li><li>软件触发：往寄存器里写数据触发</li></ul></li><li>帧率（一般与分辨率、像素时钟之间存在耦合）；</li><li>pixel clock：像素时钟频率越高，可达帧率越高；</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1] <a href="https://www.cnblogs.com/YongQiVisionIMAX/p/13872075.html">https://www.cnblogs.com/YongQiVisionIMAX/p/13872075.html</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>多传感器融合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dijkstra算法和astar算法</title>
    <link href="/2021/01/05/2021-01-05-dijkstra-astar/"/>
    <url>/2021/01/05/2021-01-05-dijkstra-astar/</url>
    
    <content type="html"><![CDATA[<h1 id="dijkstra算法和astar算法"><a href="#dijkstra算法和astar算法" class="headerlink" title="dijkstra算法和astar算法"></a>dijkstra算法和astar算法</h1><h2 id="图搜索算法"><a href="#图搜索算法" class="headerlink" title="图搜索算法"></a>图搜索算法</h2><blockquote><p>图搜索算法指在一个类似图的数据结构上进行路径搜索的算法的总称。二维网格地图其实就是一种类似图的数据结构，每个网格代表一个图节点，它连接着自身周围的四个相邻网格（图节点）。</p></blockquote><p>可以将图搜索的图结构转换成搜索树结构。那么最具代表性的两类图搜索算法就是深度优先与广度优先算法。</p><blockquote><p>需要提前强调的一点是，为了不会形成环路，已经访问过的节点需要做标记，并且不再访问。</p></blockquote><h3 id="深度优先算法-Deep-First-Search"><a href="#深度优先算法-Deep-First-Search" class="headerlink" title="深度优先算法-Deep First Search"></a>深度优先算法-Deep First Search</h3><p>可以使用栈（先进后出）这种数据结构来实现。</p><p>![dfs](&#x2F;assets&#x2F;img&#x2F;astar&#x2F;dfs.png)</p><blockquote><p>可以使用栈结构实现，几乎不太可能找到最优解，因此更短的路径大部分没有试过。因此dfs算法实现简单、路径可能不是最优解、寻路时间比较长</p></blockquote><h3 id="广度优先算法-Breadth-First-Search"><a href="#广度优先算法-Breadth-First-Search" class="headerlink" title="广度优先算法-Breadth First Search"></a>广度优先算法-Breadth First Search</h3><p>可以使用队列（先进先出）这种数据结构来实现。</p><p>![bfs](&#x2F;assets&#x2F;img&#x2F;astar&#x2F;bfs.png)</p><blockquote><p>可以使用队列结构实现，由于是逐层遍历的，因此遍历到目标点时肯定可以得到一条最短路径，因此更短的所有路径都已经遍历了，不能到达目标点。因此BFS算法实现简单、路径能找到最优解、算法消耗时间比较大、遍历的点有点多。</p></blockquote><h3 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a>启发式搜索</h3><blockquote><p>传统的广度优先搜索与深度优先搜索它们本质的区别就是每次从当前集合中弹出要读取的节点的规则，BFS是先入先出，使得每次弹出搜索树上深度最小的节点；DFS是先入后出，使得每次弹出搜索树上深度最大的节点；这两种弹出规则下两种方法的优缺点都很明显，并且都没有利用目标节点位置信息。因此后来为了找到一种更优的图搜索算法，就有了启发式搜索算法，启发式搜索算法简单来说就是指根据目标位置人为定义的另一种更合理的规则来弹出集合中的节点，这种规则就是所谓的启发。</p></blockquote><p>最简单的启发式搜索算法就是<strong>贪心算法</strong>。贪心算法的启发规则就是简单的弹出当前集合中距离终点最近的那个节点。当然实际的距离我们是不会提前知道的（虽然一般我们知道起点和终点的位置，但是我们不知道地图或者地图会变化），所以用来做启发的是一种理想中的距离，比如假设没有障碍物的存在，使用欧式（或曼哈顿等）距离来做启发。</p><blockquote><p>其实上述的广度优先与深度优先还有一个缺点，那就是只能在无权图上做规划，因为是以生成树上节点的深度来启发的。</p></blockquote><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>算法要点：</p><ul><li><strong>弹出规则</strong>：g(n)-对于一个节点n，g(n)表示从起点到当前节点已经耗费的总代价。（Dijkstra算法每次<strong>弹出</strong>g(n)最小的那个节点，其实类似BFS，BFS的g(n)为节点在搜索树上的深度）</li><li><strong>更新规则</strong>：对于当前节点n的一个邻居节点m，如果m已经在当前集合中，则根据当前路径（n-&gt;m）重新确定一个g(m)，如果其小于原本的值，则对g(m)进行更新。</li></ul><p>算法伪代码：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">Initial初始化: 初始节点g(X_s)=<span class="hljs-number">0</span>,其他所有节点g(n)=infinite;设计一个数据结构priority queue(自动对其中数据根据g(n)进行排序) <br><span class="hljs-symbol">Loop:</span><br>- <span class="hljs-keyword">if</span> the queue <span class="hljs-built_in">is</span> empty, <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>; break;<br>- Remove the node <span class="hljs-string">&quot;n&quot;</span> <span class="hljs-keyword">with</span> the lowest g(n) <span class="hljs-keyword">from</span> the queue<br>- Mark node <span class="hljs-string">&quot;n&quot;</span> <span class="hljs-keyword">as</span> expanded<br>- <span class="hljs-keyword">if</span> the node <span class="hljs-string">&quot;n&quot;</span> <span class="hljs-built_in">is</span> the goal state, <span class="hljs-keyword">return</span> <span class="hljs-literal">TRUE</span>; break;<br>- <span class="hljs-keyword">For</span> all unexpanded neighbors <span class="hljs-string">&quot;m&quot;</span> <span class="hljs-keyword">of</span> node <span class="hljs-string">&quot;n&quot;</span><br>- <span class="hljs-keyword">if</span> g(m)=infinite<br>- g(m) = g(n) + Cnm<br>- Push node <span class="hljs-string">&quot;m&quot;</span> <span class="hljs-keyword">into</span> the queue<br>- <span class="hljs-keyword">if</span> g(m) &gt; g(n) + Cnm<br>- g(m) = g(n) + Cnm<br>- <span class="hljs-keyword">end</span><br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Loop</span><br></code></pre></td></tr></table></figure><p>![Dijkstra](&#x2F;assets&#x2F;img&#x2F;astar&#x2F;dijkstra.png)</p><blockquote><p>优点：完备的，只要有解一定可以找到最优解。缺点：只利用了到目前为止的成本，没有利用目标位置的信息，这也导致了当图中每条边权重相同时，Dijkstra算法也就退化成了广度优先搜索算法。所以本算法其实就是对BFS的拓展使其可以用于有权图搜索。此类算法盲目穷举进行探索的，都不是启发式搜索算法。</p></blockquote><ul><li>在cpp中上述Priority queue可以使用下面三种方式实现<ul><li><code>std::priority_queue</code></li><li><code>std::make_heap</code></li><li><code>std::mutimap</code></li></ul></li></ul><h2 id="A-star算法"><a href="#A-star算法" class="headerlink" title="A-star算法"></a>A-star算法</h2><p>算法要点：</p><ul><li><strong>累积成本函数</strong>g(n): 从起点到当前节点n累积的成本cost；</li><li><strong>启发函数</strong>h(n): 从当前节点n到目标估计成本cost（类似欧式距离、曼哈顿距离等）；</li><li><strong>估计成本函数</strong> f(n) &#x3D; g(n) + h(n): 经过当前节点n从起始节点到目标节点的估计成本； </li><li><strong>策略</strong>：每次<strong>弹出</strong>f(n)最小的节点<ul><li><strong>更新策略</strong>：对于当前节点n的一个邻居节点m，如果m已经在当前集合中，则根据当前路径（n-&gt;m）重新确定一个g(m)，如果其小于原本的值，则对g(m)进行更新。</li><li>每个被访问（弹出）过的节点n，一定找到了从起点到n的一个最短路径</li></ul></li></ul><p>算法伪代码：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">Initial初始化: 初始节点g(X_s)=<span class="hljs-number">0</span>,其他所有节点g(n)=infinite;初始化所有节点h(n);设计一个数据结构priority queue(自动对其中数据根据g(n)进行排序) <br><span class="hljs-symbol">Loop:</span><br>- <span class="hljs-keyword">if</span> the queue <span class="hljs-built_in">is</span> empty, <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>; break;<br>- Remove the node <span class="hljs-string">&quot;n&quot;</span> <span class="hljs-keyword">with</span> the lowest f(n) <span class="hljs-keyword">from</span> the queue<br>- Mark node <span class="hljs-string">&quot;n&quot;</span> <span class="hljs-keyword">as</span> expanded<br>- <span class="hljs-keyword">if</span> the node <span class="hljs-string">&quot;n&quot;</span> <span class="hljs-built_in">is</span> the goal state, <span class="hljs-keyword">return</span> <span class="hljs-literal">TRUE</span>; break;<br>- <span class="hljs-keyword">For</span> all unexpanded neighbors <span class="hljs-string">&quot;m&quot;</span> <span class="hljs-keyword">of</span> node <span class="hljs-string">&quot;n&quot;</span><br>- <span class="hljs-keyword">if</span> g(m)=infinite<br>- g(m) = g(n) + Cnm<br>- Push node <span class="hljs-string">&quot;m&quot;</span> <span class="hljs-keyword">into</span> the queue<br>- <span class="hljs-keyword">if</span> g(m) &gt; g(n) + Cnm<br>- g(m) = g(n) + Cnm<br>- <span class="hljs-keyword">end</span><br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Loop</span><br></code></pre></td></tr></table></figure><p>![astar](&#x2F;assets&#x2F;img&#x2F;astar&#x2F;astar.png)</p><blockquote><p>由于引入了启发函数h，如果启发函数不合理，A星算法有可能是找不到最优解的（如下图）。如果想保证a星算法可以找到最优解，需要满足任意 h(n)小于等于节点n到终点的实际cost。</p></blockquote><p>![astar_wrong](&#x2F;assets&#x2F;img&#x2F;astar&#x2F;astar1.png)</p><ul><li><strong>加权A星算法</strong>，即使用的$f(n)&#x3D;g(n)+\varepsilon h(n)$，当$\varepsilon &gt;1$时，代表着增加了h(n)的权重，这有可能导致不能得到最优解，但是可以更快的到达目标（有可能提升几十倍 ）。<ul><li>这种方法其实是一种 最优性 vs 速度（贪心算法肯定是最快的，只是不能得到最优解）；</li><li>已经被证明：$cost_{solution} \le \varepsilon cost_{optimal}$，即结果的cost与最优解的cost的关系；</li></ul></li></ul><blockquote><p>如果想查看不同算法的动态效果，<a href="http://qiao.github.io/PathFinding.js/visual/">这个网页</a>提供了在线模拟运行的小程序。</p></blockquote><ul><li>常识强调：<ul><li><code>openlist</code>：也就是维护的priority queue，也就是所有已经扩展过的节点的邻居（不包括已经扩展过的节点）组成的容器；</li><li><code>closelist</code>: 也就是已经扩展过（访问过）的节点组成的容器；</li></ul></li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1] 深蓝学院运动规划课程PPT（高飞老师）。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>算法与数据结构</tag>
      
      <tag>路径规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>鸽群优化</title>
    <link href="/2021/01/05/2021-01-05-pigeon/"/>
    <url>/2021/01/05/2021-01-05-pigeon/</url>
    
    <content type="html"><![CDATA[<h2 id="鸽群优化"><a href="#鸽群优化" class="headerlink" title="鸽群优化"></a>鸽群优化</h2><ul><li><p>鸽子的导航工具</p><ul><li>太阳：鸽子可记忆鸽巢位置不同时刻的太阳高度角和方位角，并通过太阳高度信息进行导航；</li><li>磁场：鸽子上喙结构含有磁感应结构，磁石粒子的信号是通过鼻子经三叉神经反馈给大脑，从而提高导航信息。</li><li>地标：鸽子依靠重力场进行空间定位，通过比较鸽房的陀螺仪设置与其所在地的陀螺仪数值，设定一个初始的返航方向。</li><li>导航工具切换：鸽子会在旅程不同阶段使用不同导航工具：前期依赖太阳和磁场，后期依赖地标。</li></ul><blockquote><p>鸽群优化：收敛速度快，不易陷入局部最优点等优势。</p></blockquote><p>初始（依赖磁场或太阳）</p><p>$V_i^{Nc} &#x3D; V_i^{Nc-1}.e^{-R\times Nc} + rand.(X_{gbest} - X_i^{Nc-1})$</p><p>$X_i^{Nc} &#x3D; X_i^{Nc-1} + V_i^{Nc}$</p><blockquote><p>1.此时的速度通过前一时刻速度还有当前最优位置与当前所在位置的差共同决定；根据速度更新位置。</p><p>2.最优位置$X_{gbest}$是通过比较鸽群中每一个鸽子的位置查看哪个是最好的，然后所有鸽子将向拥有最好位置的鸽子进行方向的调整和飞行。</p><p>3.R是地图和指南针因子，可认为设定为0~1之间的数；Nc是当前迭代次数；$X_{gbest}$是在Nc-1次迭代循环后通过比较所有鸽子的位置，得到的全局最优位置；</p></blockquote><p>后来（根据地标导航）</p><p>$X_i^{Nc} &#x3D; X_i^{Nc-1} + rand.(X_{center}^{Nc-1} - X_i^{Nc-1}) $</p><p>$X_{\text{center}}^{Nc-1} &#x3D; \frac{\sum_{i&#x3D;1}^{N^{Nc-1}} X_{i}^{Nc-1}\cdot F\left(X_i^{Nc-1}\right)}<br>{N^{Nc-1} \cdot \sum_{i&#x3D;1}^{N^{Nc-1}} F\left(X_i^{Nc-1}\right)} $</p><p>$N^{Nc}&#x3D;\frac{N^{Nc-1}}{2}$</p><blockquote><p>1.每次迭代循环中将鸽子的总数N折半一次（第三个式子），根据每只鸽子的当前位置依据评价指标进行排序，排在后半段的鸽子被认为远离目的地并且不熟悉地标，从而被舍弃；</p><p>2.将余下鸽子的中心位置（第二个式子，有甲醛）当成地标作为飞行的参考方向（第三个式子）；</p></blockquote></li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1]北航智能自主系统课件（段海滨老师）。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>多机协同</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统的可观性问题分析</title>
    <link href="/2020/12/17/2020-12-17-nullspace-observable/"/>
    <url>/2020/12/17/2020-12-17-nullspace-observable/</url>
    
    <content type="html"><![CDATA[<h1 id="1-系统可观性问题分析"><a href="#1-系统可观性问题分析" class="headerlink" title="1 系统可观性问题分析"></a>1 系统可观性问题分析</h1><h2 id="1-1-数学基础"><a href="#1-1-数学基础" class="headerlink" title="1.1 数学基础"></a>1.1 数学基础</h2><p>对于一个方程组：$Ax&#x3D;0$，其中$A$维度为$m \times n$（其中列数为未知数的数量），$x$维度为$n \times 1$，则有</p><ul><li>矩阵$A$是列满秩的（$m \ge n$，此处列数也是未知向量x的维数），则每个列向量之间线性无关，则上面方程的只存在0解（$x$对每列进行线性组合）；</li><li>矩阵$A$不是列满秩的，则上面方程存在非零解；</li></ul><p>对于一个矩阵$A$，维度为$m \times n$，所有满足$Ax&#x3D;0$的向量$x$（维度为$n \times 1$）组成的集合$N$，可以证明$N$包含零向量，并且对于线性运算是封闭的，因此$N$是一个向量子空间。这个向量子空间$N$就是矩阵$A$的零空间。一般来说零空间的自由度就是系统的不可观的状态维度。</p><blockquote><p>矩阵$A$可以看作是由一组列向量$C_1,C_2,…,C_n$组成的，则如果这组列向量是线性无关的，则矩阵$A$是列满秩的，并且其零空间中只包含一个零向量；相反，如果这组列向量是线性相关的，则矩阵$A$不是列满秩的，即矩阵的零空间中会包含非零向量。</p></blockquote><p><strong>零空间和可观性</strong>的联系在于：我们将$x$看成当前系统的状态量，$A$看成系统的观测矩阵，则当$x$在零空间的维度上进行变化时，我们通过观测矩阵是发现不了的，也就是对于该观测系统，其零空间维度的状态变化是不可观的。</p><h2 id="1-2-系统的可观性分析"><a href="#1-2-系统的可观性分析" class="headerlink" title="1.2 系统的可观性分析"></a>1.2 系统的可观性分析</h2><p>由上面的描述可知，首先需要找到系统的A矩阵——可观性矩阵，在SLAM系统中，k时刻的观测对系统初始状态的可观性矩阵的定义为<br>$$<br>A_k &#x3D; H_k \Phi(t_k,t_0)<br>$$<br>其中，$H_k$为k时刻的测量雅克比矩阵（比如视觉测量对状态向量的雅克比），$\Phi(t_k,t_0)$为从0时刻到t时刻的状态转移矩阵。</p><p>举一个例子，在黄国权老师的一篇融合gnss测量的vio论文中，有过关于在vio坐标系下系统可观性的探讨。</p><ul><li>1.首先确定k时刻的状态向量：在vio坐标系下imu的位姿、速度，还有一个视觉路标3d位置，vio坐标系与enu坐标系位姿的外参；</li><li>2.然后确定k时刻对系统初始状态的可观性矩阵$A_k$：$H_k$为视觉观测与gnss观测对状态向量的雅克比，$\Phi(t_k,t_0)$为依赖imu的从初始时刻到k时刻的状态转移矩阵；</li><li>3.在重力轴上VIO坐标系相对于ENU坐标系添加一个旋转扰动，获得初始状态的扰动向量，发现这个扰动向量乘以$A_k$等于0，因此可以断定这个扰动向量是系统的一个零空间向量；</li><li>4.在VIO坐标系相对于ENU坐标系的位移上添加一个扰动，获得初始状态的扰动向量，同样发现这个扰动向量乘以$A_k$等于0，又发现一个零空间向量；</li><li>5.因为4中的位移扰动有3个自由度，可以由此找到3个互不相关的扰动向量，由此可以至少确定一个自由度为4的零空间；</li><li>6.由5找到的零空间可以找到该系统的4个不可观方向；</li></ul><blockquote><p>此处多记录一下这篇论文，论文分析了gps与vio松耦合的定位系统的可观性。首先通过上述分析得到在vio坐标系下该系统不可观（我觉得主要是因为vio系下需要维护vio与enu坐标系之间的外参，这个是因为系统需要输出enu坐标，但是设备每次启动，vio和enu之间的外参有可能是不同的）的；而在enu坐标系下系统是完全可观的（额主要就是因为不需要维护vio与enu之间的外参了）</p></blockquote><p>论文中提到关于在vio系下不可观问题的解决方案是：</p><ol><li>系统开机后进行初始化：通过轨迹对齐非线性优化确定enu与vio坐标系之间外参；</li><li>将vio的状态根据1估计的外参转换到enu坐标系下；</li><li>在enu下进行状态传播与更新，不需要再维护vio与enu之间的外参；</li></ol><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1]. Lee, Woosik &amp; Eckenhoff, Kevin &amp; Geneva, Patrick &amp; Huang, Guoquan. (2020). Intermittent GPS-aided VIO: Online Initialization and Calibration. 10.1109&#x2F;ICRA40945.2020.9197029.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pytorch中组成网络的卷积、归一化、relu等常见结构</title>
    <link href="/2020/08/15/2020-08-14-pytorch-network/"/>
    <url>/2020/08/15/2020-08-14-pytorch-network/</url>
    
    <content type="html"><![CDATA[<p>对pytorch中组成网络的各种结构进行介绍记录，防止忘掉。</p><ul><li><a href="#%E6%8F%90%E5%8F%96%E5%B9%B6%E8%B0%83%E6%95%B4%E7%89%B9%E5%BE%81%E7%BB%B4%E5%BA%A6">第一类-提取特征并调整网络结构的层</a></li><li><a href="#%E5%BD%92%E4%B8%80%E5%8C%96%E8%B0%83%E6%95%B4%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4%E5%B1%82">第二类-归一化调整数值范围层</a></li><li><a href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E5%B1%82">第三类-非线性激活函数层</a></li></ul><h1 id="提取并调整特征维度"><a href="#提取并调整特征维度" class="headerlink" title="提取并调整特征维度"></a>提取并调整特征维度</h1><h2 id="2维卷积层torch-nn-Conv2d"><a href="#2维卷积层torch-nn-Conv2d" class="headerlink" title="2维卷积层torch.nn.Conv2d"></a>2维卷积层<code>torch.nn.Conv2d</code></h2><blockquote><p>卷积操作主要用来提取图像特征，卷积过程可以参考我之前的一篇<a href="https://xhy3054.github.io/cnn-base/">文章</a>中的一个动图。</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py">CLASS torch.nn.Conv2d(in_channels: <span class="hljs-built_in">int</span>, <br>out_channels: <span class="hljs-built_in">int</span>, <br>kernel_size: <span class="hljs-type">Union</span>[<span class="hljs-built_in">int</span>, <br><span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]], <br>stride: <span class="hljs-type">Union</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]] = <span class="hljs-number">1</span>, <br>padding: <span class="hljs-type">Union</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]] = <span class="hljs-number">0</span>, <br>dilation: <span class="hljs-type">Union</span>[<span class="hljs-built_in">int</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]] = <span class="hljs-number">1</span>, <br>groups: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span>, <br>bias: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">True</span>, <br>padding_mode: <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;zeros&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>in_channels</code>：一个整型，表示输入通道数；</li><li><code>out_channels</code>：一个整型，表示输出通道数；</li><li><code>kernel_size</code>：卷积核尺寸，可以是一个整型数，也可以是一个包含两个整型的tuple，一个整数时默认长宽相同；</li><li><code>stride</code>： 输入可以是一个整型号，也可以是一个包含两个整型的tuple；表示步长；一般步长也可以看作提取到的特征相对于原图尺寸缩小的倍数；</li><li><code>padding</code>：输入可以是一个整型号，也可以是一个包含两个整型的tuple；表示默认在图像边缘补0的尺寸，输入一个tuple的话，第一个数表示高度上，第二个表示宽度上填充的尺寸；比如当为1时，表示原图基础上，上下左右各补了一行；</li><li><code>dilation</code>：输入可以是一个整型号，也可以是一个包含两个整型的tuple；表示卷积核的扩张尺寸，也是核点之间的间距；</li><li><code>groups</code>: 范围从1到<code>in_channels</code>，默认是1，表示所有每个输出通道都包含了所有输入通道的信息；如果为2，则一半的输出通道是由一半的输入通道产生的，另一半的输出通道是由剩下一半的输入通道产生；如果为<code>in_channels</code>，表示每个输入通道都有自己单独的卷积核，卷积核输出维度为<code>out_channels/in_channels</code>；</li></ul><h2 id="上采样层torch-nn-PixelShuffle"><a href="#上采样层torch-nn-PixelShuffle" class="headerlink" title="上采样层torch.nn.PixelShuffle"></a>上采样层<code>torch.nn.PixelShuffle</code></h2><blockquote><p>主要用来重新排列一个维度(x, C<em>r^2, H, W)的tensor为一个维度(x, C, H</em>r, W<em>r)的tensor。这种做法是16年一篇论文提出的超分辨率方法，主要思想是对于（1, H, W）维度的图像，为了将其放大r倍，首先使用卷积网络提取得到(r^2, H, W)维度的深层特征；然后使用PixelShuffle对深层特征重新排列，得到一个(1, H</em>r, W*r)的高分辨的图像。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">CLASS torch.nn.PixelShuffle(upscale_factor: <span class="hljs-built_in">int</span>)<br></code></pre></td></tr></table></figure><ul><li><code>upscale_factor</code>：int类型，上采样的倍数，也是上面的r；</li></ul><h1 id="归一化调整数值范围层"><a href="#归一化调整数值范围层" class="headerlink" title="归一化调整数值范围层"></a>归一化调整数值范围层</h1><h2 id="批处理归一化层torch-nn-BatchNorm2d"><a href="#批处理归一化层torch-nn-BatchNorm2d" class="headerlink" title="批处理归一化层torch.nn.BatchNorm2d"></a>批处理归一化层<code>torch.nn.BatchNorm2d</code></h2><blockquote><p>批处理归一化层主要用来进行数据归一化，使得在relu之前不会因数据过大而导致网络性能不稳定。对于一个（1,3，H,W）的输入，主要的处理如下：</p></blockquote><p>$$y&#x3D;\frac{x-\mathrm{E}[x]}{\sqrt{\operatorname{Var}[x]+\epsilon}} * \gamma+\beta$$</p><p>上面计算是对3个通道分别进行的，其中x为一个一个像素位置多个通道值组成的向量，E为每个通道的平均数组成的向量，var为每个通道的标准差组成的向量，$\epsilon$是为了数值稳定性在分母上增加的值，$\gamma$（默认1）和$beta$（默认0）为可学习的参数向量（维度为通道数）。上面公式写成向量形式，但是实际理解可以是对特征的每个通道分别执行上式。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">CLASS torch.nn.BatchNorm2d(num_features, <br>eps=<span class="hljs-number">1e-05</span>, <br>momentum=<span class="hljs-number">0.1</span>, <br>affine=<span class="hljs-literal">True</span>, <br>track_running_stats=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><ul><li><code>num_features</code>：当前要处理的特征层的通道数（一开始rgb图像的话是3）；</li><li><code>eps</code>：也就是上面公式中的$\epsilon$，为数值稳定性在分母上增加的值。默认为：1e-5；</li><li><code>momentum</code>：一个用于运行过程中均值和方差的一个估计参数（我的理解是一个稳定系数，类似于SGD中的momentum的系数）；</li><li><code>affine</code>：当设为true时，该模块拥有可以学习的系数$\gamma$和$beta$；</li><li><code>track_running_stats</code>: 是否跟踪均值和标准差的计算；</li></ul><h2 id="归一化层torch-nn-functional-normalize"><a href="#归一化层torch-nn-functional-normalize" class="headerlink" title="归一化层torch.nn.functional.normalize"></a>归一化层<code>torch.nn.functional.normalize</code></h2><blockquote><p>在指定的维度上执行$L_p$归一化操作，其实就是在某个维度上对每个元素做$L_p$操作并做sum，然后当前元素值为原值除以sum，公式为：</p></blockquote><p>$$v&#x3D;\frac{v}{\max \left(|v|_{p}, \epsilon\right)}$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.nn.functional.normalize(<span class="hljs-built_in">input</span>: torch.Tensor, <br>p: <span class="hljs-built_in">float</span> = <span class="hljs-number">2</span>, <br>dim: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span>, <br>eps: <span class="hljs-built_in">float</span> = <span class="hljs-number">1e-12</span>, <br>out: <span class="hljs-type">Optional</span>[torch.Tensor] = <span class="hljs-literal">None</span>) → torch.Tensor<br></code></pre></td></tr></table></figure><ul><li><code>input</code>：任意shape的tensor输入；</li><li><code>p</code>：范数的指数，默认为2，即$L_2$范数；</li><li><code>dim</code>：计算范数的维度，默认是1；</li><li><code>out</code>：the output tensor. If out is used, this operation won’t be differentiable.</li></ul><h2 id="层torch-nn-functional-softplus"><a href="#层torch-nn-functional-softplus" class="headerlink" title="层torch.nn.functional.softplus"></a>层<code>torch.nn.functional.softplus</code></h2><blockquote><p>逐元素执行如下操作，note:为了数值稳定，当$\beta x &gt; threshold$时实现变为线性函数。</p></blockquote><p>$$\text { Softplus }(x)&#x3D;\frac{1}{\beta} * \log (1+\exp (\beta * x))$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.nn.functional.softplus(<span class="hljs-built_in">input</span>, beta=<span class="hljs-number">1</span>, threshold=<span class="hljs-number">20</span>) → Tensor<br></code></pre></td></tr></table></figure><h2 id="层torch-nn-functional-softmax"><a href="#层torch-nn-functional-softmax" class="headerlink" title="层torch.nn.functional.softmax"></a>层<code>torch.nn.functional.softmax</code></h2><blockquote><p>也是一种归一化操作，沿着某个维度执行如下操作，使得该维度向量每个元素值在0到1之间，并且和为1。</p></blockquote><p>$$\operatorname{Softmax}\left(x_{i}\right)&#x3D;\frac{\exp \left(x_{i}\right)}{\sum_{j} \exp \left(x_{j}\right)}$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.nn.functional.softmax(<span class="hljs-built_in">input</span>: torch.Tensor, <br>dim: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>] = <span class="hljs-literal">None</span>, <br>_stacklevel: <span class="hljs-built_in">int</span> = <span class="hljs-number">3</span>, <br>dtype: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>] = <span class="hljs-literal">None</span>) → torch.Tensor<br></code></pre></td></tr></table></figure><ul><li><code>input</code>：输入tensor；</li><li><code>dim</code>：沿着这个维度执行softmax</li><li><code>dtype</code>：如果指定类型，在执行操作前需要将输入被转换为该类型；</li></ul><h1 id="非线性激活函数层"><a href="#非线性激活函数层" class="headerlink" title="非线性激活函数层"></a>非线性激活函数层</h1><h2 id="修正线性单元层torch-nn-ReLU"><a href="#修正线性单元层torch-nn-ReLU" class="headerlink" title="修正线性单元层torch.nn.ReLU"></a>修正线性单元层<code>torch.nn.ReLU</code></h2><blockquote><p>主要是执行非线性变换。Relu的非线性变换是大于0时不变，小于0时置为0，特点是瘦脸快，求梯度简单。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">CLASStorch.nn.ReLU(inplace: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li><code>inplace</code>：是否在原数据上操作；</li></ul><h2 id="第二种激活函数torch-nn-ELU"><a href="#第二种激活函数torch-nn-ELU" class="headerlink" title="第二种激活函数torch.nn.ELU"></a>第二种激活函数<code>torch.nn.ELU</code></h2><blockquote><p>对每个元素执行如下操作：</p></blockquote><p>$$ ELU(x)&#x3D;max(0,x)+min(0,α∗(exp(x)−1)) $$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">CLASStorch.nn.ELU(alpha: <span class="hljs-built_in">float</span> = <span class="hljs-number">1.0</span>, inplace: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li><code>alpha</code>：上面公式中的$\alpha$值，默认为1；</li><li><code>inplace</code>：是否在原数据位置进行操作；</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1] pytorch官方文档</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pycharm远程调试</title>
    <link href="/2020/08/14/2020-08-14-pychram-remote/"/>
    <url>/2020/08/14/2020-08-14-pychram-remote/</url>
    
    <content type="html"><![CDATA[<p>我们在本地windows使用各种IDE可以很方便的调试代码，但是有的项目对内存或者显存需求量很大，本地的机器很难满足。实验室刚好有一个linux服务器，内存够大，gpu够给力，不过我没有在服务器上安装IDE的权限，于是就鼓捣了一下pycharm的远程调试。</p><h1 id="pycharm远程调试"><a href="#pycharm远程调试" class="headerlink" title="pycharm远程调试"></a>pycharm远程调试</h1><p>pycharm的远程调试其实就是利用ssh先将本地工程拷贝到远程服务器上，然后在远程服务器上运行，所以我们需要给pycharm提供以下的信息：</p><ol><li><p>远程服务器ip，用户名，密码；</p></li><li><p>工程使用的python解释器（一般是远程服务器上anaconda的一个环境）；</p></li><li><p>本地工程文件夹与远程服务器上的工程文件夹的对应关系；</p></li></ol><h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><ul><li><p>首先使用pycharm打开本地的工程目录；</p></li><li><p>依次打开<code>File</code>-&gt;<code>Setting</code>-&gt;<code>Project:工程名</code>-&gt;<code>Project Interpreter</code>；</p></li></ul><p><img src="/img/pycharm/pycharm1.PNG" alt="pycharm"></p><ul><li>选择<code>Project Interpreter</code>最右侧的那个设置按钮点<code>add</code>，新界面选择<code>SSH Interpreter</code>;</li></ul><p><img src="/img/pycharm/pycharm2.PNG" alt="pycharm"></p><ul><li>在<code>New server configuration</code>中输入ip和用户名，点击<code>Next</code>，输入密码连接后;</li></ul><p><img src="/img/pycharm/pycharm3.PNG" alt="pycharm"></p><ul><li><p>其中<code>Interpreter</code>是远程服务器中你想使用的python环境地址，<code>Sync folders</code>是本地和远程的工程文件夹对应关系，两个同名文件夹，设置完后选择<code>Finish</code>;</p></li><li><p>然后pycharm会自动将本地工程复制到远程服务器上。</p></li><li><p>复制完毕后，要想远程调试还需要<code>Run</code>-&gt;<code>edit Configurations</code>，然后在这个界面中选择运行和调试时使用的python解释器<code>Python interpreter</code>，还有通过<code>Parameters</code>设置运行时的参数输入。</p></li></ul><p><img src="/img/pycharm/pycharm4.PNG" alt="pycharm"></p><ul><li><p>大功告成，可以调试了。</p></li><li><p>如果想对远程服务器进行管理，可以<code>Tools</code>-&gt;<code>Deployment</code>-&gt;<code>configure</code>进行改名、新建、删除等，其中<code>Encoding for client-server communication</code>是与服务器通信的编码方式，可以设置成<code>UTF-8</code>(如果包含中文的话)；</p></li></ul><p><img src="/img/pycharm/pycharm5.PNG" alt="pycharm"></p>]]></content>
    
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双目相机模型与标定</title>
    <link href="/2020/08/08/2020-08-08-stereo-vision/"/>
    <url>/2020/08/08/2020-08-08-stereo-vision/</url>
    
    <content type="html"><![CDATA[<p>单目相机无法恢复真实尺度，使得双目相机成为了很多开发者的选择。</p><h1 id="双目相机模型"><a href="#双目相机模型" class="headerlink" title="双目相机模型"></a>双目相机模型</h1><p>双目恢复深度进行三维重建的原理与人眼类似，为了进一步分析双目测距的原理，可以从下图深入理解双目相机模型：</p><p><img src="/img/stereo/stereo.PNG" alt="stereo"></p><p>双目相机一般由左眼和右眼两个<strong>水平放置</strong>的相机组成。上图中左右两个相机都是使用针孔相机模型，两个相机的成像平面在同一个水平面上，同时两个相机光心是水平放置的，因此对于一个P点，其在两个图像上的投影点的行坐标是相同的，我们通过对其纵坐标的处理便可以得到视差了。</p><p>图中两个相机光心之间的距离b被成为双目相机的<strong>基线</strong>，是与焦距f一样重要的参数。</p><p>根据上图，假设一个空间点P，在左右目各成一像$P_L$与$P_R$，分别以两个光心垂直的位置为二维坐标原点，则$P_L$的横坐标为$u_L$，$P_R$的横坐标为$u_R$，可以发现$u_R$是一个负数。根据上图中右侧三角形相似的原理，可以得到下面公式</p><p>$$\frac{z-f}{z}=\frac{b-u_{L}+u_{R}}{b}$$</p><p>经过整理，可以得到</p><p>$$ z = \frac{fb}{d}, d= u_L -u_R $$</p><p>此处d为投影点在左右图上的横坐标之差，也叫作<strong>视差</strong>，因此，根据视差我们就可以估计出这个空间点的深度了。此处可以发现，视差最小也就是1个像素，因此双目可以测量的最大深度是有上限的，而这个值和$fb$有关，所以一般相机焦距f确定的时候，双目基线越大，可测量的最远深度也越大。</p><blockquote><p>由于以上双目相机模型的特殊，我们不仅可以方便的估计深度，也可以在双目匹配时很容易的进行极线（横坐标一致的水平线）搜索匹配，大大减小匹配计算量。</p></blockquote><h1 id="双目立体标定"><a href="#双目立体标定" class="headerlink" title="双目立体标定"></a>双目立体标定</h1><p>上面讲述了双目相机模型的原理，我们可以发现这是一个很苛刻的条件，要求两个相机光心在同一水平线上，并且成像平面平行。这个在双目相机的制作中很难做到。因此在获得一个双目相机后，需要对其进行双目标定，得到两个$3*4$的投影矩阵H1和H2，在两个相机成像分别使用这两个矩阵进行投影后得到两个新的矫正后的图像，此时校正后的两个图像应该是满足上面的双目相机模型的。整个矫正过程如下所示 </p><p><img src="/img/stereo/stereo_rectify.gif" alt="stereo"></p><h2 id="opencv进行双目标定"><a href="#opencv进行双目标定" class="headerlink" title="opencv进行双目标定"></a>opencv进行双目标定</h2><h3 id="知道内参"><a href="#知道内参" class="headerlink" title="知道内参"></a>知道内参</h3><blockquote><p>对于一个已经标定的双目相机（已知内参、畸变参数等），在opencv中可以使用<code>cv:StereoRectify</code>来完成双目矫正矩阵的获得（不只是矫正矩阵，还有两个相机之间的位姿变换，视差到深度的4*4映射矩阵等）；</p></blockquote><p>这种方法也称为(Bouguet)方法，需要先分别对两个相机进行标定，分别得出两个相机的内参数矩阵，然后再进行立体标定，进行立体图像的矫正。具体可以去opencv官网查看，函数介绍比较清晰。</p><h3 id="不知道内参"><a href="#不知道内参" class="headerlink" title="不知道内参"></a>不知道内参</h3><blockquote><p>对于一个没有标定的双目相机，可以使用opencv中<code>cv::stereoRectifyUncalibrated</code>函数来获得双目的矫正矩阵H1和H2，分别使用这两个矩阵对图像做单应变换，即可矫正图像。</p></blockquote><p>这种方法也叫非标定方法也称为（Hartley)方法，有时候我们不知道相机的内参矩阵，而且也不用知道内参数具体是多少，因为我们仅关心如何得到两幅图像的稠密匹配，或者两幅图像之间的视差图或者深度图就足够了。因为不知道相机的内参数，所以只能借助对极约束来解决问题了，通过计算两幅图像的基础矩阵F，然后利用对极约束条件中对极线为平行且行对准，可以很好的实现目标。</p><p><img src="/img/stereo/stereo_rectify1.PNG" alt="stereo"></p><p>第三个参数是本质矩阵可以通过<code>cv::findFundamentalMat</code>获得，需要说明一点，该函数的前两个参数<code>Mat&amp; points1, Mat&amp; points2</code>与<code>cv::findFundamentalMat</code>的前两个参数并不是相同的数据结构。它们虽然可以是同一个匹配点集，但是他们的数据结构是完全不同的！<code>cv::findFundamentalMat</code>中传入的匹配点集要求是2xN或者Nx2的矩阵，但是<code>cv::stereoRectifyUncalibrated</code>中要求传入的匹配点集必须是1x2N或者2Nx1的矩阵！在很多文档中都说他们的参数是一样的，这其实是一个天大的错误，如果用计算F的匹配点集直接传给图像矫正函数，程序将直接崩溃。正确的做法是利用cv::Mat的构造函数，直接从vector<Point2f>构造一个cv::Mat传入。</p><p><code>cv::stereoRectifyUncalibrated</code>函数默认原始图像是没有径向畸变的，因此在矫正图像之前，最好先对原始图像做径向矫正。另外需要注意的一点，函数返回的单应变换矩阵H1和H2都是double类型，也即CV_64F类型，若不是该类型的矩阵，与之相乘会报错。    </p><h3 id="生成映射矩阵"><a href="#生成映射矩阵" class="headerlink" title="生成映射矩阵"></a>生成映射矩阵</h3><blockquote><p>在双目立体标定之后，需要根据标定结果生成新的映射表，然后通过映射表完成矫正。</p></blockquote><p>映射表的生成使用如下函数，这个函数需要使用两遍，如下这边是得到左目的映射表，这个映射函数的原理可以查看opencv的docs，关于该函数有详细的公式推导</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cv::<span class="hljs-built_in">initUndistortRectifyMap</span>(            <span class="hljs-comment">//计算无畸变和修正转换映射</span><br>    K_l,                                <span class="hljs-comment">//输入：相机内参矩阵 (单目标定阶段得到的相机内参矩阵)</span><br>    D_l,                                <span class="hljs-comment">//输入：单目标定阶段得到的相机的去畸变参数</span><br>    R_l,                                <span class="hljs-comment">//输入：可选的修正变换矩阵,3*3, 从 cv::stereoRectify 得来.如果这个矩阵为空矩阵,那么就将会被设置成为单位矩阵</span><br>    P_l.<span class="hljs-built_in">rowRange</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>).<span class="hljs-built_in">colRange</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>),    <span class="hljs-comment">//输入：新的相机内参矩阵（后续根据这个矩阵来进行投影变换，畸变已经没有了）</span><br>    cv::<span class="hljs-built_in">Size</span>(cols_l,rows_l),            <span class="hljs-comment">//在去畸变之前的图像尺寸</span><br>    CV_32F,                             <span class="hljs-comment">//第一个输出映射的类型，映射x</span><br>    M1l,                                <span class="hljs-comment">//输出：第一个输出映射表，映射y</span><br>    M2l);                               <span class="hljs-comment">//输出：第二个输出映射</span><br></code></pre></td></tr></table></figure><p>得到映射表后，可以通过如下函数完成映射：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cv::<span class="hljs-built_in">remap</span>(              <span class="hljs-comment">//重映射，就是把一幅图像中某位置的像素放置到另一个图片指定位置的过程。</span><br>            imLeft,             <span class="hljs-comment">//输入图像</span><br>            imLeftRect,         <span class="hljs-comment">//输出图像</span><br>            M1l,                <span class="hljs-comment">//第一个映射矩阵表， 作用是对于输出图像某个位置（x,y），M1l(x,y)处的值为一个x1坐标</span><br>            M2l,                <span class="hljs-comment">//第二个映射矩阵，作用是对于输出图像某个位置（x,y），M2l(x,y)处的值一个y1坐标, remap函数将输入图像(x1,y1)处的值赋值给输出图像（x,y）位置处</span><br>            cv::INTER_LINEAR);<br></code></pre></td></tr></table></figure><p>至此，大功告成得到的imLeftRect便是修正后的左目图像了，与同样修正后的右目图像满足上面介绍的双目相机模型</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1]. 视觉slam十四讲</li><li>[2]. <a href="https://blog.csdn.net/jaccen/article/details/51217936">https://blog.csdn.net/jaccen/article/details/51217936</a></li><li>[3]. <a href="https://docs.opencv.org/4.2.0/d9/d0c/group__calib3d.html#gaadc5b14471ddc004939471339294f052">https://docs.opencv.org/4.2.0/d9/d0c/group__calib3d.html#gaadc5b14471ddc004939471339294f052</a></li><li>[4]. <a href="https://blog.csdn.net/u010368556/article/details/86484695">https://blog.csdn.net/u010368556/article/details/86484695</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自监督学习备忘</title>
    <link href="/2020/07/13/2020-07-13-self-supervised-learning/"/>
    <url>/2020/07/13/2020-07-13-self-supervised-learning/</url>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#第一类-基于数据生成的任务">第一类-基于数据生成的任务</a></li><li><a href="#第二类-基于数据变换的任务">第二类-基于数据变换的任务</a></li><li><a href="#第三类-基于多模态数据的自监督任务">第三类-基于多模态数据的自监督任务</a></li><li><a href="#对比学习">对比学习</a></li></ul><blockquote><p>以下转载自<a href="https://zhuanlan.zhihu.com/p/66063089">知乎的一篇文章</a></p></blockquote><p>自监督学习（self-supervised learning）可以被看作是机器学习的一种“理想状态”，模型直接从无标签数据中自行学习，无需标注数据。本文主要对当前自监督学习涉及到的一些方面进行总结（笔记）。</p><h1 id="自监督学习简介"><a href="#自监督学习简介" class="headerlink" title="自监督学习简介"></a>自监督学习简介</h1><ol><li>自监督学习的核心，在于如何自动为数据产生标签。例如输入一张图片，把图片随机旋转一个角度，然后把旋转后的图片作为输入，随机旋转的角度作为标签。再例如，把输入的图片均匀分割成3*3的格子，每个格子里面的内容作为一个patch，随机打乱patch的排列顺序，然后用打乱顺序的patch作为输入，正确的排列顺序作为label。类似这种自动产生的标注，完全无需人工参与。</li><li>自监督学习如何评价性能？自监督学习性能的高低，主要通过模型学出来的feature的质量来评价。feature质量的高低，主要是通过迁移学习的方式，把feature用到其它视觉任务中（分类、分割、物体检测…），然后通过视觉任务的结果的好坏来评价。目前没有统一的、标准的评价方式。</li><li>自监督学习的一个研究套路。前面说到，自监督学习的核心是如何给输入数据自动生成标签。之前的很多工作都是围绕这个核心展开的。一般的套路是：首先提出一个新的自动打标签的辅助任务（pretext task，例如：旋转图片、打乱patch顺序），用辅助任务自动生成标签，然后做实验、测性能、发文章。每年都有新的辅助任务被提出来，自监督学习的性能也在不断提高，有的甚至已经接近监督学习的性能。总体上说，或者是提出一种完全新的辅助任务，或者是把多个旧的辅助任务组合到一起作为一个“新”的辅助任务。</li></ol><blockquote><p>以下转载自<a href="https://zhuanlan.zhihu.com/p/125721565">另一篇知乎文章</a></p></blockquote><h1 id="自监督学习与监督学习和无监督学习的比较"><a href="#自监督学习与监督学习和无监督学习的比较" class="headerlink" title="自监督学习与监督学习和无监督学习的比较"></a>自监督学习与监督学习和无监督学习的比较</h1><p>手动数据注释是监督学习中必不可少的步骤，这是耗时，费力且有噪声的。与有监督的方法不同，无监督的方法不依赖于人类注释，并且通常集中在数据良好表示（例如平滑度，稀疏性和分解）的预设先验上。无监督方法的经典类型是聚类方法，例如高斯混合模型，它将数据集分解为多个高斯分布式子数据集。然而，非监督学习学习由于预设先验的一般性较差而不太值得信赖，在某些数据集（例如非高斯子数据集）上选择将数据拟合为高斯分布可能是完全错误的。</p><p>自我监督方法可以看作是一种具有监督形式的特殊形式的非监督学习方法，这里的监督是由自我监督任务而不是预设先验知识诱发的。与完全不受监督的设置相比，自监督学习使用数据集本身的信息来构造伪标签。在表示学习方面，自我监督学习具有取代完全监督学习的巨大潜力。人类学习的本质告诉我们，大型注释数据集可能不是必需的，我们可以自发地从未标记的数据集中学习。更为现实的设置是使用少量带注释的数据进行自学习。这称为Few-shot Learning。</p><p>在自监督学习中，如何自动获取伪标签至关重要。 根据伪标签的不同类型，我将自我监督的表示学习方法分为4种类型：基于数据生成(恢复)的任务，基于数据变换的任务，基于多模态的任务，基于辅助信息的任务。</p><h2 id="第一类-基于数据生成的任务"><a href="#第一类-基于数据生成的任务" class="headerlink" title="第一类-基于数据生成的任务"></a>第一类-基于数据生成的任务</h2><p>对于第一种类型，其实自监督学习与非监督学习本质上是基本相同的。所有的非监督学习方法，例如数据降维(PCA:在减少数据维度的同时最大化的保留原有数据的方差)，数据拟合分类(GMM: 最大化高斯混合分布的似然)， 本质上都是为了得到一个良好的数据表示并希望其能够生成(恢复)原始输入。这也正是目前很多的自监督学习方法赖以使用的监督信息。基本上所有的encoder-decoder模型都是以数据恢复为训练损失。</p><p>自监督学习的出发点是考虑在缺少标签或者完全没有标签的情况下，依然学习到能够表示原始图片的良好有意义的特征。那么什么样的特征是良好有意义的呢？在第一类自监督任务——数据恢复任务中，能够通过学习到的特征还原生成原始数据的特征，我们认为是良好有意义的。看到这里，实际上大家能够联想到自动编码器类的模型，甚至更简单的PCA。实际上，几乎所有的非监督学习方法都是以这个原则作为基础的。包括非常火的GAN</p><blockquote><p>GAN的核心是通过Discriminator去缩小Generator distribution和real distribution之间的距离。GAN的学习过程不需要人为进行数据标注，其监督信号也即是优化目标就是使得上述对抗过程趋向平稳。</p></blockquote><p>这里我们以两篇具体的paper为例子，介绍数据恢复类的自监督任务如何操作实现。我们的重点依然是视觉问题，这里分别介绍一篇图片上色的文章和一篇视频预测的文章。其余的领域比如NLP，其本质是类似的，在弄清楚了数据本身的特点之后，可以先做一些低级的照猫画虎的工作。</p><h3 id="上色任务"><a href="#上色任务" class="headerlink" title="上色任务"></a>上色任务</h3><p>设计自监督任务时需要一些巧妙的思考。比如图片色彩恢复任务，我们已有的数据集是一张张的彩色图片，假如去掉色彩，作为感性思考者的我们，是否能够从黑白图片中显示的内容推测原来图片真实的色彩？对于一个婴儿来说可能很难，但是对于我们来说，生活的经历告诉我们瓢虫应当是红色的(下图第二行中)。我们是如何做出预测的？事实上，我们通过观察大量的瓢虫，在脑中建立了从“瓢虫”到“红色”的映射。</p><p>把这个学习过程推广到我们的模型上，在给定黑白输入的情况下，我们用正确的彩色的原始图像作为学习的标签，从而模型会试着理解原始黑白图像中“每个区域”是“什么”进而去建立从是“什么”到“不同颜色”的映射。</p><p>当我们完成训练，模型的中间层feature map就得到了类似人脑对于“瓢虫”以及其他物体的记忆，以向量的形式。</p><h3 id="视频预测——下一秒你会在哪里？"><a href="#视频预测——下一秒你会在哪里？" class="headerlink" title="视频预测——下一秒你会在哪里？"></a>视频预测——下一秒你会在哪里？</h3><blockquote><p>一般来说，视觉问题分成图片和视频两大类，图片数据可以认为具有i.i.d特性，而视频是由多个图片帧构成的，可以认为具有一定的Markov dependency，时序关系是他们之间最大的不同。比如最简单的思路，利用CNN提取单张图片特征可以做图片分类，再加入一个RNN或者LSTM去刻画Markov Dependency，便可以应用到视频上。</p></blockquote><p>视频预测任务十分的耿直。怎么形容呢，他就是那种，你知道的，我们说视频中帧与帧之间存在时空连续性。类似的，人类会利用这种帧与帧之间的连续性，当我们看电影时突然按了暂停，下一秒下几秒会发生什么实际上我们是可以预测的。</p><p>同样，把这个学习过程推广到我们的模型上，在给定前一帧或者前几帧的情况下，我们用后续的视频帧作为学习的标签，从而模型会试着理解给定视频帧中的语义信息(发生了啥？)进而去建立从当前到未来的映射关系。</p><h2 id="第二类-基于数据变换的任务"><a href="#第二类-基于数据变换的任务" class="headerlink" title="第二类-基于数据变换的任务"></a>第二类-基于数据变换的任务</h2><p>这种类型的自监督学习是大家熟知的窄意的自监督学习。本文<a href="https://arxiv.org/pdf/1803.07728.pdf">链接</a></p><p>用一句话说明这一类任务，事实上原理很简单。对于样本 X ，我们对其做任意变换 T(X)=Y ，则自监督任务的目标是能够对生成的 Y 估计出其变换 T。下面介绍一种原理十分简单但是目前看来非常有效的自监督任务——Rotation Prediction。</p><p>给定输入图片 X ，我们对其做4个角度的旋转，分别得到 $X_0, X_1, X_2, X_3$ ,并且我们知道其对应的变换角度分别为 0°，90°，180°，270° 。此时，任务目标即是对于以上4张图片预测其对应的旋转角度，这里每张图片都经过同样的卷积神经网。</p><blockquote><p>我始终坚持的观点是自监督学习需要动机明确，这里我们能做的任意变换应当是对目标有益的。比如在Rotation Prediction中，作为人类的我们只有在理解了图片中是一只鸟站在枝头之后才知道X_0的旋转角度应当是 0° 。那么我们有理由相信，当模型能够做出同样正确的判断时，其中间的feature map必然携带了有意义的图片语义信息。</p></blockquote><h2 id="第三类-基于多模态数据的自监督任务"><a href="#第三类-基于多模态数据的自监督任务" class="headerlink" title="第三类-基于多模态数据的自监督任务"></a>第三类-基于多模态数据的自监督任务</h2><p>下面介绍一种典型的多模态数据，是的，你没有猜错，就是伴随声音信息的视频数据。我们平时看到的短视频，电影实际上都属于这一类多模态数据。基于多模态数据进行自监督学习其内含的假设是，视频每一帧的内容与对应的音轨应当存在相关性，比如在一段乐器演奏视频中，人类能够通过观察乐器的种类在脑海中想象出不同的音色（当然我并不懂乐器），同样的，在听到一段旋律的时候，人类能够通过已有的知识判断出这是来自那种乐器（当然我也并不能）。</p><blockquote><p>本篇论文<a href="https://arxiv.org/pdf/1705.08168.pdf">链接</a></p></blockquote><p><img src="/img/self-supervised/s1.jpg" alt="self-supervised"></p><p>文中将此任务命名为Audio-Visual Correspondence Task，后文简称为AVC。AVC任务事实上是一个简单的二进制分类：针对每一个视频帧和一段音频剪辑，网络需要判断其是否彼此对应。对应的（正）对是在同一时间从同一视频，但从不同视频中提取了不匹配的（负）对。为了解决这个任务，我们期望模型能够学会在视觉和音频领域中检测各种语义概念。</p><p>应当指出，这项任务非常困难。模型需要从0开始建立网络以学习视觉和音频功能，并且却从未见过一个标签。此外，原始的视频数据可能非常嘈杂，音频源不一定在视频中可见（例如，摄像机操作员讲话，对视频进行旁白的人，声源不可见或被遮挡等），以及音频和视觉内容可能是完全不相关的（例如，带有附加音乐的视频，声音很小，周围环境诸如风之类的声音主导了音轨等）。</p><p>尽管如此，本文的结果仍然表明AVC网络能够相当成功地解决AVC任务，并且在此过程中习得非常好的视觉和听觉表示。</p><h2 id="对比学习"><a href="#对比学习" class="headerlink" title="对比学习"></a>对比学习</h2><p>说到当下最火热的非监督学习方法，非对比学习(Contrastive Learning)莫属。Bengio和Lecun在AAAI还是哪个会上力挺自监督学习尤其是对比学习方法，这篇简单介绍以下对比学习是为何物。</p><p>就我而言，当下的对比学习框架与之前的两篇文章(Exemplar learning)有着类似的思路，有兴趣大家可以自行阅读，在那两篇文章中，每一张图片被视为一个独立的class，我们对每一张图片做各种变换进行数据augmentation，这样就得到了一个多分类问题（有多少张图片就有多少个类别）。</p><p>对比学习可以视为将上面两篇文章中的Cross-entropy loss替换为contrastive loss之后的版本。我们用一个简单的例子描述对比学习：</p><p>假如有两张图片A(足球)，B(猫咪)，由于是非监督学习，我们并不知道真实标签，但我们知道A 和B分属不同的语义类别，即使我们对A和B分别做一些变换，比如旋转(R)，裁减(C)，高斯模糊(G)等等，在理想的情况下，人们仍然能够合理的避免变换的影响，将变换后的图片正确归类到A或是B。这一点很好理解，正常人都不会因为一张猫咪照被翻转之后就认为他变成了狗甚至是足球。</p><p>基于以上的动机，假设我们有模型f，我们希望f同样具有以上能力，假如我们用特征之间的距离来表示图片之间的关联度，那么分别图片A和图片B，我们希望旋转后的图片A与裁减后的图片后距离较近，而与高斯模糊后的图片B较远。</p><p><img src="/img/self-supervised/s2.jpg" alt="self-supervised"></p><p>$$\operatorname{dist}(f(R(A)), f(C(A)))&lt;\operatorname{dist}(f(R(A)), f(G(B)))$$</p><p>看到这里，有经验的同学可能会想到Triplet Loss，事实上我认为这两者确实蛮相似的，唯一的区别可能是这里的负样本不是一对，而是很多对，也即，在满足上式的同时，对于图片A和数据库中的其他图片，我们都希望其满足此距离关系：</p><p>$$\operatorname{dist}(f(R(A)), f(C(X)))&lt;\operatorname{dist}(f(R(A)), f(G(X))), \quad X \in R^{H \times W}$$</p><p>大家思考一下，实际上最终的目标是，希望每一张图片及其变换后的图片所产生的特征形成一个cluster，在我们假设类内方差小于类间方差的情况下，这一点是可以保证的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习中的常见函数总结（备忘）</title>
    <link href="/2020/06/02/2020-06-02-matchine-learning/"/>
    <url>/2020/06/02/2020-06-02-matchine-learning/</url>
    
    <content type="html"><![CDATA[<p>主要近来又发现本人的记忆力水平需要笔记辅助，因此写来备忘。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#Softmax%E5%87%BD%E6%95%B0">Softmax函数</a></li><li><a href="#Triplet_loss">Triplet loss</a></li></ul><h2 id="Softmax函数"><a href="#Softmax函数" class="headerlink" title="Softmax函数"></a>Softmax函数</h2><p>Softmax函数，也叫归一化指数函数，主要是用来辅助多分类任务。</p><p>应用场景： 对于一个k分类的问题，通过对一个物体的特征进行处理，得到一个k维向量v，最好的结果当然是正确分类的维度取值1，其他维度取值0. 但是一般情况下我们得到的结果是每个维度取值范围为从负无穷到正无穷。</p><p>Softmax的作用：将每个维度的取值限定到0到1之间，并且所有维度的值之和为1.</p><p>Softmax的做法：</p><ol><li><p>首先将每个维度的值转换为非负数，做法：<code>v[i] = exp(v[i])</code></p></li><li><p>将非负数的值限定到0和1之间，并似的所有值和为1.做法：<code>v[i] = v[i]/(v[1]+v[2]+...+v[k])</code>;</p></li></ol><p>总结：<code>v[i] = exp(v[i]) / &#123;exp(v[1]) + exp(v[2]) + ... + exp(v[k])&#125;</code></p><h2 id="Triplet-loss"><a href="#Triplet-loss" class="headerlink" title="Triplet_loss"></a>Triplet_loss</h2><blockquote><p>Triplet loss最初是在FaceNet的论文中提出，可以较好地学到人脸的embedding，相似的图像在embedding空间里是相近的，可以判断是否是同一个人脸。</p></blockquote><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul><li><p>使具有相同标签的样本在embedding空间尽量接近。</p></li><li><p>使具有不同标签的样本在embedding空间尽量远离。</p></li></ul><p>如果只遵循以上两点，最后embedding空间中相同类别的样本间距离很小，不同类别的样本之间距离也会偏小。因此，需要加入margin。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>输入是一个三元组<code>&lt;a, p, n&gt;</code>，其中</p><ul><li>a：anchor 原点</li><li>p：positive 与a同一类别的样本</li><li>n：negative 与a不同类别的样本</li></ul><p>最终的loss为</p><p>$$ L &#x3D; max(d(a,p) - d(a,n) + margin, 0) $$</p><p>最小化L，则<code>d(a,p)-&gt;0，d(a,n)-&gt;margin</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSE/AVX加速时的内存对齐问题</title>
    <link href="/2020/01/07/2020-01-07-memory-alignment/"/>
    <url>/2020/01/07/2020-01-07-memory-alignment/</url>
    
    <content type="html"><![CDATA[<p>上个月比较忙，一篇博客都没写，这是2020第一篇～</p><blockquote><p>这篇博客的内容主要参考了官网与<a href="https://zhuanlan.zhihu.com/p/93824687">一篇知乎上的文章</a></p></blockquote><h1 id="内存对齐问题"><a href="#内存对齐问题" class="headerlink" title="内存对齐问题"></a>内存对齐问题</h1><p>这个是在学习Eigen的过程中顺便学习的。Eigen中有较多的矩阵与向量运算，因此可以使用SSE、AVX等指令集进行加速，当编译时打开<code>-march=native</code>这个选项时，会尝试对Eigen中的运算进行加速。而加速时内存对齐，因此如果不满足就会报错。</p><h2 id="向量化运算"><a href="#向量化运算" class="headerlink" title="向量化运算"></a>向量化运算</h2><p>向量化运算就是用SSE、AVX等SIMD（Single Instruction Multiple Data）指令集，实现一条指令对多个操作数的运算，从而提高代码的吞吐量，实现加速效果。SSE是一个系列，包括从最初的SSE到最新的SSE4.2，支持同时操作16 bytes的数据，即4个float或者2个double。AVX也是一个系列，它是SSE的升级版，支持同时操作32 bytes的数据，即8个float或者4个double。</p><p>但向量化运算是有前提的，那就是内存对齐。SSE的操作数，必须16 bytes对齐，而AVX的操作数，必须32 bytes对齐。也就是说，如果我们有4个float数，必须把它们放在连续的且首地址为16的倍数的内存空间中，才能调用SSE的指令进行运算。</p><blockquote><p>关于SSE与AVX还有SIMD的介绍附在了文后。至于内存对齐的原因，尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度.显然此处向量化运算的存取粒度会比较大一点。</p></blockquote><h3 id="简单的AVX加速示例"><a href="#简单的AVX加速示例" class="headerlink" title="简单的AVX加速示例"></a>简单的AVX加速示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>  <span class="hljs-type">double</span> input1[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>  <span class="hljs-type">double</span> input2[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>  <span class="hljs-type">double</span> result[<span class="hljs-number">4</span>];<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;address of input1: &quot;</span> &lt;&lt; input1 &lt;&lt; std::endl;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;address of input2: &quot;</span> &lt;&lt; input2 &lt;&lt; std::endl;<br><br>  __m256d a = _mm256_load_pd(input1);<br>  __m256d b = _mm256_load_pd(input2);<br>  __m256d c = _mm256_add_pd(a, b);<br><br>  _mm256_store_pd(result, c);<br><br>  std::cout &lt;&lt; result[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; result[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; result[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; result[<span class="hljs-number">3</span>] &lt;&lt; std::endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这段代码使用AVX中的向量化加法指令，同时计算4对double的和。这4对数保存在input1和input2中。 <code>_mm256_load_pd</code>指令用来加载操作数，<code>_mm256_add_pd</code>指令进行向量化运算，最后， <code>_mm256_store_pd</code>指令读取运算结果到<code>result</code>中。可惜的是，程序运行到第一个<code>_mm256_load_pd</code>处就崩溃了。崩溃的原因正是因为输入变量没有内存对齐。我特意打印出了两个输入变量的地址，结果如下 </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">address of input1: 0x7ffeef431ef0<br>address of input2: 0x7ffeef431f10 <br></code></pre></td></tr></table></figure><p>上一节提到了AVX要求32字节对齐，我们可以把这两个输入变量的地址除以32，看是否能够整除。结果发现<code>0x7ffeef431ef0</code>和<code>0x7ffeef431f10</code>都不能整除。当然，其实直接看倒数第二位是否是偶数即可，是偶数就可以被32整除，是奇数则不能被32整除。</p><p>如何让输入变量内存对齐呢？我们知道，对于局部变量来说，它们的内存地址是在编译期确定的，也就是由编译器决定。所以我们只需要告诉编译器，给<code>input1</code>和<code>input2</code>申请空间时请让首地址32字节对齐，这需要通过预编译指令来实现。不同编译器的预编译指令是不一样的，比如gcc的语法为<code>__attribute__((aligned(32)))</code>，MSVC的语法为 <code>__declspec(align(32))</code> 。以gcc语法为例，做少量修改，就可以得到正确的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>  __attribute__ ((<span class="hljs-built_in">aligned</span> (<span class="hljs-number">32</span>))) <span class="hljs-type">double</span> input1[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>  __attribute__ ((<span class="hljs-built_in">aligned</span> (<span class="hljs-number">32</span>))) <span class="hljs-type">double</span> input2[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>  __attribute__ ((<span class="hljs-built_in">aligned</span> (<span class="hljs-number">32</span>))) <span class="hljs-type">double</span> result[<span class="hljs-number">4</span>];<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;address of input1: &quot;</span> &lt;&lt; input1 &lt;&lt; std::endl;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;address of input2: &quot;</span> &lt;&lt; input2 &lt;&lt; std::endl;<br><br>  __m256d a = _mm256_load_pd(input1);<br>  __m256d b = _mm256_load_pd(input2);<br>  __m256d c = _mm256_add_pd(a, b);<br><br>  _mm256_store_pd(result, c);<br><br>  std::cout &lt;&lt; result[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; result[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; result[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; result[<span class="hljs-number">3</span>] &lt;&lt; std::endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">address of input1: 0x7ffc5ca2e640<br>address of input2: 0x7ffc5ca2e660<br>2 3 4 5<br></code></pre></td></tr></table></figure><p>可以看到，这次的两个地址都是32的倍数，而且最终的运算结果也完全正确。</p><h3 id="动态内存申请时的对齐问题"><a href="#动态内存申请时的对齐问题" class="headerlink" title="动态内存申请时的对齐问题"></a>动态内存申请时的对齐问题</h3><blockquote><p>上面的操作是在栈上进行地址对齐的内存申请，此时内存地址是编译器在编译时确定的，因此预编译指令可以生效。但是我们在真正的编程时，经常会使用到动态内存申请，动态创建的对象存储在堆上，其地址是运行时确定的。</p></blockquote><p>其实要想实现动态申请内存的32位地址对齐，方法有很多</p><ol><li><p>为该类重写<code>new</code>函数，每次分配内存时多申请32个字节，然后寻找这段内存中第一个32倍数的地址返回。</p></li><li><p>c++从C++11开始新增了函数<code>void *aligned_alloc( size_t alignment, size_t size );</code>可以动态申请到alignment字节对齐的内存;</p></li><li><p>从C++17开始新增了函数<code>void* operator new ( std::size_t count, std::align_val_t al);</code>函数可以动态申请对齐的内存;</p></li></ol><blockquote><p>使用<code>new</code>动态创建一个类对象，首先使用<code>new</code>在堆上申请该类大小的内存，然后调用该类的构造函数在申请的内存上构造该对象。所以如果想使用<code>new</code>动态申请一个内存对齐的对象，关键在于第一步，方法是1。（当然了在重写该类的new函数可以直接使用2和3来实现，也可以自行判断保证返回的指针是内存对齐的）</p></blockquote><h2 id="Eigen中的内存对齐方式"><a href="#Eigen中的内存对齐方式" class="headerlink" title="Eigen中的内存对齐方式"></a>Eigen中的内存对齐方式</h2><p>在Eigen官方文档中说，如果你想要创建一个类，然后这个类中包含Eigen类型，那么需要考虑内存对齐的问题。比如如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br>  ...<br>  Eigen::Vector2d v;<br>  ...<br>&#125;;<br>...<br>Foo *foo = <span class="hljs-keyword">new</span> Foo;<br></code></pre></td></tr></table></figure><blockquote><p>上面这个类中含有一个<a href="http://eigen.tuxfamily.org/dox/group__TopicFixedSizeVectorizable.html">固定尺寸的Eigen对象</a>，所以需要考虑内存对齐。解决方法如下：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br>  ...<br>  Eigen::Vector2d v;<br>  ...<br><span class="hljs-keyword">public</span>:<br>  EIGEN_MAKE_ALIGNED_OPERATOR_NEW<br>&#125;;<br>...<br>Foo *foo = <span class="hljs-keyword">new</span> Foo;<br></code></pre></td></tr></table></figure><blockquote><p>只需要在你的<code>class</code>的public部分添加一个宏定义声明<code>EIGEN_MAKE_ALIGNED_OPERATOR_NEW</code>即可。这个宏定义其实就是一个<code>void* operator new()</code>的重载函数，这个重载的函数保证返回一个内存对齐的指针，Eigen将其封装成了一个宏，因此用户只要在此处添加这个宏，即代表着重写了这个类的new函数。</p></blockquote><h2 id="SIMD-单指令多数据"><a href="#SIMD-单指令多数据" class="headerlink" title="SIMD(单指令多数据)"></a>SIMD(单指令多数据)</h2><p>SIMD单指令流多数据流(SingleInstruction Multiple Data,SIMD)是一种采用一个控制器来控制多个处理器，同时对一组数据（又称“数据向量”）中的每一个分别执行相同的操作从而实现空间上的并行性的技术。在微处理器中，单指令流多数据流技术则是一个控制器控制多个平行的处理微元，例如Intel的MMX或SSE以及AMD的3D Now!技术还有RAM的NEON等。</p><blockquote><p>所以SIMD其实是一种技术，目前的处理器上基本都会支持SIMD，只是需要相关的指令集来使用它。SSE与AVX都是intel提出的适用于自己处理器的SIMD指令集。AVX是SSE的延伸架构。其他公司比如AMD或者ARM也都有推出自己的SIMD指令集。想了解的更详细可以自己再查阅相关资料。</p></blockquote><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1] Eigen官网</li><li>[2] <a href="https://zhuanlan.zhihu.com/p/93824687">https://zhuanlan.zhihu.com/p/93824687</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>空间坐标系系统介绍</title>
    <link href="/2019/11/10/2019-11-10-spatial-coordinate-system/"/>
    <url>/2019/11/10/2019-11-10-spatial-coordinate-system/</url>
    
    <content type="html"><![CDATA[<p>最近好忙，只能想起来就写一点，把空间坐标系总结一下。</p><h1 id="空间坐标系"><a href="#空间坐标系" class="headerlink" title="空间坐标系"></a>空间坐标系</h1><blockquote><p>我们生活在宇宙中，我们生活在地球上。地球相对于宇宙肯定不是固定不动的，我们知道地球绕太阳公转，同时本身也有自转（具体地球的运动，请见附录）。</p></blockquote><p>我们知道，定义坐标系都是有一个参照物的，因此，根据参照物的属性，我们首先可以将空间坐标系划分为两种：<strong>惯性坐标系</strong>与<strong>地球坐标系</strong>。</p><ol><li>惯性坐标系</li><li>地球坐标系<ul><li>地心地固坐标系<ul><li>地心地固直角坐标系</li><li>大地坐标系</li></ul></li><li>站心坐标系<ul><li>ENU（东北天）坐标系</li></ul></li></ul></li></ol><h2 id="1-惯性坐标系"><a href="#1-惯性坐标系" class="headerlink" title="1 惯性坐标系"></a>1 惯性坐标系</h2><blockquote><p>在空间中静止或者做匀速直线运动的坐标系称为<strong>惯性坐标系</strong>，也叫做<strong>空固坐标系。</strong></p></blockquote><p>由上面定义可知，要建立一个严格意义上的惯性坐标系，相当困难。毕竟，我们生活在地球上，而地球运动复杂。</p><h2 id="2-地球坐标系"><a href="#2-地球坐标系" class="headerlink" title="2 地球坐标系"></a>2 地球坐标系</h2><blockquote><p><strong>地球坐标系</strong>固定在地球上随着地球一起在空间里做公转与自传运动，因此也称为<strong>地固坐标系。</strong></p></blockquote><p>地固坐标系根据<strong>坐标系原点的不同</strong>，又可以分为<strong>地心地固坐标系</strong>与<strong>站心坐标系</strong></p><h3 id="2-1-地心地固坐标系"><a href="#2-1-地心地固坐标系" class="headerlink" title="2.1 地心地固坐标系"></a>2.1 地心地固坐标系</h3><h4 id="2-1-1-地心地固直角坐标系"><a href="#2-1-1-地心地固直角坐标系" class="headerlink" title="2.1.1 地心地固直角坐标系"></a>2.1.1 地心地固直角坐标系</h4><p>地心地固直角坐标系以地心$$O$$为坐标原点，Z轴与地球自传轴重合并指向北极（协议北极），X轴指向参考子午面（通常是英国伦敦处的格林尼治子午面）与地球赤道的一个交点，而X,Y,Z三轴一起构成右手直角坐标系。</p><h4 id="2-1-2大地坐标系"><a href="#2-1-2大地坐标系" class="headerlink" title="2.1.2大地坐标系"></a>2.1.2大地坐标系</h4><p>大地坐标系也叫经纬高坐标系。三个坐标分别表示经度、纬度、高度信息。</p><p>为了给出高度值，大地坐标系首先会定义一个与地球几何最吻合的椭球体来代替表面凹凸不平的地球，这个椭球体成为基准椭球体。此时大地高度h是从P点到基准椭球面的法线距离，基准椭球面以外为正，以内为负。</p><blockquote><p>由于地球会有极移现象，因此为了产生固定的地心地固坐标系，一般会定义协议地级，据此制定协议地球坐标系。最常使用的是WGS-84坐标系。</p></blockquote><h3 id="2-2-站心坐标系"><a href="#2-2-站心坐标系" class="headerlink" title="2.2 站心坐标系"></a>2.2 站心坐标系</h3><p>站心坐标系通常以用户所在的位置P为坐标原点，东向为x轴正方向，北向为y轴正方向，天向为z轴正方向。因此，站心坐标系也叫作东北天（ENU）坐标系。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="地球的运动"><a href="#地球的运动" class="headerlink" title="地球的运动"></a>地球的运动</h2><p>地球的运动比较复杂，不过可以大体说一下</p><ol><li>绕太阳公转：地球及其质心围绕太阳做非匀速直线运动</li><li>地球自传：但地球自传轴的方向不是固定不变的，地球自转轴的方向在空间的运动大致可以描述成下面两种运动的叠加<ul><li>从上万年尺度长期来看，地球自转轴绕北黄极做缓慢的旋转（北极绕北黄极顺时针大圆周运动，半径等于黄赤交角乘以地球半径，周期大约25800年）</li><li>从几年尺度短期来看，地球自转轴还存在一种称为<strong>章动</strong>的局部小幅度旋转（北极做顺时针小椭圆运动，周期18.6年）</li></ul></li></ol><blockquote><p>地球自转轴的运动主要是由于：1.其自身密度不均匀；2.赤道隆起的地球受到日月引力共同作用；</p></blockquote><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1] GPS原理与接收机设计 谢刚著</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>多传感器融合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BA优化中Jacobian矩阵的计算</title>
    <link href="/2019/11/01/2019-11-01-BA-jacobian/"/>
    <url>/2019/11/01/2019-11-01-BA-jacobian/</url>
    
    <content type="html"><![CDATA[<p>之前写过一篇讲解<a href="https://xhy3054.github.io/bundle-adjustment-solve/">BA</a>的博客，不过那篇主要侧重于讲解BA在slam中的应用与求解方式，但是忽略了对于细节的边的构造与jacobian矩阵的计算的讲解，前几天有人提醒我这一点，所以今天抽出来时间补充一下。</p><h2 id="BA优化中的边（重投影误差）"><a href="#BA优化中的边（重投影误差）" class="headerlink" title="BA优化中的边（重投影误差）"></a>BA优化中的边（重投影误差）</h2><p>Bundle Adjustment，中文翻译有捆集调整、光束法平差。它的主要思想是<strong>最小化重投影误差</strong>。</p><p>BA优化的误差边也就是<strong>重投影误差边</strong>。</p><ul><li><p>投影过程是将一个地图点（三维坐标为$(X,Y,Z)$）投影到当前帧（假设位姿为$$T_{wc}$$）的像素平面上（得到投影坐标为$(u,v)$）</p></li><li><p>误差边的定义是测量坐标（该帧上提取到的此地图点的位置$(u_m,v_m)$）减去投影得到坐标$(u,v)$</p></li></ul><p>$$ e = [u_m,v_m]^T - [u,v]^T $$</p><h2 id="BA优化中的节点（投影点与关键帧）"><a href="#BA优化中的节点（投影点与关键帧）" class="headerlink" title="BA优化中的节点（投影点与关键帧）"></a>BA优化中的节点（投影点与关键帧）</h2><p>通常我们最经常放入BA中进行优化的节点有两个</p><ol><li><p>地图点的三维坐标为$(X,Y,Z)$</p></li><li><p>被投影帧的位姿$$T_{wc}$$</p></li></ol><blockquote><p>当然了，BA优化时只要观测到的约束足够多，方程就足够多，因此可以优化更多节点。比如我们还可以放入的节点有相机内参等。</p></blockquote><h2 id="jacobian的推导"><a href="#jacobian的推导" class="headerlink" title="jacobian的推导"></a>jacobian的推导</h2><p>前面已经列出来了<strong>重投影误差</strong>的定义为：</p><p>$$ e = [u_m,v_m]^T - [u,v]^T $$</p><p>然后被投影帧的位姿为$$T_{wc}$$，地图点在世界坐标系中的位置为$P$，则将其<strong>变换到该帧的相机坐标系下的坐标</strong>为</p><p>$$ P’ = T_{wc} * P  = [X’, Y’, Z’]^T$$</p><p>然后将这个点<strong>投影到像素平面</strong>上的操作为</p><p>$$ \left[\begin{array}{c}{Z’ u} \\ {Z’ v} \\ {Z’}\end{array}\right]=\left[\begin{array}{ccc}{f_{x}} &amp; {0} &amp; {c_{x}} \\ {0} &amp; {f_{y}} &amp; {c_{y}} \\ {0} &amp; {0} &amp; {1}\end{array}\right]\left[\begin{array}{c}{X^{\prime}} \\ {Y^{\prime}} \\ {Z^{\prime}}\end{array}\right] $$</p><p>即</p><p>$$<br>u=f_{x} \frac{X^{\prime}}{Z^{\prime}}+c_{x}, \quad v=f_{y} \frac{Y^{\prime}}{Z^{\prime}}+c_{y}<br>$$</p><h3 id="重投影误差对地图点三维坐标的jacobian"><a href="#重投影误差对地图点三维坐标的jacobian" class="headerlink" title="重投影误差对地图点三维坐标的jacobian"></a>重投影误差对地图点三维坐标的jacobian</h3><p>由上，我们首先计算重投影误差对地图点相机坐标系下坐标$$P^{\prime}$$的偏导，</p><p>$$<br>\frac{\partial e}{\partial P^{\prime}}=-\left[\begin{array}{ccc}{\frac{\partial u}{\partial X^{\prime}}} &amp; {\frac{\partial u}{\partial Y^{\prime}}} &amp; {\frac{\partial u}{\partial Z^{\prime}}} \\ {\frac{\partial v}{\partial X^{\prime}}} &amp; {\frac{\partial v}{\partial Y^{\prime}}} &amp; {\frac{\partial v}{\partial Z^{\prime}}}\end{array}\right]=-\left[\begin{array}{ccc}{\frac{f_{x}}{Z^{\prime}}} &amp; {0} &amp; {-\frac{f_{x^{\prime}} X^{\prime}}{Z^{\prime 2}}} \\ {0} &amp; {\frac{f_{y}}{Z^{\prime}}} &amp; {-\frac{f_{y} Y^{\prime}}{Z^{\prime 2}}}\end{array}\right]<br>$$</p><p>接着根据如下链式法则与坐标变换关系</p><p>$$<br>\frac{\partial e}{\partial \boldsymbol{P}}=\frac{\partial \boldsymbol{e}}{\partial \boldsymbol{P}^{\prime}} \frac{\partial \boldsymbol{P}^{\prime}}{\partial \boldsymbol{P}}<br>$$</p><p>$$<br>\boldsymbol{P}^{\prime} = \boldsymbol{R} \boldsymbol{P} + t<br>$$</p><p>可以得到最终的<strong>重投影误差对地图点三维坐标的jacobian</strong></p><p>$$<br>\frac{\partial e}{\partial \boldsymbol{P}} = -\left[\begin{array}{ccc}{\frac{f_{x}}{Z^{\prime}}} &amp; {0} &amp; {-\frac{f_{x^{\prime}} X^{\prime}}{Z^{\prime 2}}} \\ {0} &amp; {\frac{f_{y}}{Z^{\prime}}} &amp; {-\frac{f_{y} Y^{\prime}}{Z^{\prime 2}}}\end{array}\right] \boldsymbol{R}<br>$$</p><h3 id="重投影误差对被投影帧位姿的jacobian"><a href="#重投影误差对被投影帧位姿的jacobian" class="headerlink" title="重投影误差对被投影帧位姿的jacobian"></a>重投影误差对被投影帧位姿的jacobian</h3><blockquote><p>此处需要说明的是，对于位姿变换（对应的李群是$SE(3)$）的求导我们一般将其变换到$SE(3)$对应的李代数$$\xi$$上使用扰动模型来求导。</p></blockquote><p>根据前面的推导我们可以发现，重投影误差项$e$中与位姿$T_{wc}$相关的只有$\boldsymbol{P}^{\prime}$，因此可以将求解过程分解为如下两步</p><p>$$<br>\frac{\partial e}{\partial \delta \xi}=\frac{\partial e}{\partial P^{\prime}} \frac{\partial P^{\prime}}{\partial \delta \xi}<br>$$</p><p>其中第一部分$$\frac{\partial e}{\partial P^{\prime}}$$在前面已经求解出来了，第二部分可以通过使用扰动模型左乘扰动量来求得（具体步骤见附录1）</p><p>$$<br>\frac{\partial(\boldsymbol{T} \boldsymbol{P})}{\partial \delta \boldsymbol{\xi}}=(\boldsymbol{T} \boldsymbol{P})^{\odot}=\left[\begin{array}{cc}{\boldsymbol{I}} &amp; {-\boldsymbol{P}^{\prime \wedge}} \\ {\boldsymbol{0}^{\mathrm{T}}} &amp; {\boldsymbol{0}^{\mathrm{T}}}\end{array}\right]<br>$$</p><p>由于上面是使用的$$\boldsymbol{P}$$的齐次坐标形式，所以从上式结果中取出前三维就是（这是一个$3*6$大小的矩阵）</p><p>$$<br>\frac{\partial \boldsymbol{P}^{\prime}}{\partial \delta \boldsymbol{\xi}}=\left[\boldsymbol{I},-\boldsymbol{P}^{\prime \wedge}\right]<br>$$</p><p>然后将两项相乘就可以得到我们想要的结果–<strong>重投影误差对被投影帧位姿的jacobian</strong></p><p>$$<br>\frac{\partial e}{\partial \delta \xi}=-\left[\begin{array}{lllll}{\frac{f_{x}}{Z^{\prime}}} &amp; {0} &amp; {-\frac{f_{x} X^{\prime}}{Z^{\prime 2}}} &amp; {-\frac{f_{x} X^{\prime} Y^{\prime}}{Z^{\prime 2}}} &amp; {f_{x}+\frac{f_{x} X^{2}}{Z^{\prime 2}}} &amp; {-\frac{f_{x} Y^{\prime}}{Z^{\prime}}} \\ {0} &amp; {\frac{f_{y}}{Z^{\prime}}} &amp; {-\frac{f_{y Y^{\prime}}}{Z^{\prime 2}}} &amp; {-f_{y}-\frac{f_{y} Y^{\prime 2}}{Z^{\prime 2}}} &amp; {\frac{f_{y} X^{\prime Y^{\prime}}}{Z^{\prime 2}}} &amp; {\frac{f_{y} X^{\prime}}{Z^{\prime}}}\end{array}\right]<br>$$</p><h3 id="附录1"><a href="#附录1" class="headerlink" title="附录1"></a>附录1</h3><p>假设如下求导中的左乘的扰动项的李代数为$$\delta \boldsymbol{\xi}=[\delta \boldsymbol{\rho}, \delta \phi]^{\mathrm{T}}$$，那么：</p><p><img src="/img/math/raodong.PNG" alt="math"></p><blockquote><p>上面最后一行矩阵除法，与矩阵乘法规则类似，只是乘号变成了除号。其使用一个$4×1$矩阵除以一个$1×6$矩阵得到一个$4×6$矩阵</p></blockquote><h3 id="附录2"><a href="#附录2" class="headerlink" title="附录2"></a>附录2</h3><p><strong>雅克比矩阵即是偏导数矩阵</strong>，由于一般待求导的目标函数的因变量是列向量，自变量也是列向量，在求雅克比矩阵时遵循如下规则：</p><p>$$<br>\frac{\mathrm{d}\left[\begin{array}{l}{a} \\ {b}\end{array}\right]}{\mathrm{d}\left[\begin{array}{l}{x} \\ {y}\end{array}\right]}=\left[\begin{array}{cc}{\frac{\mathrm{d} a}{\mathrm{d} x}} &amp; {\frac{\mathrm{d} a}{\mathrm{d} y}} \\ {\frac{\mathrm{d} b}{\mathrm{d} x}} &amp; {\frac{\mathrm{d} b}{\mathrm{d} y}}\end{array}\right]<br>$$</p><blockquote><p>其实只需要明确一点，上述公式便很容易记起来了。对于输入为n维向量，输出为m维向量的变换（即从$R^n$到$R^m$的变换），它的雅克比矩阵为$m*n$维。即行数由输出向量的维度决定，列数由输入向量的维度决定</p></blockquote><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1] 视觉slam十四讲 从理论到实践 高翔等著；</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vins中的外参标定</title>
    <link href="/2019/10/30/2019-10-30-camera-extrinsic/"/>
    <url>/2019/10/30/2019-10-30-camera-extrinsic/</url>
    
    <content type="html"><![CDATA[<p>之前写过一篇博客介绍vins中进行初始化的操作，其实在这之前，vins会首先进行外参的标定。今天终于找到时间写一下。</p><h1 id="外参标定"><a href="#外参标定" class="headerlink" title="外参标定"></a>外参标定</h1><h2 id="外参"><a href="#外参" class="headerlink" title="外参"></a>外参</h2><p>此处的外参指的是相机坐标系到imu坐标系（body）的变换矩阵。下文中会使用$$T_{bc}$$来表示。</p><h2 id="vins中的设置"><a href="#vins中的设置" class="headerlink" title="vins中的设置"></a>vins中的设置</h2><p>在vins中可以通过在配置文件中设置<code>estimate_extrinsic</code>值来选择对外参进行如何处理</p><ol><li><p>将这个值设为0时代表提供的外参已经是准确的了，vins之后不会再对其进行优化；</p></li><li><p>将这个值设为1时代表提供的外参只是一个估计值，vins之后还会将其作为节点初始值放入非线性优化中进行优化；</p></li><li><p>将这个值设为2时代表并不提供外参，此时vins会在初始化前在线标定外参。</p></li></ol><blockquote><p>需要说明的是，在vins进行外参的在线标定时，只进行了外参旋转部分的估计，而平移部分是直接初始化为0了。这个是因为一般情况下我们使用的都是相机与imu集成起来的设备，两者之间的距离十分小（几厘米），所以在此处可以直接初始化为0，后续可以通过优化来矫正（或者直接忽略也不会有太大影响）。</p></blockquote><h2 id="标定原理"><a href="#标定原理" class="headerlink" title="标定原理"></a>标定原理</h2><p>首先，从第$k+1$帧相机坐标系到第$k$帧body坐标系的旋转变换$$R_{b_k c_{k+1}}$$可以使用两种如下方式求得</p><p>$$ R_{b_k c_{k+1}} &#x3D; R_{b_k b_{k+1}} * R_{bc} &#x3D; R_{bc} * R_{c_k c_{k+1}} $$</p><p>上面等式用四元数重写为如下形式</p><p>$$ q_{b_k b_{k+1}} * q_{bc} &#x3D; q_{bc} * q_{c_k c_{k+1}} $$</p><p>上面的第一个等式我们会发现$$R_{bc}$$在等式两边都出现了，只是一边是左乘了一个矩阵，一边是右乘了一个矩阵，我们可以将等式右边的右乘矩阵$$R_{c_k c_{k+1}}$$变换成左乘形式$$R_{c_k c_{k+1}}^{right}$$然后移动到右边，然后上式子就变成了</p><p>$$[ R_{b_k b_{k+1}} - R_{c_k c_{k+1}}^{right} ] * R_{bc} &#x3D; 0 $$</p><p>将多帧之间的等式关系联立我们可以构建一个超定方程$$Ax&#x3D;0$$。对$A$进行$svd$分解，其中最小奇异值对应的右奇异向量便是结果$$R_{bc}$$。</p><h2 id="vins中的实现"><a href="#vins中的实现" class="headerlink" title="vins中的实现"></a>vins中的实现</h2><p>在vins的实现中流程如下：</p><ol><li><p>取得连续两帧之间匹配到（跟踪到）的归一化特征点集合；</p></li><li><p>根据帧间匹配集合由随意抽样一致方法通过对极几何约束得到前后两帧的相机坐标系的相对旋转变换$$R_{c_k c_{k+1}}$$</p></li><li><p>根据imu预积分得到前后两帧BODY坐标系的相对旋转变换$$R_{b_k b_{k+1}}$$</p></li><li><p>连续积累滑动窗口数个上面的方程，解方程得到。</p></li></ol><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>在vins实现中，构建的左乘矩阵$L$是$$R_{c_k c_{k+1}}$$的左乘矩阵，构建的右乘矩阵$R$是$$R_{b_k b_{k+1}}$$，相当于其解方程的公式如下：</p><p>$$[ R_{c_k c_{k+1}} - R_{b_k b_{k+1}}^{right} ] * R_{cb} &#x3D; 0 $$</p><p>所以解方程求得的是$$R_{cb}$$，因此代码的最后会对其进行求逆来获得$$R_{bc}$$</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] <a href="https://github.com/HKUST-Aerial-Robotics/VINS-Fusion">https://github.com/HKUST-Aerial-Robotics/VINS-Fusion</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>多传感器融合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人学中的坐标变换问题探讨</title>
    <link href="/2019/10/15/2019-10-15-robot-coordinate-transform/"/>
    <url>/2019/10/15/2019-10-15-robot-coordinate-transform/</url>
    
    <content type="html"><![CDATA[<p>在机器人学中，<strong>坐标变换</strong>是一个及其复杂但重要的问题。为了更清楚的表达，我们在本文中做出如下约定。</p><ol><li><p>坐标、姿态的表达使用下标来表明坐标系。比如物体在A坐标系下的位置坐标为$$P_{A}$$</p></li><li><p>将坐标系B的坐标变换到A坐标系的坐标的变换矩阵，记为$$T_{AB}$$</p></li><li><p>本文中使用的向量$(x,y,z)$是横向量，纵向量形式为$(x,y,z)^T$</p></li></ol><blockquote><p>一般我们在描述不同物体之间的位姿变换关系时，会引入坐标系之间的变换概念。即描述如何将以该物体位姿坐标原点的坐标系变换到令一个坐标系的变换。本文接下来的部分，我们会以<strong>两个物体A与B之间变换关系</strong>来展开讨论。</p></blockquote><h2 id="位置变换"><a href="#位置变换" class="headerlink" title="位置变换"></a>位置变换</h2><p>最简单的当然是<strong>只考虑位置变换</strong>的情况。</p><p>假设以物体A的位置作为原点的A坐标系中，B的坐标为$(x,y,z)$。</p><p>则我们知道两点：</p><ol><li><p>A到B的平移向量为$t&#x3D;(x,y,z)$</p></li><li><p>将B坐标系的坐标变换到A坐标系的坐标的变换向量也是$t_{AB} &#x3D; (x,y,z)$。（因为B在B坐标系中坐标是$(0,0,0)$,B在A坐标系中坐标是$(x,y,z)$）</p></li></ol><blockquote><p>总结，<strong>只考虑位置变换，则物体B在A坐标系中的位置，就是坐标系B到A的变换向量。</strong></p></blockquote><h2 id="姿态变换"><a href="#姿态变换" class="headerlink" title="姿态变换"></a>姿态变换</h2><p>现在来考虑<strong>只有姿态变换</strong>的情况。</p><ul><li><p>由于只有姿态变换，因此A与B的位置是重合的，只是姿态不同，也就是A坐标系与B坐标系的原点重合，但是坐标轴不重合。</p></li><li><p>假设物体A的坐标系的三个坐标轴在A坐标系下分别是$$ax_{A}&#x3D;(1,0,0)^T,ay_{A}(0,1,0)^T,az_{A}&#x3D;(0,0,1)^T$$</p></li><li><p><strong>经过旋转</strong>$R$后，变换成的B坐标系的坐标轴在A坐标系下的坐标为$$bx_{A}, by_{A}, bz_{A}$$(假设是列向量形式)。</p></li><li><p>因为我们知道(R乘以$$(1,0,0)^T$$得到的向量是R的第一列。。。)</p><p>  $$ R * ax_{A} &#x3D; bx_{A} $$</p><p>  $$ R * ay_{A} &#x3D; by_{A} $$</p><p>  $$ R * az_{A} &#x3D; bz_{A} $$</p></li><li><p>所以可以得到R，此处R也就是B在A坐标系中的姿态矩阵</p><p>  $$ R &#x3D; [bx_{A} , by_{A}, bz_{A}] $$</p></li><li><p>由于B在B坐标系中的三个坐标轴是$$bx_{B}&#x3D;(1,0,0)^T,by_{B}(0,1,0)^T,bz_{B}&#x3D;(0,0,1)^T$$，并且有</p><p>  $$ R_{AB} * bx_{B} &#x3D; bx_{A} $$</p><p>  $$ R_{AB} * by_{B} &#x3D; by_{A} $$</p><p>  $$ R_{AB} * bz_{B} &#x3D; bz_{A} $$</p></li><li><p>所以，B坐标系到A坐标系的变换矩阵$$R_{AB}$$为（矩阵S乘以$$(1,0,0)^T$$得到的向量是矩阵S的第一列…）</p><p>  $$ R_{AB} &#x3D; [bx_{A} , by_{A}, bz_{A}] $$</p></li></ul><blockquote><p>总结，<strong>物体B在坐标系A中的姿态矩阵，也就是从B坐标系到A坐标系的姿态变换矩阵</strong>。</p></blockquote><h3 id="拓展：旋转矩阵是正交矩阵"><a href="#拓展：旋转矩阵是正交矩阵" class="headerlink" title="拓展：旋转矩阵是正交矩阵"></a>拓展：旋转矩阵是正交矩阵</h3><ul><li><p>由上面我们可以知道，假设旋转矩阵R可以用来将A坐标系的三个坐标轴旋转成B坐标系的三个坐标轴。即</p><p>  $$ R * ax_{A} &#x3D; bx_{A} $$</p><p>  $$ R * ay_{A} &#x3D; by_{A} $$</p><p>  $$ R * az_{A} &#x3D; bz_{A} $$</p></li><li><p>则此时我们可以得到R</p><p>  $$ R &#x3D; [bx_{A} , by_{A}, bz_{A}] $$</p></li><li><p>上面R矩阵的三个列向量是三个单位正交向量（因为是坐标轴）。由此，我们可以很轻松地得到</p><p>  $$ R R^T &#x3D; E $$</p></li><li><p>由上可证：旋转矩阵是正交矩阵。</p></li></ul><h2 id="位姿变换下的位置变换"><a href="#位姿变换下的位置变换" class="headerlink" title="位姿变换下的位置变换"></a>位姿变换下的位置变换</h2><ul><li><p>下面来综合考虑位姿变换的情况。</p></li><li><p>一般对于这种情况，假设在A坐标系中，B的姿态是R，位置是t；(变换过程可以分解成，首先从原点位移t，然后进行姿态变换成R)</p></li><li><p>对于B点，在A坐标系坐标是$$bp_{A} &#x3D; t$$，在B坐标系坐标是$$bp_{B} &#x3D; (0,0,0)^T$$，在A坐标系中B坐标系原点的姿态是$$br_{A} &#x3D; R$$，则应该是</p></li></ul><p>$$ bp_{A} &#x3D; R * bp_{B} + t &#x3D; t $$</p><ul><li>因此，对于一个物体c，假设其在A坐标系坐标是$$c_{A}$$，在B坐标系坐标是$$c_{B}$$</li></ul><p>$$ c_{A} &#x3D; R * c_{B} + t $$</p><blockquote><p>总结，<strong>物体B在坐标系A中的姿态矩阵，也就是从B坐标系到A坐标系的姿态变换矩阵</strong>$$R_{AB}$$，<strong>物体B在A坐标系中的位置，就是坐标系B到A的变换向量</strong>。并且在<strong>进行位置变换时，首先进行姿态变换，然后进行位置变换。</strong>(如果顺序反过来，上面的推导就不对了)</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>从B坐标系到A坐标系的旋转矩阵$$R_{AB}$$，其实就是B坐标系原点在A坐标系中的姿态。</p></li><li><p>从B坐标系到A坐标系的平移$$t_{AB}$$，其实就是B坐标系原点在A坐标系中的位置坐标。</p></li><li><p>首先对于B坐标系中的姿态$$r_{B}$$，变换到A坐标系中，可以直接使用旋转矩阵$$R_{AB}$$进行变换；</p></li></ul><p>$$ r_{A} &#x3D; R_{AB} * r_{B} $$</p><ul><li>而对于一个位置p，从B坐标系变换到A坐标系，整体的变换执行过程如下：</li></ul><p>$$ p_{A} &#x3D; R_{AB} * p_{B} + t_{AB} $$</p><ul><li>因此，对于位置的齐次坐标表示形式，从B坐标系到A坐标系的齐次变换矩阵$$T_{AB}$$，可以写成</li></ul><p>$$<br>T_{AB} &#x3D; \left[ \begin{array}{ccc} R_{AB} &amp; t_{AB} \ O_{1*3} &amp; 1\end{array} \right]<br>$$</p><blockquote><p>我们会发现，<strong>坐标系之间的姿态变换比较简单，直接做累乘操作就可以了。而对于坐标系之间的位置变换，会相对麻烦些，因为需要考虑两个坐标系之间姿态的差异。</strong></p></blockquote><ul><li><p>举一个例子：对于假设B坐标系原点在A坐标系中坐标是t，那A坐标系原点在B坐标系中的坐标是$-t$吗？</p></li><li><p>答案: 如下，只有在$$R_{AB}&#x3D;E$$时，才会有$$p_{B}&#x3D;-t$$。</p></li></ul><p>$$ (0,0,0)^T &#x3D; R_{AB} * p_{B} + t $$</p><blockquote><p>上面这个式子的含义是将A坐标系原点在B坐标系中的坐标$$p_{B}$$变换到A坐标系中是$$(0,0,0)^T$$</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ros中的包与节点与roslaunch的使用</title>
    <link href="/2019/10/10/2019-10-10-ros-package-node/"/>
    <url>/2019/10/10/2019-10-10-ros-package-node/</url>
    
    <content type="html"><![CDATA[<p>之前写过一篇<a href="">关于ros入门的博客</a>，但是这段时间我再看时发现当时比较关注全面性，所以在里面可以看到ros里几乎所有的基本知识。但是通篇看下来每一个讲的都没有很仔细，都是概念性的讲解。使得看完后，大家似乎对于ros的实现机制与功能模块有了一定的理解，但是如何使用ros呢？如何开发ros呢？好像还是有一些不是很懂。所以这一篇博客就会从ros使用的案例来说明，如何使用一个最小ros的功能包来跑起来节点。</p><h1 id="1-功能包"><a href="#1-功能包" class="headerlink" title="1. 功能包"></a>1. 功能包</h1><blockquote><p><strong>功能包（package）</strong>是构成ROS的基本单元。ROS应用程序是以功能包为单位开发的。功能包包括至少一个以上的节点或拥有用于运行其他功能包的节点的配置文件。它还包含功能包所需的所有文件，如用于运行各种进程的ROS依赖库、数据集和配置文件等。</p></blockquote><ul><li>在工作空间中创建包<code>new_package</code>，依赖于包<code>depend_p1</code>与<code>depend_p2</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_ws/src<br>catkin_create_pkg new_package depend_p1 depend_p2 <br></code></pre></td></tr></table></figure></li></ul><hr><ul><li><p>查看一个包的直接依赖<code>rospack depends1 new_packsge</code></p></li><li><p>查看一个包的所有依赖（包括直接与间接）<code>rospack depends new_package</code></p></li><li><p>编译包，直接编译整个工作空间就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_ws<br>catkin_make<br></code></pre></td></tr></table></figure></li></ul><hr><blockquote><p><strong>元功能包（metapackage）</strong>是一个具有共同目的的功能包的集合。例如，导航元功能包包含AMCL、DWA、EKF和map_server等10余个功能包。</p></blockquote><h1 id="2-节点"><a href="#2-节点" class="headerlink" title="2. 节点"></a>2. 节点</h1><blockquote><p><strong>ros的节点</strong>说到底就是一个操作系统上运行起来的程序。而这个可执行文件是依赖于某一个功能包的。</p></blockquote><p>如同前一节，假设我们创建了一个功能包<code>ros_tutorials_topic</code>，这个功能包主要的作用就是向初学者演示两个节点如何通过话题（topic）来通信。</p><ul><li><p>首先，这个功能包中会有两个节点（也就是会生成两个可执行文件），一个是话题发布节点，一个是话题订阅节点。</p></li><li><p>生成这两个节点的方法比较简单，就是在功能包文件夹下新建<code>src</code>文件夹，在里面编写两个节点的源代码，然后编译生成可执行文件即可。在CMakeLists中如下生成的两个可执行文件就是该功能包的两个节点。（添加依赖、链接什么的省略了）</p></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">add<span class="hljs-constructor">_executable(<span class="hljs-params">topic_publisher</span> <span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">topic_publisher</span>.<span class="hljs-params">cpp</span>)</span><br>add<span class="hljs-constructor">_executable(<span class="hljs-params">topic_subscriber</span> <span class="hljs-params">src</span><span class="hljs-operator">/</span><span class="hljs-params">topic_subscriber</span>.<span class="hljs-params">cpp</span>)</span><br></code></pre></td></tr></table></figure><ul><li>在使用<code>catkin_make</code>编译之后可执行文件（节点就生成了），下面就可以运行这两个节点了。</li></ul><h2 id="2-1-使用rosrun运行节点"><a href="#2-1-使用rosrun运行节点" class="headerlink" title="2.1 使用rosrun运行节点"></a>2.1 使用<code>rosrun</code>运行节点</h2><ul><li>下面三条命令分别新开一个终端执行<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ roscore<br>$ rosrun ros_tutorials_topic topic_publisher<br>$ rosrun ros_tutorials_topic topic_subscriber<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>使用<code>rosrun</code>来启动节点，只需要知道节点所属的功能包的名字，然后知道节点对应的可执行文件的名称，即可找到该节点对应的可执行文件并启动节点了。（如果是python脚本的节点，可执行文件的名称就是python脚本的名字去除后缀名）</p></blockquote><h2 id="2-2-使用roslaunch运行节点"><a href="#2-2-使用roslaunch运行节点" class="headerlink" title="2.2 使用roslaunch运行节点"></a>2.2 使用<code>roslaunch</code>运行节点</h2><ul><li><p>使用<code>rosrun</code>来运行节点实在太麻烦，需要开太多的终端。此时我们可以使用<code>roslaunch</code>来同时启动多个节点。同时，它还有很多灵活的地方，比如修改参数与节点的名称，设置节点的命名空间等（并且会自动启动ros master）。</p></li><li><p>首先需要创建一个<code>×.launch</code>文件，它基于<code>XML</code>，提供了标签选项。</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;ros_tutorials_topic&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;topic_publisher&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;topic_publisher1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;ros_tutorials_topic&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;topic_subscriber&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;topic_subscriber1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;ros_tutorials_topic&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;topic_publisher&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;topic_publisher2&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;ros_tutorials_topic&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;topic_subscriber&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;topic_subscriber2&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><p>launch文件中的标签；</p><ul><li>$launch$标签是launch文件中的根元素；</li><li>$node$标签表示启动节点<ul><li>$pkg$ 表示该节点所在的功能包的名称</li><li>$type$ 表示实际运行的节点的名称（也就是该节点对应的可执行文件名称）</li><li>$name$ 节点运行时的名称，如果只有一个同类型的节点，一般取的name与type相同</li><li>其他的还会有output、respawn、required、ns、args等；</li></ul></li><li>$param$标签为设置ROS系统运行中的参数，存储在参数服务器中；<ul><li>比如<code>&lt;param name=&quot;output_frame&quot; value=&quot;odom&quot;/&gt;</code><ul><li>name为参数名</li><li>value为参数值</li></ul></li><li>加载参数文件中的多个参数：<code>&lt;rosparam file=&quot;params.yaml&quot; command=&quot;load&quot; ns=&quot;params&quot; /&gt;</code></li></ul></li><li>$arg$标签为设置launch文件内部的局部变量，仅限于launch文件使用<ul><li>比如<code>arg name=&quot;arg-name&quot; value=&quot;arg-value&quot; /&gt;</code><ul><li>name为参数名</li><li>value为参数值</li></ul></li></ul></li><li>$remap$为重映射ros计算图资源的命名；<ul><li>比如<code>&lt;remap from=&quot;/turtlebot/cmd_vel&quot; to=&quot;/cmd_vel&quot; /&gt;</code></li></ul></li><li>$include$为包含其他launch文件，类似c语言的头文件包含<ul><li>比如<code>&lt;include file=&quot;$(dirname)/other.launch&quot; /&gt;</code></li></ul></li><li>运行该<code>union.launch</code>文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ roslaunch ros_tutorials_topic union.launch --screen<br></code></pre></td></tr></table></figure><hr><blockquote><p>此处需要说明的是使用<code>roslaunch</code>启动多个节点时，默认这些节点的输出（info、error）等不会打印在终端。所以添加一个<code>--screen</code>，则所有节点的输出会打印到终端上，方便调试。</p></blockquote><ul><li>查看运行结果</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rosnode list<br>/rosout<br>/topic_publisher1<br>/topic_publisher2<br>/topic_subscriber1<br>/topic_subscriber2<br></code></pre></td></tr></table></figure><div style="text-align: center"><img src="/assets/img/ros/launch1.PNG"/></div><blockquote><p>我们会发现此时两个订阅者都订阅了两个发布者发布的话题，这是因为两个发布者发布的话题名称相同，两个订阅者订阅的话题名称也一样。</p></blockquote><ul><li>为了使得<code>subscriber1</code>只订阅<code>publisher1</code>发布的话题，<code>subscriber2</code>只订阅<code>publisher2</code>发布的话题。我们可以将launch文件进行如下改写</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">group</span> <span class="hljs-attr">ns</span>=<span class="hljs-string">&quot;ns1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;ros_tutorials_topic&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;topic_publisher&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;topic_publisher&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;ros_tutorials_topic&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;topic_subscriber&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;topic_subscriber&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">group</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">group</span> <span class="hljs-attr">ns</span>=<span class="hljs-string">&quot;ns2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;ros_tutorials_topic&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;topic_publisher&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;topic_publisher&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;ros_tutorials_topic&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;topic_subscriber&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;topic_subscriber&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">group</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><ul><li><p>上面新的标签如下：</p><ul><li>$group$ 是对指定节点进行分组的标签</li><li>$ns$ 是group的选项，代表命名空间，是给这个组起了一个名字，使其与其他组区分开来</li></ul></li><li><p>新的launch文件运行后，使用<code>rqt_graph</code>来查看各个节点之间的关联，可以看到我们实现了目的。</p></li></ul><div style="text-align: center"><img src="/assets/img/ros/launch2.PNG"/></div><h2 id="2-3-launch的标签"><a href="#2-3-launch的标签" class="headerlink" title="2.3 launch的标签"></a>2.3 launch的标签</h2><p>在launch文件中根据XML的编写方式可以灵活的实现ros节点的启动。launch中会使用到的标签如下：</p><ul><li><p><code>launch</code> 指roslaunch语句的开始与结束</p></li><li><p><code>node</code> 这是节点运行的标签，可以在标签里修改功能包、节点名称、执行名称等</p></li><li><p><code>machine</code> 可以设置运行该节点的PC名称、address、ros-root还有ros-package-path等</p></li><li><p><code>include</code> 可以加载属于同一个功能包或不同功能包的另一个launch文件，并运行</p></li><li><p><code>remap</code> 可以更改节点名称、话题名称等等，在节点中用到的ROS变量的名称</p></li><li><p><code>env</code> 设置环境变量，如路径和IP（较少使用）</p></li><li><p><code>param</code> 设置参数名称、类型、值等</p></li><li><p><code>rosparam</code> 可以像rosparam命令一样，查看修改load、dump和delete等参数信息。</p></li><li><p><code>group</code> 用于分组正在运行的节点</p></li><li><p><code>test</code> 用于测试节点。类似于node，但是可以有用于测试的选型</p></li><li><p><code>arg</code> 可以在launch文件中定义一个变量，以便在像下面这样运行时更改参数</p></li></ul><p>此处举一个例子，大致演示一下如何使用<code>arg</code>与<code>param</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;update_period&quot;</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;timing&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$(arg update_period)&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="在运行上述launch文件时，可以指定上述参数的值"><a href="#在运行上述launch文件时，可以指定上述参数的值" class="headerlink" title="在运行上述launch文件时，可以指定上述参数的值"></a>在运行上述launch文件时，可以指定上述参数的值<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ roslaunch my_package my_package.launch update_period:=30<br></code></pre></td></tr></table></figure></h2><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1]. ROS Robot Programming. YoonSeok Pyo, HanCheol Cho, RyuWoon Jung, TaeHoon Lim</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dogleg算法解析</title>
    <link href="/2019/09/29/2019-09-29-dogleg/"/>
    <url>/2019/09/29/2019-09-29-dogleg/</url>
    
    <content type="html"><![CDATA[<p>之前有仔细介绍过非线性优化，其中二阶梯度的方法有高斯牛顿法、LM算法、dogleg算法等。前段时间仔细研究了dogleg算法的实现步骤，今天抽出时间总结一下。</p><blockquote><p>dogleg属于二阶梯度法，为了解决高斯牛顿法在使用一阶导数平方近似计算hessian矩阵时可能不准确的问题，它结合了高斯牛顿法与最速下降法，通过定义近似半径来限制近似的可执行范围。本质上与LM算法类似，不过实现细节大有不同。</p></blockquote><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>dogleg的思想很简单，对于一个非线性优化问题，它的每次的迭代步骤可以归纳如下：</p><ol><li><p>首先计算当前其高斯牛顿方法的迭代步长$$H_{gn}$$，然后计算最速下降法的迭代步长$$H_{sd}$$。</p></li><li><p>根据第一步中确定的$$H_{gn}$$与$$H_{sd}$$相对与当前信赖域半径$$r$$的大小确定本次dogleg更新的步长$$\delta$$；</p></li><li><p>使用第二步中确定的更新步长进行更新，然后计算$\rho$（与LM中相同），根据其大小判断是否执行本次迭代与如何更新信赖域半径$$r$$。</p></li></ol><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>第一步是计算高斯牛顿与最速下降两种方法的更新步长。</p><ul><li>高斯牛顿法步长$$H_{gn}$$可以通过求解如下方程组得到（推导可见<a href="https://xhy3054.github.io/nonlinear-optimization/">非线性优化</a>）</li></ul><p>$$\left(\mathbf{J}(\mathbf{x})^{\top} \mathbf{J}(\mathbf{x})\right) \mathbf{h}_{\mathrm{gn}}=-\mathbf{J}(\mathbf{x})^{\top} \mathbf{f}(\mathbf{x}) $$</p><ul><li>最速下降法步长$$H_{sd}$$，获得可以分为两步来获得<ul><li>第一步是先获得最速下降的方向</li><li>第二步是确定最速下降的步长</li><li>最后综合方向与步长即可得到更新的向量</li></ul></li></ul><p>首先，最速下降法的方向即是梯度反方向，先不考虑模长，我们可以使用下面公式表示(其中ｇ表示梯度方向)</p><p>$$ \mathbf{h}_{\mathrm{sd}} = -\mathbf{g} = -\mathbf{J}(\mathbf{x})^{\top} \mathbf{f}(\mathbf{x}) $$</p><p>然后我们知道利用雅克比矩阵可以得到下面模型：</p><p>$$<br>\begin{aligned} \mathbf{f}\left(\mathbf{x}+\alpha \mathbf{h}<em>{\mathrm{sd}}\right) &amp; \simeq \mathbf{f}(\mathbf{x})+\alpha \mathbf{J}(\mathbf{x}) \mathbf{h}</em>{\mathrm{sd}} \\ F\left(\mathbf{x}+\alpha \mathbf{h}<em>{\mathrm{sd}}\right) &amp; \simeq \frac{1}{2}\left|\mathbf{f}(\mathbf{x})+\alpha \mathbf{J}(\mathbf{x}) \mathbf{h}</em>{\mathrm{sd}}\right|^{2} \\ &amp;=F(\mathbf{x})+\alpha \mathbf{h}<em>{\mathrm{sd}}^{\top} \mathbf{J}(\mathbf{x})^{\top} \mathbf{f}(\mathbf{x})+\frac{1}{2} \alpha^{2}\left|\mathbf{J}(\mathbf{x}) \mathbf{h}</em>{\mathrm{sd}}\right|^{2} \end{aligned}<br>$$</p><p>我们对上述模型求最小值，此时$$\alpha$$应取值为：</p><p>$$<br>\alpha=-\frac{\mathbf{h}<em>{\mathrm{sd}}^{\top} \mathbf{J}(\mathbf{x})^{\top} \mathbf{f}(\mathbf{x})}{\left|\mathbf{J}(\mathbf{x}) \mathbf{h}</em>{\mathrm{sd}}\right|^{2}}=\frac{|\mathbf{g}|^{2}}{|\mathbf{J}(\mathbf{x}) \mathbf{g}|^{2}}<br>$$</p><p>所以，最后最速下降法的更新向量为</p><p>$$ \mathbf{h}<em>{\mathrm{sd}} = \alpha \mathbf{h}</em>{\mathrm{sd}} $$　</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>通过当前的信赖域半径与上一步计算的两种步长结合计算处dogleg算法的更新步长更新规则如下：</p><p><img src="/img/math/dogleg.PNG" alt="dogleg"></p><p>上图中的更新规则描述的较为清楚，但是代码实现尚有难度，主要是$$\beta$$的值较难确定。我在网上看到了一个更加明确的规则，将上述更新规则总结为一个统一的表达式。</p><p>$$<br>h_{dl}=\left\{\begin{array}{ll}{\tau h_{sd},} &amp; {0 \leq \tau \leq 1} \\ {h_{sd}+(\tau-1)\left(h_{gn}-h_{sd}\right),} &amp; {1 \leq \tau \leq 2}\end{array}\right.<br>$$</p><p>其中比较关键的是变量$$\tau$$的确定，我直接贴出代码(其中<code>delta_</code>是信赖区域的半径大小)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> tau;<br><span class="hljs-keyword">if</span>(H_gn.<span class="hljs-built_in">norm</span>() &lt;= delta_)<br>    tau = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(H_sd.<span class="hljs-built_in">norm</span>() &gt;= delta_)<br>    tau = delta_ / H_sd.<span class="hljs-built_in">norm</span>() ;<br><span class="hljs-keyword">else</span>&#123;<br>    VecX tmp = H_gn - H_sd ;<br>    tau = (- H_sd.<span class="hljs-built_in">transpose</span>() * tmp + <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">pow</span>((H_sd.<span class="hljs-built_in">transpose</span>() * tmp),<span class="hljs-number">2</span>) - tmp.<span class="hljs-built_in">squaredNorm</span>() * (H_sd.<span class="hljs-built_in">squaredNorm</span>() - <span class="hljs-built_in">pow</span>(delta_,<span class="hljs-number">2</span>)))) / tmp.<span class="hljs-built_in">squaredNorm</span>()       ;<br>    tau += <span class="hljs-number">1</span>;     <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>判断改更新是否执行，并更新信赖域半径，此处的迭代策略比较简单，我是看的参考文献第一篇提供的策略，直接贴代码了。</p><p>注意此处有个$$\rho$$的计算，其值为</p><p>$$<br>\rho=\frac{F(\mathbf{x})-F\left(\mathbf{x}+\Delta \mathbf{x}<em>{\operatorname{dl}}\right)}{L(\mathbf{0})-L\left(\Delta \mathbf{x}</em>{\mathrm{dl}}\right)}<br>$$</p><p>其中分母是此次更新后真实目标函数损失减少的量，分子是使用近似模型此次更新后目标函数损失应该减少的量。其中$$L(h)$$函数是如下线性函数模型</p><p>$$L(\mathbf{h}) = \frac{1}{2}|\mathbf{f}(\mathbf{x})+\mathbf{J}(\mathbf{x}) \mathbf{h}|^{2}$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 狗腿</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Problem::IsGoodStep</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//此处是计算当前目标函数的损失</span><br>    <span class="hljs-type">double</span> tempChi = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> edge:edges_)&#123;<br>        edge.second-&gt;<span class="hljs-built_in">ComputeResidual</span>();<br>        tempChi += edge.second-&gt;<span class="hljs-built_in">Chi2</span>();    <br>    &#125;<br> <br>    <span class="hljs-comment">//此处是计算近似使用dogleg步长更新理论上应该减小的损失</span><br>    <span class="hljs-type">double</span> scale = <span class="hljs-number">0</span>;<br>    scale = delta_x_.<span class="hljs-built_in">transpose</span>() * b_ ;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;第一部分scale为 &quot;</span>&lt;&lt;scale&lt;&lt;endl;<br>    scale -= <span class="hljs-number">0.5</span> * delta_x_.<span class="hljs-built_in">transpose</span>() * Hessian_ * delta_x_; <br>    scale += <span class="hljs-number">1e-3</span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;scale = &quot;</span>&lt;&lt;scale&lt;&lt;endl;<br><br>    <span class="hljs-type">double</span> rho = (currentChi_ - tempChi)/scale;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;rho: &quot;</span> &lt;&lt; rho &lt;&lt; <span class="hljs-string">&quot; , chi= &quot;</span> &lt;&lt; tempChi &lt;&lt; <span class="hljs-string">&quot; , delta= &quot;</span> &lt;&lt; delta_<br>                  &lt;&lt; std::endl;<br>    <span class="hljs-comment">//迭代策略</span><br>    <span class="hljs-keyword">if</span>(rho &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">isfinite</span>(tempChi))&#123;<br>        <span class="hljs-keyword">if</span>(rho&gt;<span class="hljs-number">0.75</span>) delta_ = std::<span class="hljs-built_in">max</span>(delta_, <span class="hljs-number">3.</span>*delta_x_.<span class="hljs-built_in">norm</span>());<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rho&lt;<span class="hljs-number">0.25</span>)   delta_ = delta_/<span class="hljs-number">2.</span>;<br>        currentChi_ = tempChi;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        delta_ = delta_/<span class="hljs-number">2.</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>对于dogleg算法基于eigen实现了一般版本，下面是其应用于曲线拟合的实例。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><p>[1] METHODS FOR NON-LINEAR LEAST SOUARES PROBLEMS. K.Madsen, H.B.Nielsen, O.Tingleff</p></li><li><p>[2] Is Levenberg-Marquardt the Most Efficient Optimization Algorithm for Implementing Bundle Adjustment. Manolis I.A.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vins中基于滑窗的后端优化</title>
    <link href="/2019/09/03/2019-09-03-vins-backend-optimize/"/>
    <url>/2019/09/03/2019-09-03-vins-backend-optimize/</url>
    
    <content type="html"><![CDATA[<p>前面已经讲了很多vins里的细节操作，今天来谈谈将整个系统最核心的后端优化部分。</p><h1 id="vins的后端优化"><a href="#vins的后端优化" class="headerlink" title="vins的后端优化"></a>vins的后端优化</h1><p>一般在vins系统中，视觉与imu数据经过预处理后，此时如果已经完成初始化，则会在滑窗中进行非线性优化操作。整个过程一般会是如下过程：</p><ol><li><p>对滑窗中所有特征点进行三角化操作</p></li><li><p>针对现有的窗口中的数据，构建非线性优化问题，并为该问题添加优化参数与待优化残差项，然后进行优化；</p></li><li><p>优化完成后进行滑窗操作（根据之前判断的次新帧是否作为关键帧保留，而选择是marg掉最老的关键帧或者marg掉次新帧）；</p></li></ol><blockquote><p>其中2,3两步是整个滑窗优化问题的核心操作。</p></blockquote><h2 id="参与优化的参数"><a href="#参与优化的参数" class="headerlink" title="参与优化的参数"></a>参与优化的参数</h2><p>在vins的后端优化中，<strong>优化的参数变量</strong>很多，主要有</p><ol><li><p>每一帧body系的位姿；</p></li><li><p>每一帧body系的速度；</p></li><li><p>每一帧时imu的bias;</p></li><li><p>每个特征点在可以观测到它的第一帧相机坐标系下的逆深度；</p></li><li><p>相机与body系的外参；</p></li><li><p>相机与imu测量的时间偏差（如果存在）;</p></li></ol><blockquote><p>其中imu测量的预积分残差会对1,2,3进行优化，视觉重投影残差会对1,4,5,6进行优化。</p></blockquote><h2 id="待优化的残差项"><a href="#待优化的残差项" class="headerlink" title="待优化的残差项"></a>待优化的残差项</h2><p>在vins的后端优化中，<strong>待优化的残差项</strong>也有一些，主要有</p><ol><li><p>imu测量的预积分残差；</p></li><li><p>视觉观测的重投影误差；</p></li><li><p>先验残差；</p></li><li><p>闭环检测残差；</p></li></ol><blockquote><p>在下面讲到优化过程时，涉及到很多求导雅克比矩阵的操作，这些求导操作是有明显的流程的。首先需要明确被求导的因变量，与求导的自变量。然后如果是关于姿态（四元数）的求导，就先将旋转变换到李群上，使用扰动模型去推导。其他的比较简单直接推就行了。</p></blockquote><h2 id="imu测量的预积分残差"><a href="#imu测量的预积分残差" class="headerlink" title="imu测量的预积分残差"></a>imu测量的预积分残差</h2><p>在滑窗中，首先被添加到问题中的残差项就是imu的残差。imu残差其实就是imu预积分的误差，计算方式如下（此处计算的残差是i帧与j帧之间的预积分残差）：</p><p>$$<br>\left[\begin{array}{c}{\mathbf{r}<em>{p}} \\ {\mathbf{r}</em>{q}} \\ {\mathbf{r}<em>{v}} \\ {\mathbf{r}</em>{b a}} \\ {\mathbf{r}<em>{b g}}\end{array}\right]</em>{15 \times 1}=\left[\begin{array}{c}{\mathbf{q}<em>{b</em>{i} w}\left(\mathbf{p}<em>{w b</em>{j}}-\mathbf{p}<em>{w b</em>{i}}-\mathbf{v}<em>{i}^{w} \Delta t+\frac{1}{2} \mathbf{g}^{w} \Delta t^{2}\right)-\boldsymbol{\alpha}</em>{b_{i} b_{j}}} \\ {2\left[\mathbf{q}<em>{b</em>{j} b_{i}} \otimes\left(\mathbf{q}<em>{b</em>{i} w} \otimes \mathbf{q}<em>{w b</em>{j}}\right)\right]<em>{x y z}} \\ {\mathbf{q}</em>{b_{i} w}\left(\mathbf{v}<em>{j}^{w}-\mathbf{v}</em>{i}^{w}+\mathbf{g}^{w} \Delta t\right)-\beta_{b_{i} b_{j}}} \\ {\mathbf{b}<em>{j}^{a}-\mathbf{b}</em>{i}^{a}} \\ {\mathbf{b}<em>{j}^{g}-\mathbf{b}</em>{i}^{g}}\end{array}\right]<br>$$</p><blockquote><p>在vins中，这个残差块与i帧时刻位姿、速度、bias还有j帧时刻的位姿、速度、bias相关，也就是最小化这个残差块需要不断优化以上的参数块。</p></blockquote><h3 id="imu残差的雅克比"><a href="#imu残差的雅克比" class="headerlink" title="imu残差的雅克比"></a>imu残差的雅克比</h3><blockquote><p>此处我们发现，上面的imu残差一共有五维，因此在计算雅克比时，可以对五个维度的残差分别对待优化参数块进行求导。由于此处如果全部进行求导，实在会太多公式，因此，此处仅仅以$$r_v$$为例，列举几个求导过程</p></blockquote><ul><li>$$r_v$$对i时刻位置求导</li></ul><p>$$<br>\frac{\partial \mathbf{r}<em>{v}}{\partial \delta \mathbf{p}</em>{b_{i} b_{i}^{\prime}}}=\mathbf{0}<br>$$</p><ul><li>$$r_v$$对i时刻角度求导</li></ul><p>$$<br>\begin{aligned} \frac{\partial \mathbf{r}<em>{v}}{\partial \delta \boldsymbol{\theta}</em>{b_{i} b_{i}^{\prime}}} &amp;=\frac{\partial\left(\mathbf{q}<em>{w b</em>{i}} \otimes\left[\begin{array}{c}{1} \\ {\frac{1}{2} \delta \boldsymbol{\theta}<em>{b</em>{i} b_{i}^{\prime}}}\end{array}\right]\right)^{-1}\left(\mathbf{v}<em>{j}^{w}-\mathbf{v}</em>{i}^{w}+\mathbf{g}^{w} \Delta t\right)}{\partial \delta \boldsymbol{\theta}<em>{b</em>{i} b_{i}^{\prime}}} \\ &amp;=\frac{\partial\left(\mathbf{R}<em>{w b</em>{i}} \exp \left(\left[\delta \boldsymbol{\theta}<em>{b</em>{i}}^{\prime}\right] \times\right)\right)^{-1}\left(\mathbf{v}<em>{j}^{w}-\mathbf{v}</em>{i}^{w}+\mathbf{g}^{w} \Delta t\right)}{\partial \delta \boldsymbol{\theta}<em>{b</em>{i} b_{i}^{\prime}}} \\ &amp;=\frac{\partial \exp \left(\left[-\delta \boldsymbol{\theta}<em>{b</em>{i} b_{i}^{\prime}}\right]<em>{\mathbf{X}}\right) \mathbf{R}</em>{b_{i} w}\left(\mathbf{v}<em>{j}^{w}-\mathbf{v}</em>{i}^{w}+\mathbf{g}^{w} \Delta t\right)}{\partial \delta \boldsymbol{\theta}<em>{b</em>{i} b_{i}^{\prime}}} \end{aligned}<br>$$</p><p>$$<br>\begin{aligned} &amp;=\frac{\partial\left(\mathbf{I}-\left[\delta \boldsymbol{\theta}<em>{b</em>{i} b_{i}^{\prime}}\right] \times\right) \mathbf{R}<em>{b</em>{i} w}\left(\mathbf{v}<em>{j}^{w}-\mathbf{v}</em>{i}^{w}+\mathbf{g}^{w} \Delta t\right)}{\partial \delta \boldsymbol{\theta}<em>{b</em>{i} b_{i}^{\prime}}} \=&amp; \frac{\partial-\left[\delta \boldsymbol{\theta}<em>{b</em>{i} b_{i}^{\prime}}\right] \times \boldsymbol{R}<em>{b</em>{i} w}\left(\mathbf{v}<em>{j}^{w}-\mathbf{v}</em>{i}^{w}+\mathbf{g}^{w} \Delta t\right)}{\partial \delta \boldsymbol{\theta}<em>{b</em>{i} b_{i}^{\prime}}} \=&amp; \frac{\partial\left[\mathbf{R}<em>{b</em>{i} w}\left(\mathbf{v}<em>{j}^{w}-\mathbf{v}</em>{i}^{w}+\mathbf{g}^{w} \Delta t\right]<em>{ \times}\right) \delta \boldsymbol{\theta}</em>{b_{i} b_{i}^{\prime}}}{\partial \delta \boldsymbol{\theta}<em>{b</em>{i} b_{i}^{\prime}}} \=&amp;\left[\mathbf{R}<em>{b</em>{i} w}\left(\mathbf{v}<em>{j}^{w}-\mathbf{v}</em>{i}^{w}+\mathbf{g}^{w} \Delta t\right)\right]_{\mathbf{x}} \end{aligned}<br>$$</p><ul><li>$$r_v$$对i时刻速度求导</li></ul><p>$$<br>\frac{\partial \mathbf{r}<em>{v}}{\partial \delta \mathbf{v}</em>{i}^{w}}=-\mathbf{R}<em>{b</em>{i} w}<br>$$</p><ul><li>$$r_v$$对i时刻bias求导（注意，此处预积分对bias的导数在初始化时就已经求过了）</li></ul><p>$$<br>\frac{\partial \mathbf{r}<em>{v}}{\partial \delta \mathbf{b}</em>{i}^{a}}=-\frac{\partial \boldsymbol{\beta}<em>{b</em>{i} b_{j}}}{\partial \delta \mathbf{b}<em>{i}^{a}}=-\mathbf{J}</em>{b_{i}^{a}}^{\beta}<br>$$</p><blockquote><p>其实在计算imu残差的雅克比矩阵时，会多次用到链式法则，因为在另外一篇讲解<a href="https://xhy3054.github.io/2019/07/31/2019-07-31-pre-integration/">imu预积分</a>的博客中，已经计算出了imu预积分相对于bias的雅克比。</p></blockquote><h3 id="imu残差的协方差"><a href="#imu残差的协方差" class="headerlink" title="imu残差的协方差"></a>imu残差的协方差</h3><p>上文中给出了残差与雅克比的计算，我们知道如果想使用高斯牛顿或者LM算法，最好还需要给出准确的协方差。此处由于在imu积分中，协方差是一直传递的。我们知道imu增量的递推公式可以写为：</p><p>$$\delta z_{k+1}^{15 \times 1}=F^{15 \times 15} \delta z_{k}^{15 \times 1} + V^{15 \times 18} n^{18 \times 1}$$</p><p>由上式我们知道，协方差的传递公式为：</p><p>$$ P_{k+1} = F P_k F^T + V Q V^T, P_0 = 0 $$</p><p>此处我们假设初始值是为0，噪声项的<strong>对角协方差矩阵Q</strong>可以通过艾伦方差标定得到(此处前两项是k时刻的加速度与角速度的高斯白噪方差，中间两项是k+1时刻的高斯白噪方差，最后两项是k时刻的bias随机游走方差，它们之间互相不相关，所以是对角矩阵)。</p><p>$$ Q^{18 \times 18} = \left(\sigma_{a}^2 , \sigma_{w}^2 , \sigma_{a}^2 , \sigma_{w}^2 , \sigma_{ba}^2 , \sigma_{bw}^2 \right) $$</p><h2 id="视觉观测的重投影误差"><a href="#视觉观测的重投影误差" class="headerlink" title="视觉观测的重投影误差"></a>视觉观测的重投影误差</h2><p>视觉残差也就是特征点的重投影误差，vins中的视觉残差是由每个特征点从观测到它的第一帧，到所有可以观测到它的其他帧的重投影误差组成的。</p><p>拿其中任意一项举例，比如这项是一个特征点从i帧到j帧的重投影误差，这个特征点在i帧相机平面的归一化坐标为$$(u_{ci}, v_{ci})$$，深度为$$\lambda$$，在j帧相机平面的归一化坐标为$$(u_{cj}, v_{cj})$$。假设将这个点从i帧投影到j帧的相机坐标系，则过程如下：</p><p>$$<br>\left[\begin{array}{c}{x_{c_{j}}} \\ {y_{c_{j}}} \\ {z_{c_{j}}} \\ {1}\end{array}\right]=\mathbf{T}<em>{b c}^{-1} \mathbf{T}</em>{w b_{j}}^{-1} \mathbf{T}<em>{w b</em>{i}} \mathbf{T}<em>{b c}\left[\begin{array}{c}{\frac{1}{\lambda} u</em>{c_{i}}} \\ {\frac{1}{\lambda} v_{c_{i}}} \\ {\frac{1}{\lambda}} \\ {1}\end{array}\right]<br>$$</p><p>整个投影过程比较长，依次是将特征点</p><ol><li><p>从i帧相机坐标系变换到i帧body坐标系</p></li><li><p>从i帧body坐标系变换到世界坐标系</p></li><li><p>从世界坐标系变换到j帧body坐标系</p></li><li><p>从j帧body坐标系变换到j帧相机坐标系</p></li></ol><p>将上面这个变换拆分成3维坐标形式，变换形式如下：</p><p>$$<br>\begin{aligned} \mathbf{f}<em>{c</em>{j}}=\left[\begin{array}{c}{x_{c_{j}}} \\ {y_{c_{j}}} \\ {z_{c_{j}}}\end{array}\right] &amp;=\mathbf{R}<em>{b c}^{\top} \mathbf{R}</em>{w b_{j}}^{\top} \mathbf{R}<em>{w b</em>{i}} \mathbf{R}<em>{b c} \frac{1}{\lambda}\left[\begin{array}{c}{u</em>{c_{i}}} \\ {v_{c_{i}}} \\ {1}\end{array}\right] \\ &amp;+\mathbf{R}<em>{b c}^{\top}\left(\mathbf{R}</em>{w b_{j}}^{\top}\left(\left(\mathbf{R}<em>{w b</em>{i}} \mathbf{p}<em>{b c}+\mathbf{p}</em>{w b_{i}}\right)-\mathbf{p}<em>{w b</em>{j}}\right)-\mathbf{p}_{b c}\right) \end{aligned}<br>$$</p><p>而视觉残差就是</p><p>$$<br>\mathbf{r}<em>{c}=\left[\begin{array}{c}{\frac{x</em>{c_{j}}}{z_{c_{j}}}-u_{c_{j}}} \\ {\frac{y_{c_{j}}}{z_{c_{j}}}-v_{c_{j}}}\end{array}\right]<br>$$</p><h3 id="视觉残差的雅克比"><a href="#视觉残差的雅克比" class="headerlink" title="视觉残差的雅克比"></a>视觉残差的雅克比</h3><blockquote><p>此处推导视觉残差的雅克比遵循了链式法则，首先求视觉残差对$$\mathbf{f}<em>{c</em>{j}}$$的导数，然后由$$\mathbf{f}<em>{c</em>{j}}$$开始求其对待优化参数的偏导数。</p></blockquote><ul><li>首先，残差对$$\mathbf{f}<em>{c</em>{j}}$$求导；</li></ul><p>$$<br>\frac{\partial \mathbf{r}<em>{c}}{\partial \mathbf{f}</em>{c_{j}}}=\left[\begin{array}{ccc}{\frac{1}{z_{c_{j}}}} &amp; {0} &amp; {-\frac{x_{c_{j}}}{z_{c_{j}}^{2}}} \\ {0} &amp; {\frac{1}{z_{c_{j}}}} &amp; {-\frac{y_{c_{j}}}{z_{c_{j}}^{2}}}\end{array}\right]<br>$$</p><ul><li><p>其次，$$\mathbf{f}<em>{c</em>{j}}$$对各状态量求导；</p></li><li><p>$$\mathbf{f}<em>{c</em>{j}}$$对i时刻位置求导；</p></li></ul><p>$$<br>\frac{\partial \mathbf{f}<em>{c</em>{j}}}{\partial \delta \mathbf{p}<em>{b</em>{i} b_{i}^{\prime}}}=\mathbf{R}<em>{b c}^{\top} \mathbf{R}</em>{w b_{j}}^{\top}<br>$$</p><ul><li>$$\mathbf{f}<em>{c</em>{j}}$$对i时刻姿态求导；</li></ul><p>$$<br>\mathbf{f}<em>{c</em>{j}}=\mathbf{R}<em>{b c}^{\top} \mathbf{R}</em>{w b_{j}}^{\top} \mathbf{R}<em>{w b</em>{i}} \mathbf{R}<em>{b c} \mathbf{f}</em>{c_{i}}+\mathbf{R}<em>{b c}^{\top}\left(\mathbf{R}</em>{w b_{j}}^{\top}\left(\left(\mathbf{R}<em>{w b</em>{i} \mathbf{p}<em>{b c}}+\mathbf{p}</em>{w b_{i}}\right)-\mathbf{p}<em>{w b</em>{j}}\right)-\mathbf{p}_{b c}\right)<br>$$</p><p>$$<br>\begin{aligned} \frac{\partial \mathbf{f}<em>{c</em>{j}}}{\partial \delta \boldsymbol{\theta}<em>{b</em>{i} b_{i}^{\prime}}} &amp;=\frac{\partial \mathbf{R}<em>{b c}^{\top} \mathbf{R}</em>{w b_{j}}^{\top} \mathbf{R}<em>{w b</em>{i}}\left(\mathbf{I}+\left[\delta \boldsymbol{\theta}<em>{b</em>{i} b_{i}^{\prime}}\right]<em>{\mathbf{x}}\right) \mathbf{f}</em>{b_{i}}}{\partial \delta \boldsymbol{\theta}<em>{b</em>{i} b_{i}^{\prime}}} \\ &amp;=-\mathbf{R}<em>{b c}^{\top} \mathbf{R}</em>{w b_{j}}^{\top} \mathbf{R}<em>{w b</em>{i}}\left[\mathbf{f}<em>{b</em>{i}}\right]_{ \times} \end{aligned}<br>$$</p><ul><li>$$\mathbf{f}<em>{c</em>{j}}$$对j时刻位置求导；</li></ul><p>$$<br>\frac{\partial \mathbf{f}<em>{c</em>{j}}}{\partial \delta \mathbf{p}<em>{b</em>{j} b_{j}^{\prime}}}= - \mathbf{R}<em>{b c}^{\top} \mathbf{R}</em>{w b_{j}}^{\top}<br>$$</p><ul><li>$$\mathbf{f}<em>{c</em>{j}}$$对j时刻姿态求导；</li></ul><p>$$<br>\begin{aligned} \mathbf{f}<em>{c</em>{j}} &amp;=\mathbf{R}<em>{b c}^{\top} \mathbf{R}</em>{w b_{j}}^{\top} \mathbf{R}<em>{w b</em>{i}} \mathbf{R}<em>{b c} \mathbf{f}</em>{c_{i}}+\mathbf{R}<em>{b c}^{\top}\left(\mathbf{R}</em>{w b_{j}}^{\top}\left(\left(\mathbf{R}<em>{w b</em>{i} \mathbf{p}<em>{b c}}+\mathbf{p}</em>{w b_{i}}\right)-\mathbf{p}<em>{w b</em>{j}}\right)-\mathbf{p}<em>{b c}\right) \\ &amp;=\mathbf{R}</em>{b c}^{\top} \mathbf{R}<em>{w b</em>{j}}^{\top}\left(\mathbf{R}<em>{w b</em>{i}}\left(\mathbf{R}<em>{b c} \mathbf{f}</em>{c_{i}}+\mathbf{p}<em>{b c}\right)+\mathbf{p}</em>{w b_{i}}-\mathbf{p}<em>{w b</em>{j}}\right)+(\ldots) \\ &amp;=\mathbf{R}<em>{b c}^{\top} \mathbf{R}</em>{w b_{j}}^{\top}\left(\mathbf{f}<em>{w}-\mathbf{p}</em>{w b_{j}}\right)+(\ldots) \end{aligned}<br>$$</p><p>$$<br>\begin{aligned} \frac{\partial \mathbf{f}<em>{c</em>{j}}}{\partial \delta \boldsymbol{\theta}<em>{b</em>{j} b_{j}^{\prime}}} &amp;=\frac{\partial \mathbf{R}<em>{b c}^{\top}\left(\mathbf{I}-\left[\delta \boldsymbol{\theta}</em>{b_{j} b_{j}^{\prime}}\right] \times\right) \mathbf{R}<em>{w b</em>{j}}^{\top}\left(\mathbf{f}<em>{w}-\mathbf{p}</em>{w b_{j}}\right)}{\partial \delta \boldsymbol{\theta}<em>{b</em>{j} b_{j}^{\prime}}} \\ &amp;=\frac{\partial \mathbf{R}<em>{b c}^{\top}\left(\mathbf{I}-\left[\delta \boldsymbol{\theta}</em>{b_{j} b_{j}^{\prime}}\right] \times\right) \mathbf{f}<em>{b</em>{j}}}{\partial \delta \boldsymbol{\theta}<em>{b</em>{j} b_{j}^{\prime}}} \\ &amp;=\mathbf{R}<em>{b c}^{\top}\left[\mathbf{f}</em>{b_{j}}\right]_{ \times} \end{aligned}<br>$$</p><ul><li>$$\mathbf{f}<em>{c</em>{j}}$$对imu与相机之间的外参位移求导；</li></ul><p>$$<br>\frac{\partial \mathbf{f}<em>{c</em>{j}}}{\partial \delta \mathbf{p}<em>{c c^{\prime}}}=\mathbf{R}</em>{b c}^{\top}\left(\mathbf{R}<em>{w b</em>{j}}^{\top} \mathbf{R}<em>{w b</em>{i}}-\mathbf{I}_{3 \times 3}\right)<br>$$</p><ul><li>$$\mathbf{f}<em>{c</em>{j}}$$对imu与相机之间的外参角度求导；</li></ul><p>$$<br>\frac{\partial \mathbf{f}<em>{c</em>{j}}}{\partial \delta \boldsymbol{\theta}<em>{c c^{\prime}}}=-\mathbf{R}</em>{b c}^{\top} \mathbf{R}<em>{w b</em>{j}}^{\top} \mathbf{R}<em>{w b</em>{i}} \mathbf{R}<em>{b c}\left[\mathbf{f}</em>{c_{i}}\right]<em>{\mathbf{x}}+\left[\mathbf{R}</em>{b c}^{\top} \mathbf{R}<em>{w b</em>{j}}^{\top} \mathbf{R}<em>{w b</em>{i}} \mathbf{R}<em>{b c} \mathbf{f}</em>{c_{i}}\right]<em>{ \times} +<br>\left[\mathbf{R}</em>{b c}^{\top}\left(\mathbf{R}<em>{w b</em>{j}}^{\top}\left(\left(\mathbf{R}<em>{w b</em>{i}} \mathbf{p}<em>{b c}+\mathbf{p}</em>{w b_{i}}\right)-\mathbf{p}<em>{w b</em>{j}}\right)-\mathbf{p}_{b c}\right)\right] \times<br>$$</p><ul><li>$$\mathbf{f}<em>{c</em>{j}}$$对特征在i帧相机坐标系中的逆深度求导；</li></ul><p>$$<br>\begin{aligned} \frac{\partial \mathbf{f}<em>{c</em>{j}}}{\partial \delta \lambda} &amp;=\frac{\partial \mathbf{f}<em>{c</em>{j}}}{\partial \mathbf{f}<em>{c</em>{i}}} \frac{\partial \mathbf{f}<em>{c</em>{i}}}{\partial \delta \lambda} \\ &amp;=\mathbf{R}<em>{b c}^{\top} \mathbf{R}</em>{w b_{j}}^{\top} \mathbf{R}<em>{w b</em>{i}} \mathbf{R}<em>{b c}\left(-\frac{1}{\lambda^{2}}\left[\begin{array}{c}{u</em>{c_{i}}} \\ {v_{c_{i}}} \\ {1}\end{array}\right]\right) \\ &amp;=-\frac{1}{\lambda} \mathbf{R}<em>{b c}^{\top} \mathbf{R}</em>{w b_{j}}^{\top} \mathbf{R}<em>{w b</em>{i}} \mathbf{R}<em>{b c} \mathbf{f}</em>{c_{i}} \end{aligned}<br>$$</p><blockquote><p>上面的推导公式中，有一些推导步骤实在太过繁琐复杂，因此被我舍去了，如果大家想看，可以自己手动推导或者查看一些vio论文，会有详细推导过程。</p></blockquote><h3 id="视觉约束的协方差"><a href="#视觉约束的协方差" class="headerlink" title="视觉约束的协方差"></a>视觉约束的协方差</h3><p>在vins代码中假设重投影到像素平面上时的<code>sqrt_info</code>为1.5个像素，对应到归一化平面上需要除以焦距f。这个是假设视觉投影时投影点的位置在理论值附近呈均值为0，标准差为1.5个像素的高斯分布。代码部分如下：</p><pre><code class="hljs">ProjectionFactor::sqrt_info = FOCAL_LENGTH / 1.5 * Matrix2d::Identity();</code></pre><h2 id="先验残差"><a href="#先验残差" class="headerlink" title="先验残差"></a>先验残差</h2><h2 id="marg掉最老的关键帧"><a href="#marg掉最老的关键帧" class="headerlink" title="marg掉最老的关键帧"></a>marg掉最老的关键帧</h2><h2 id="marg掉次新的关键帧"><a href="#marg掉次新的关键帧" class="headerlink" title="marg掉次新的关键帧"></a>marg掉次新的关键帧</h2>]]></content>
    
    
    
    <tags>
      
      <tag>多传感器融合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vins初始化中的陀螺仪偏置标定</title>
    <link href="/2019/08/23/2019-08-23-vins-gyro-bias/"/>
    <url>/2019/08/23/2019-08-23-vins-gyro-bias/</url>
    
    <content type="html"><![CDATA[<p>vins是一个很好的开源工作，最近一直在熟悉它，其中大部分的内容之前已经或多多少提到过了，这篇博客主要讲一讲vins初始化中的视觉与imu联合初始化工作。</p><blockquote><p>注意：$$T_{WI}$$指的是从I系到W系的变换矩阵。</p></blockquote><h1 id="陀螺仪偏置标定问题"><a href="#陀螺仪偏置标定问题" class="headerlink" title="陀螺仪偏置标定问题"></a>陀螺仪偏置标定问题</h1><blockquote><p>这个工作主要是在<code>vins/vins_estimator/src/initial/initial_aligment.cpp</code>文件中的<code>solveGyroscopeBias</code>函数中实现的。此处之所以只对陀螺仪的bias进行标定，而不对加速度计的bias进行标定，原因是视觉sfm恢复出来的角度变换不受尺度影响，比较稳定准确。而sfm恢复出来的位移信息收到尺度影响，不似角度可以直接对齐。</p></blockquote><p>对于窗口中连续两帧图像$b_{k}$和$b_{k+1}$，之前已经通过视觉sfm得到了两帧相对于滑窗第一帧的旋转$$\mathbf{q}<em>{c</em>{0} b_{k}}$$和$$\mathbf{q}<em>{c</em>{0} b_{k+1}}$$，此时之前通过IMU预积分得到这两帧旋转的预积分$$\hat{\gamma}<em>{b_k b</em>{k+1}}$$（先前不带bias的预积分）。</p><p>此时，我们可以建立约束方程，最小化代价函数，如下：</p><p>$$<br>\arg \min <em>{\delta \mathbf{b}^{g}} \sum</em>{k \in B}\left|2\left\lfloor\mathbf{q}<em>{c</em>{0} b_{k+1}}^{-1} \otimes \mathbf{q}<em>{c</em>{0} b_{k}} \otimes {\gamma}<em>{b_k b</em>{k+1}}\right\rfloor_{x y z}\right|^{2}<br>$$</p><blockquote><p>其中$${\gamma}<em>{b_k b</em>{k+1}}$$表示的是算上陀螺仪bias的预积分值。</p></blockquote><p>$$<br>\gamma_{b_k b_{k+1}} \approx \hat{\gamma}<em>{b_k b</em>{k+1}} \otimes\left[\begin{array}{c}{1} \ {\frac{1}{2} J_{b_{g}}^{\gamma} \delta b_{g}}\end{array}\right]<br>$$</p><h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><p>在上述问题的求解时，最理想的情况如下（其中等式右边的四元数代表的是旋转不变的四元数）：</p><p>$$<br>\mathbf{q}<em>{c</em>{0} b_{k+1}}^{-1} \otimes \mathbf{q}<em>{c</em>{0} b_{k}} \otimes {\gamma}<em>{b_k b</em>{k+1}} &#x3D; \left[\begin{array}{l}{1} \ {0}\end{array}\right]<br>$$</p><p>对上式进行变换可以得到</p><p>$$<br>{\gamma}<em>{b_k b</em>{k+1}} &#x3D; \mathbf{q}<em>{c</em>{0} b_{k}}^{-1} \otimes \mathbf{q}<em>{c</em>{0} b_{k+1}} \otimes \left[\begin{array}{l}{1} \ {0}\end{array}\right]<br>$$</p><p>将$$\delta b_{g}$$带入上式可以得到</p><p>$$<br>\hat{\gamma}<em>{b_k b</em>{k+1}} \otimes\left[\begin{array}{c}{1} \ {\frac{1}{2} J_{b_{g}}^{\gamma} \delta b_{g}}\end{array}\right] &#x3D; \mathbf{q}<em>{c</em>{0} b_{k}}^{-1} \otimes \mathbf{q}<em>{c</em>{0} b_{k+1}} \otimes \left[\begin{array}{l}{1} \ {0}\end{array}\right]<br>$$</p><p>只考虑上式虚部，我们可以得到(其中$vec$代表取虚部)</p><p>$$<br>J_{b_{g}}^{\gamma} \delta b_{g}&#x3D;2\left({\hat{\gamma}<em>{b_k b</em>{k+1}}}^{-1} \otimes \mathbf{q}<em>{c</em>{0} b_{k}}^{-1} \otimes \mathbf{q}<em>{c</em>{0} b_{k+1}}\right)_{v e c}<br>$$</p><p>对于上式，我们想要做的是求解出$$\delta b_{g}$$的大小，此时我们可以使用如下办法：</p><ul><li>等式两侧同时乘以$$J_{b_{g}}^{\gamma T}$$（在使用cholesky分解求解矩阵，获取使目标函数达到最小的解时，需要将系数矩阵变为正定。），即得到</li></ul><p>$$<br>J_{b_{g}}^{\gamma T} J_{b_{g}}^{\gamma} \delta b_{g}&#x3D;2 J_{b_{g}}^{\gamma T} \left({\hat{\gamma}<em>{b_k b</em>{k+1}}}^{-1} \otimes \mathbf{q}<em>{c</em>{0} b_{k}}^{-1} \otimes \mathbf{q}<em>{c</em>{0} b_{k+1}}\right)_{v e c}<br>$$</p><ul><li>使用LDLT分解即可求得 $$\delta b_{g}$$</li></ul><h2 id="vins中代码实现"><a href="#vins中代码实现" class="headerlink" title="vins中代码实现"></a>vins中代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief   陀螺仪偏置校正</span><br><span class="hljs-comment"> * @optional    根据视觉SFM的结果来校正陀螺仪Bias -&gt; Paper V-B-1</span><br><span class="hljs-comment"> *              主要是将相邻帧之间SFM求解出来的旋转矩阵与IMU预积分的旋转量对齐</span><br><span class="hljs-comment"> *              注意得到了新的Bias后对应的预积分需要repropagate</span><br><span class="hljs-comment"> * @param[in]   all_image_frame所有图像帧构成的map,图像帧保存了位姿、预积分量和关于角点的信息</span><br><span class="hljs-comment"> * @param[out]  Bgs 陀螺仪偏置</span><br><span class="hljs-comment"> * @return      void</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveGyroscopeBias</span><span class="hljs-params">(map&lt;<span class="hljs-type">double</span>, ImageFrame&gt; &amp;all_image_frame, Vector3d* Bgs)</span></span><br><span class="hljs-function"></span>&#123;<br>    Matrix3d A;<br>    Vector3d b;<br>    Vector3d delta_bg;<br>    A.<span class="hljs-built_in">setZero</span>();<br>    b.<span class="hljs-built_in">setZero</span>();<br>    map&lt;<span class="hljs-type">double</span>, ImageFrame&gt;::iterator frame_i;<br>    map&lt;<span class="hljs-type">double</span>, ImageFrame&gt;::iterator frame_j;<br>    <span class="hljs-comment">//遍历所有图像帧</span><br>    <span class="hljs-keyword">for</span> (frame_i = all_image_frame.<span class="hljs-built_in">begin</span>(); <span class="hljs-built_in">next</span>(frame_i) != all_image_frame.<span class="hljs-built_in">end</span>(); frame_i++)<br>    &#123;<br>        <span class="hljs-comment">//下一帧</span><br>        frame_j = <span class="hljs-built_in">next</span>(frame_i);<br>        <span class="hljs-function">MatrixXd <span class="hljs-title">tmp_A</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)</span></span>;<br>        tmp_A.<span class="hljs-built_in">setZero</span>();<br>        <span class="hljs-function">VectorXd <span class="hljs-title">tmp_b</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br>        tmp_b.<span class="hljs-built_in">setZero</span>();<br><br>        <span class="hljs-comment">//两帧之间的旋转变换 </span><br>        <span class="hljs-comment">//R_ij = (R^c0_bk)^-1 * (R^c0_bk+1) 转换为四元数 q_ij = (q^c0_bk)^-1 * (q^c0_bk+1)</span><br>        <span class="hljs-function">Eigen::Quaterniond <span class="hljs-title">q_ij</span><span class="hljs-params">(frame_i-&gt;second.R.transpose() * frame_j-&gt;second.R)</span></span>;<br>        <span class="hljs-comment">//tmp_A = J_j_bw 雅可比 ，之前的预积分是没有算上陀螺仪bias的</span><br>        tmp_A = frame_j-&gt;second.pre_integration-&gt;jacobian.<span class="hljs-keyword">template</span> <span class="hljs-built_in">block</span>&lt;<span class="hljs-number">3</span>, <span class="hljs-number">3</span>&gt;(O_R, O_BG);<br>        <span class="hljs-comment">//tmp_b = 2 * (r^bk_bk+1)^-1 * (q^c0_bk)^-1 * (q^c0_bk+1)</span><br>        <span class="hljs-comment">//      = 2 * (r^bk_bk+1)^-1 * q_ij</span><br>        tmp_b = <span class="hljs-number">2</span> * (frame_j-&gt;second.pre_integration-&gt;delta_q.<span class="hljs-built_in">inverse</span>() * q_ij).<span class="hljs-built_in">vec</span>();<br>        <span class="hljs-comment">//tmp_A * delta_bg = tmp_b</span><br>        A += tmp_A.<span class="hljs-built_in">transpose</span>() * tmp_A;<br>        b += tmp_A.<span class="hljs-built_in">transpose</span>() * tmp_b;<br><br>    &#125;<br>    <span class="hljs-comment">//LDLT方法</span><br>    delta_bg = A.<span class="hljs-built_in">ldlt</span>().<span class="hljs-built_in">solve</span>(b);<br>    <span class="hljs-built_in">ROS_WARN_STREAM</span>(<span class="hljs-string">&quot;gyroscope bias initial calibration &quot;</span> &lt;&lt; delta_bg.<span class="hljs-built_in">transpose</span>());<br><br>    <span class="hljs-comment">//假设窗口中bgs值都相同</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= WINDOW_SIZE; i++)<br>        Bgs[i] += delta_bg;<br><br>    <span class="hljs-comment">//标定成功bias后需要重新进行预积分</span><br>    <span class="hljs-keyword">for</span> (frame_i = all_image_frame.<span class="hljs-built_in">begin</span>(); <span class="hljs-built_in">next</span>(frame_i) != all_image_frame.<span class="hljs-built_in">end</span>( ); frame_i++)<br>    &#123;<br>        frame_j = <span class="hljs-built_in">next</span>(frame_i);<br>        frame_j-&gt;second.pre_integration-&gt;<span class="hljs-built_in">repropagate</span>(Vector3d::<span class="hljs-built_in">Zero</span>(), Bgs[<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] <a href="https://github.com/HKUST-Aerial-Robotics/VINS-Mono">https://github.com/HKUST-Aerial-Robotics/VINS-Mono</a></li><li>[2] VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator, Tong Qin, Peiliang Li, Zhenfei Yang, Shaojie Shen, IEEE Transactions on Robotics</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>多传感器融合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IMU预积分</title>
    <link href="/2019/07/31/2019-07-31-pre-integration/"/>
    <url>/2019/07/31/2019-07-31-pre-integration/</url>
    
    <content type="html"><![CDATA[<p>在vio中会经常看到预积分这个词，vins中有，okvis中也有，所以，这个东西到底有什么作用呢？</p><h1 id="预积分的由来"><a href="#预积分的由来" class="headerlink" title="预积分的由来"></a>预积分的由来</h1><p>首先，一般imu的频率是比相机高的，所以在两个图像帧之间，会有很多imu采集的数据。如下图：</p><div style="text-align: center"><img src="/assets/img/vio/pre-inte.PNG"/></div><p>此处假设IMU的真实值是$\omega, \mathbf{a}$，测量值为$\tilde{\boldsymbol{\omega}}, \tilde{\mathbf{a}}$，则有：</p><p>$$<br>\begin{aligned} \tilde{\omega}^{b} &amp;&#x3D;\omega^{b}+\mathbf{b}^{g}+\mathbf{n}^{g} \ \tilde{\mathbf{a}}^{b} &amp;&#x3D;\mathbf{q}_{b w}\left(\mathbf{a}^{w}+\mathbf{g}^{w}\right)+\mathbf{b}^{a}+\mathbf{n}^{a} \end{aligned}<br>$$</p><p>其中上标$g$表示gyro（陀螺仪坐标系），$a$表示acc（加速度计坐标系），$w$表示在世界坐标系world，$b$表示imu机体坐标系body。</p><p>根据运动学方程，位置、速度、姿态（PVQ）的导数有如下：</p><p>$$<br>\begin{array}{l}{\dot{\mathbf{p}}<em>{w b</em>{t}}&#x3D;\mathbf{v}<em>{t}^{w}} \ {\dot{\mathbf{v}}</em>{t}^{w}&#x3D;\mathbf{a}<em>{t}^{w}} \ {\dot{\mathbf{q}}</em>{w b_{t}}&#x3D;\mathbf{q}<em>{w b</em>{t}} \otimes\left[\begin{array}{c}{0} \ {\frac{1}{2} \boldsymbol{\omega}^{b_{t}}}\end{array}\right]}\end{array}<br>$$</p><p>从第i时刻的PVQ对IMU的测量值进行积分得到第j时刻的PVQ：</p><p>$$<br>\begin{array}{l}{\mathbf{p}<em>{w b</em>{j}}&#x3D;\mathbf{p}<em>{w b</em>{i}}+\mathbf{v}<em>{i}^{w} \Delta t+\iint</em>{t \in[i, j]}\left(\mathbf{q}<em>{w b</em>{t}} \mathbf{a}^{b_{t}}-\mathbf{g}^{w}\right) \delta t^{2}} \ {\mathbf{v}<em>{j}^{w}&#x3D;\mathbf{v}</em>{i}^{w}+\int_{t \in[i, j]}\left(\mathbf{q}<em>{w b</em>{t}} \mathbf{a}^{b_{t}}-\mathbf{g}^{w}\right) \delta t} \ {\mathbf{q}<em>{w b</em>{j}}&#x3D;\int_{t \in[i, j]} \mathbf{q}<em>{w b</em>{t}} \otimes\left[\begin{array}{c}{0} \ {\frac{1}{2} \boldsymbol{\omega}^{b_{t}}}\end{array}\right] \delta t}\end{array}<br>$$</p><blockquote><p>此时我们发现，在积分项中存在全局姿态$q_{wb_{t}}$，同时在$\mathbf{a}^{b_{t}}$等测量值中还会引入bias。这样每次在迭代优化过后，由于$q_{wb_{t}}$与bias都会更新，因此此时就需要重新进行积分操作。这个计算量是非常巨大的。</p></blockquote><h2 id="预积分消减计算量"><a href="#预积分消减计算量" class="headerlink" title="预积分消减计算量"></a>预积分消减计算量</h2><p>为了消减计算量，有人提出了通过如下的简单变换，<strong>将上述积分模型转换成预积分模型</strong>。这个变换是：</p><p>$$<br>\mathbf{q}<em>{w b</em>{t}}&#x3D;\mathbf{q}<em>{w b</em>{i}} \otimes \mathbf{q}<em>{b</em>{i} b_{t}}<br>$$</p><p>转换后，整个PVQ的积分形式变为：</p><p>$$<br>\begin{array}{l}{\mathbf{p}<em>{w b</em>{j}}&#x3D;\mathbf{p}<em>{w b</em>{i}}+\mathbf{v}<em>{i}^{w} \Delta t-\frac{1}{2} \mathbf{g}^{w} \Delta t^{2}+\mathbf{q}</em>{w b_{i}} \iint_{t \in[i, j]}\left(\mathbf{q}<em>{b</em>{i} b_{t}} \mathbf{a}^{b_{t}}\right) \delta t^{2}} \ {\mathbf{v}<em>{j}^{w}&#x3D;\mathbf{v}</em>{i}^{w}-\mathbf{g}^{w} \Delta t+\mathbf{q}<em>{w b</em>{i}} \int_{t \in[i, j]}\left(\mathbf{q}<em>{b</em>{i} b_{t}} \mathbf{a}^{b_{t}}\right) \delta t} \ {\mathbf{q}<em>{w b</em>{j}}&#x3D;\mathbf{q}<em>{w b</em>{i}} \int_{t \in[i, j]} \mathbf{q}<em>{b</em>{i} b_{t}} \otimes\left[\begin{array}{c}{0} \ {\frac{1}{2} \boldsymbol{\omega}^{b_{t}}}\end{array}\right] \delta t}\end{array}<br>$$</p><p>上面公式中，我们可以将其中一部分提取出来，叫做<strong>预积分量</strong>：</p><p>$$<br>\begin{aligned} \boldsymbol{\alpha}<em>{b</em>{i} b_{j}} &amp;&#x3D;\iint_{t \in[i, j]}\left(\mathbf{q}<em>{b</em>{i} b_{t}} \mathbf{a}^{b_{t}}\right) \delta t^{2} \ \boldsymbol{\beta}<em>{b</em>{i} b_{j}} &amp;&#x3D;\int_{t \in[i, j]}\left(\mathbf{q}<em>{b</em>{i} b_{t}} \mathbf{a}^{b_{t}}\right) \delta t \ \mathbf{q}<em>{b</em>{i} b_{j}} &amp;&#x3D;\int_{t \in[i, j]} \mathbf{q}<em>{b</em>{i} b_{t}} \otimes\left[\begin{array}{c}{0} \ {\frac{1}{2} \boldsymbol{\omega}^{b_{t}}}\end{array}\right] \delta t \end{aligned}<br>$$</p><blockquote><p>如上，我们发现，其实预积分就是将原本的积分变成了相邻两帧中相对运动的积分。这使得<strong>预积分量</strong>只与IMU的测量有关，即只要imu测量不变，预积分的结果也不会变化。如果不考虑更新IMU的bias，那么我们只需要进行一次预积分，以后就无需在重新计算了。</p></blockquote><h2 id="基于预积分的状态变换"><a href="#基于预积分的状态变换" class="headerlink" title="基于预积分的状态变换"></a>基于预积分的状态变换</h2><p>此时状态量（世界位姿与bias等）和预积分的映射关系如下：</p><p>$$<br>\left[\begin{array}{c}{\mathbf{p}<em>{w b</em>{j}}} \ {\mathbf{q}<em>{w b</em>{j}}} \ {\mathbf{v}<em>{j}^{w}} \ {\mathbf{b}</em>{j}^{a}} \ {\mathbf{b}<em>{j}^{g}}\end{array}\right]&#x3D;\left[\begin{array}{cc}{\mathbf{p}</em>{w b_{i}}+\mathbf{v}<em>{i}^{w} \Delta t-\frac{1}{2} \mathbf{g}^{w} \Delta t^{2}+\mathbf{q}</em>{w b_{i}} \mathbf{\alpha}<em>{b</em>{i} b_{j}}} \ {\mathbf{q}<em>{w b</em>{i}}  \mathbf{q}<em>{b_i b_j}} \ {\mathbf{v}</em>{i}^{w}-\mathbf{g}^{w} \Delta t+\mathbf{q}<em>{w b</em>{i}} \boldsymbol{\beta}<em>{b</em>{i} b_{j}}} \ {\mathbf{b}<em>{i}^{a}} \ {\mathbf{b}</em>{i}^{g}}\end{array}\right]<br>$$</p><p>此时，如果我们想要建立基于目前状态的预积分误差，则是如下形式（其中表示位姿的四元数我们取其虚部并乘以2恢复出旋转向量）：</p><p>$$<br>\left[\begin{array}{c}{\mathbf{r}<em>{p}} \ {\mathbf{r}</em>{q}} \ {\mathbf{r}<em>{v}} \ {\mathbf{r}</em>{b a}} \ {\mathbf{r}<em>{b g}}\end{array}\right]</em>{15 \times 1}&#x3D;\left[\begin{array}{c}{\mathbf{q}<em>{b</em>{i} w}\left(\mathbf{p}<em>{w b</em>{j}}-\mathbf{p}<em>{w b</em>{i}}-\mathbf{v}<em>{i}^{w} \Delta t+\frac{1}{2} \mathbf{g}^{w} \Delta t^{2}\right)-\boldsymbol{\alpha}</em>{b_{i} b_{j}}} \ {2\left[\mathbf{q}<em>{b</em>{j} b_{i}} \otimes\left(\mathbf{q}<em>{b</em>{i} w} \otimes \mathbf{q}<em>{w b</em>{j}}\right)\right]<em>{x y z}} \ {\mathbf{q}</em>{b_{i} w}\left(\mathbf{v}<em>{j}^{w}-\mathbf{v}</em>{i}^{w}+\mathbf{g}^{w} \Delta t\right)-\beta_{b_{i} b_{j}}} \ {\mathbf{b}<em>{j}^{a}-\mathbf{b}</em>{i}^{a}} \ {\mathbf{b}<em>{j}^{g}-\mathbf{b}</em>{i}^{g}}\end{array}\right]<br>$$</p><p>由于k+1帧段的预积分受其他变量的影响，为了以后方便处理，可以推导出其雅克比矩阵，整体形式如下：</p><p>$$<br>\left[\begin{array}{c}{\delta \boldsymbol{\alpha}<em>{b</em>{k+1} b_{k+1}^{\prime}}} \ {\delta \boldsymbol{\theta}<em>{b</em>{k+1} b_{k+1}^{\prime}}} \ {\delta \boldsymbol{\beta}<em>{b</em>{k+1} b_{k+1}^{\prime}}} \ {\delta \mathbf{b}<em>{k+1}^{a}} \ {\delta \mathbf{b}</em>{k+1}^{g}}\end{array}\right]&#x3D;\mathbf{F}\left[\begin{array}{c}{\delta \boldsymbol{\alpha}<em>{b</em>{k} b_{k}^{\prime}}} \ {\delta \boldsymbol{\theta}<em>{b</em>{k} b_{k}^{\prime}}} \ {\delta \boldsymbol{\beta}<em>{b</em>{k} b_{k}^{\prime}}} \ {\delta \mathbf{b}<em>{k}^{a}} \ {\delta \mathbf{b}</em>{k}^{g}}\end{array}\right]+\mathbf{G}\left[\begin{array}{c}{\mathbf{n}<em>{k}^{a}} \ {\mathbf{n}</em>{k}^{g}} \ {\mathbf{n}<em>{k+1}^{a}} \ {\mathbf{n}</em>{k+1}^{g}} \ {\mathbf{n}<em>{\mathbf{b}</em>{k}^{a}}} \ {\mathbf{n}<em>{\mathbf{b}</em>{k}^{g}}^{g}}\end{array}\right]<br>$$</p><p>其中部分雅克比系数的推导如下：</p><p>$$<br>\mathbf{f}<em>{12}&#x3D;\frac{\partial \boldsymbol{\alpha}</em>{b_{i} b_{k+1}}}{\partial \delta \boldsymbol{\theta}<em>{b</em>{k} b_{k}^{\prime}}}&#x3D;-\frac{1}{4}\left(\mathbf{R}<em>{b</em>{i} b_{k}}\left[\mathbf{a}^{b_{k}}-\mathbf{b}<em>{k}^{a}\right]</em>{ \times} \delta t^{2}+\mathbf{R}<em>{b</em>{i} b_{k+1}}\left[\left(\mathbf{a}^{b_{k+1}}-\mathbf{b}<em>{k}^{a}\right)\right]</em>{ \times}\left(\mathbf{I}-[\boldsymbol{\omega}]_{ \times} \boldsymbol{\delta} t\right) \delta t^{2}\right)<br>$$</p><p>$$<br>\mathbf{f}<em>{32}&#x3D;\frac{\partial \boldsymbol{\beta}</em>{b_{i} b_{k+1}}}{\partial \delta \boldsymbol{\theta}<em>{b</em>{k} b_{k}^{\prime}}}&#x3D;-\frac{1}{2}\left(\mathbf{R}<em>{b</em>{i} b_{k}}\left[\mathbf{a}^{b_{k}}-\mathbf{b}<em>{k}^{a}\right]</em>{ \times} \delta t+\mathbf{R}<em>{b</em>{i} b_{k+1}}\left[\left(\mathbf{a}^{b_{k+1}}-\mathbf{b}<em>{k}^{a}\right)\right]</em>{ \times}\left(\mathbf{I}-[\boldsymbol{\omega}]_{ \times} \delta t\right) \delta t\right)<br>$$</p><p>$$<br>\mathbf{f}<em>{15}&#x3D;\frac{\partial \boldsymbol{\alpha}</em>{b_{i} b_{k+1}}}{\partial \delta \mathbf{b}<em>{k}^{g}}&#x3D;-\frac{1}{4}\left(\mathbf{R}</em>{b_{i} b_{k+1}}\left[\left(\mathbf{a}^{b_{k+1}}-\mathbf{b}_{k}^{a}\right)\right] \times \delta t^{2}\right)(-\delta t)<br>$$</p><p>$$<br>\mathbf{f}<em>{35}&#x3D;\frac{\partial \boldsymbol{\beta}</em>{b_{i} b_{k+1}}}{\partial \delta \mathbf{b}<em>{k}^{g}}&#x3D;-\frac{1}{2}\left(\mathbf{R}</em>{b_{i} b_{k+1}}\left[\left(\mathbf{a}^{b_{k+1}}-\mathbf{b}_{k}^{a}\right)\right] \times \delta t\right)(-\delta t)<br>$$</p><p>$$<br>\mathbf{g}<em>{12}&#x3D;\frac{\partial \boldsymbol{\alpha}</em>{b_{i} b_{k+1}}}{\partial \mathbf{n}<em>{k}^{g}}&#x3D;\mathbf{g}</em>{14}&#x3D;\frac{\partial \boldsymbol{\alpha}<em>{b</em>{i} b_{k+1}}}{\partial \mathbf{n}<em>{k+1}^{g}}&#x3D;-\frac{1}{4}\left(\mathbf{R}</em>{b_{i} b_{k+1}}\left[\left(\mathbf{a}^{b_{k+1}}-\mathbf{b}_{k}^{a}\right)\right] \times \delta t^{2}\right)\left(\frac{1}{2} \delta t\right)<br>$$</p><p>$$<br>\mathbf{g}<em>{32}&#x3D;\frac{\partial \boldsymbol{\beta}</em>{b_{i} b_{k+1}}}{\partial \mathbf{n}<em>{k}^{g}}&#x3D;\mathbf{g}</em>{34}&#x3D;\frac{\partial \boldsymbol{\beta}<em>{b</em>{i} b_{k+1}}}{\partial \mathbf{n}<em>{k+1}^{g}}&#x3D;-\frac{1}{2}\left(\mathbf{R}</em>{b_{i} b_{k+1}}\left[\left(\mathbf{a}^{b_{k+1}}-\mathbf{b}_{k}^{a}\right)\right] \times \delta t\right)\left(\frac{1}{2} \delta t\right)<br>$$</p><h2 id="基于中值积分的预积分"><a href="#基于中值积分的预积分" class="headerlink" title="基于中值积分的预积分"></a>基于中值积分的预积分</h2><p>首先，对于姿态变化的中值积分首先进行</p><p>$$<br>\begin{aligned} \boldsymbol{\omega} &amp;&#x3D;\frac{1}{2}\left(\left(\boldsymbol{\omega}^{b_{k}}+\mathbf{n}<em>{k}^{g}-\mathbf{b}</em>{k}^{g}\right)+\left(\boldsymbol{\omega}^{b_{k+1}}+\mathbf{n}<em>{k+1}^{g}-\mathbf{b}</em>{k}^{g}\right)\right) \ \mathbf{q}<em>{b</em>{i} b_{k+1}} &amp;&#x3D;\mathbf{q}<em>{b</em>{i} b_{k}} \otimes\left[\begin{array}{c}{1} \ {\frac{1}{2} \boldsymbol{\omega} \delta t}\end{array}\right] \end{aligned}<br>$$</p><p>然后，会完成位置变化的中值积分</p><p>$$<br>\begin{aligned} \mathbf{a} &amp;&#x3D;\frac{1}{2}\left(\mathbf{q}<em>{b</em>{i} b_{k}}\left(\mathbf{a}^{b_{k}}+\mathbf{n}<em>{k}^{a}-\mathbf{b}</em>{k}^{a}\right)+\mathbf{q}<em>{b</em>{i} b_{k+1}}\left(\mathbf{a}^{b_{k+1}}+\mathbf{n}<em>{k+1}^{a}-\mathbf{b}</em>{k}^{a}\right)\right) \ \boldsymbol{\alpha}<em>{b</em>{i} b_{k+1}} &amp;&#x3D;\boldsymbol{\alpha}<em>{b</em>{i} b_{k}}+\boldsymbol{\beta}<em>{b</em>{i} b_{k}} \delta t+\frac{1}{2} \mathbf{a} \delta t^{2} \ \boldsymbol{\beta}<em>{b</em>{i} b_{k+1}} &amp;&#x3D;\boldsymbol{\beta}<em>{b</em>{i} b_{k}}+\mathbf{a} \delta t \end{aligned}<br>$$</p><p>最后是bias的更新：</p><p>$$<br>\begin{aligned} \mathbf{b}<em>{k+1}^{a} &amp;&#x3D;\mathbf{b}</em>{k}^{a} \ \mathbf{b}<em>{k+1}^{g} &amp;&#x3D;\mathbf{b}</em>{k}^{g} \end{aligned}<br>$$</p><h2 id="在vins中，这部分的代码如下（vins-estimator模块中factor文件夹下的头文件integration-base-h中的midPointIntegration函数）："><a href="#在vins中，这部分的代码如下（vins-estimator模块中factor文件夹下的头文件integration-base-h中的midPointIntegration函数）：" class="headerlink" title="在vins中，这部分的代码如下（vins_estimator模块中factor文件夹下的头文件integration_base.h中的midPointIntegration函数）："></a>在vins中，这部分的代码如下（<code>vins_estimator</code>模块中<code>factor</code>文件夹下的头文件<code>integration_base.h</code>中的<code>midPointIntegration</code>函数）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//此处预积分也就是在相邻两帧之间的相对积分，得到的是相对的位姿变换</span><br><br><span class="hljs-comment">//ROS_INFO(&quot;midpoint integration&quot;); 加速度中值测量前一个测量</span><br>Vector3d un_acc_0 = delta_q * (_acc_0 - linearized_ba);<br><span class="hljs-comment">//陀螺仪中值测量</span><br>Vector3d un_gyr = <span class="hljs-number">0.5</span> * (_gyr_0 + _gyr_1) - linearized_bg;<br><span class="hljs-comment">//旋转预积分</span><br>result_delta_q = delta_q * <span class="hljs-built_in">Quaterniond</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">un_gyr</span>(<span class="hljs-number">0</span>) * _dt / <span class="hljs-number">2</span>, <span class="hljs-built_in">un_gyr</span>(<span class="hljs-number">1</span>) * _dt / <span class="hljs-number">2</span>, <span class="hljs-built_in">un_gyr</span>(<span class="hljs-number">2</span>) * _dt / <span class="hljs-number">2</span>);<br><span class="hljs-comment">//加速度中值测量的后一个测量</span><br>Vector3d un_acc_1 = result_delta_q * (_acc_1 - linearized_ba);<br><span class="hljs-comment">//加速度计中值测量</span><br>Vector3d un_acc = <span class="hljs-number">0.5</span> * (un_acc_0 + un_acc_1);<br><span class="hljs-comment">//位置预积分</span><br>result_delta_p = delta_p + delta_v * _dt + <span class="hljs-number">0.5</span> * un_acc * _dt * _dt;<br><span class="hljs-comment">//速度预积分</span><br>result_delta_v = delta_v + un_acc * _dt;<br><span class="hljs-comment">//bias默认不变（预积分时）</span><br>result_linearized_ba = linearized_ba;<br>result_linearized_bg = linearized_bg;         <br></code></pre></td></tr></table></figure></h2><h1 id="预积分更新问题"><a href="#预积分更新问题" class="headerlink" title="预积分更新问题"></a>预积分更新问题</h1><p>我们知道，在vins的非线性优化中不止进行了相机姿态还有路标的优化，也将imu的bias加入了优化的变量中。这样在一次优化更新后，其实bias是会发生改变的，这样预积分量也就需要更新，那么积分就还需要重新计算？</p><p>其实在vins中为了解决这个问题，是这样做的(当更新前后bias变化比较小时)：</p><p>$$<br>\begin{aligned} \boldsymbol{\alpha}<em>{b</em>{k+1}}^{b_{k}} &amp; \approx \hat{\boldsymbol{\alpha}}<em>{b</em>{k+1}}^{b_{k}}+\mathbf{J}<em>{b</em>{a}}^{\alpha} \delta \mathbf{b}<em>{a</em>{k}}+\mathbf{J}<em>{b</em>{w}}^{\alpha} \delta \mathbf{b}<em>{w</em>{k}} \ \boldsymbol{\beta}<em>{b</em>{k+1}}^{b_{k}} &amp; \approx \hat{\boldsymbol{\beta}}<em>{b</em>{k+1}}^{b_{k}}+\mathbf{J}<em>{b</em>{a}}^{\beta} \delta \mathbf{b}<em>{a</em>{k}}+\mathbf{J}<em>{b</em>{w}}^{\beta} \delta \mathbf{b}<em>{w</em>{k}} \ \boldsymbol{\gamma}<em>{b</em>{k+1}}^{b_{k}} &amp; \approx \hat{\boldsymbol{\gamma}}<em>{b</em>{k+1}}^{b_{k}} \otimes\left[\begin{array}{c}{1} \ {\frac{1}{2} \mathbf{J}<em>{b</em>{w}}^{\gamma} \delta \mathbf{b}<em>{w</em>{k}}}\end{array}\right] \end{aligned}<br>$$</p><blockquote><p>当一次非线性优化后，<strong>如果bias的变化比较小</strong>，会使用一阶展开来近似更新<strong>从k帧到k+1帧</strong>的预积分量。<strong>当bias变化比较大时</strong>，近似效果会不好，此时需要重新进行积分。（此处假设使用欧拉积分）这样做可以很大的消减基于优化的方法的计算量。</p></blockquote><h1 id="vins中预积分的实现"><a href="#vins中预积分的实现" class="headerlink" title="vins中预积分的实现"></a>vins中预积分的实现</h1><p>vins中的预积分功能，主要是在<code>vins_estimator</code>模块中<code>factor</code>文件夹下的头文件<code>integration_base.h</code>中实现。</p><p>在vins程序代码中，对于每两帧图像之间都会使用一个<code>integrationBase</code>对象维护此两帧之间的预积分。其中主要有以下几个值得注意的地方：</p><ol><li><p>代码中对于图像与imu数据的时间戳对齐问题使用线性插值的方法进行处理（线性插值获得图像帧时间戳时的imu测量）；</p></li><li><p>预积分使用中值积分进行；</p></li><li><p>在预积分是可以叠加的，每次读入新的imu测量数据，就会进行一个中值预积分操作；</p></li><li><p>每次中值预积分完成后，会更新其雅克比矩阵与方差矩阵（此处的雅克比矩阵在imu的bias变化后，可以直接拿来更新预积分，不用重新积分）</p></li></ol><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1] 深蓝学院vio课程讲义</li><li>[2] Leutenegger S, Furgale P, Rabaud V, et al. Keyframe-based visual-inertial slam using nonlinear optimization[J]. Proceedings of Robotis Science and Systems (RSS) 2013, 2013.</li><li>[3] Qin T, Li P, Shen S. Vins-mono: A robust and versatile monocular visual-inertial state estimator[J]. IEEE Transactions on Robotics, 2018, 34(4): 1004-1020.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>多传感器融合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>slam中的滑动窗口法</title>
    <link href="/2019/07/28/2019-07-28-sliding-window/"/>
    <url>/2019/07/28/2019-07-28-sliding-window/</url>
    
    <content type="html"><![CDATA[<p>随着VSLAM系统不断往新环境探索，就会有新的相机姿态以及看到新的环境特征，最小二乘残差就会越来越多，信息矩阵越来越大，计算量也会越来越大。</p><p>为了<strong>保持优化变量的个数在一定范围内</strong>，需要使用滑动窗口算法动态增加或移除优化变量。</p><h1 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li><p>增加新的变量进入最小二乘系统优化</p></li><li><p>如果变量数目达到了一定的维度，则移除老的变量</p></li><li><p>系统不断循环前面两步</p></li></ol><h2 id="信息矩阵"><a href="#信息矩阵" class="headerlink" title="信息矩阵"></a>信息矩阵</h2><p>一般对于最小二乘问题，对应的高斯牛顿求解为：</p><p>$$<br>\underbrace{\mathbf{J}^{\top} \boldsymbol{\Sigma}^{-1} \mathbf{J}}<em>{\mathbf{H} \text { or } \Lambda} \delta \boldsymbol{\xi}=\underbrace{-\mathbf{J}^{\top} \boldsymbol{\Sigma}^{-1} \mathbf{r}}</em>{\mathbf{b}}<br>$$</p><p>其中$\Sigma$对应的是测量的协方差矩阵（它的逆是测量的信息矩阵），而$H$是优化变量的信息矩阵。</p><blockquote><p>为啥会多出$\Sigma$呢？待续</p></blockquote><h2 id="利用边际概率移除老的变量-Marginalization"><a href="#利用边际概率移除老的变量-Marginalization" class="headerlink" title="利用边际概率移除老的变量(Marginalization)"></a>利用边际概率移除老的变量(Marginalization)</h2><blockquote><p>直接丢弃变量和对应的测量值，会损失信息。正确的做法是使用边际概率，将丢弃变量所携带的信息传递给剩余变量。</p></blockquote><p>下面，本文使用一个例子A来演示一下，下面这个例子中，我们使用边界概率移除变量$\xi_{1}$。信息矩阵的变化过程如下：</p><p><img src="/img/math/sample3_all.PNG" alt="window"></p><p>接下来，再通过一个例子B，这个例子中，我们先加入一个$x_{t+1}$变量，然后再移除$x_{t}$变量，整个变化过程如下：</p><p><img src="/img/math/sample4_all.PNG" alt="window"></p><blockquote><p>我们可以发现，marginalization会使得信息矩阵变稠密，原先条件独立的变量，可能变得相关。这个原因是因为信息矩阵中会包含间接相关性。</p></blockquote><h2 id="移除旧变量，添加新变量"><a href="#移除旧变量，添加新变量" class="headerlink" title="移除旧变量，添加新变量"></a>移除旧变量，添加新变量</h2><p>这里还是使用这个例子，完整过程如下：</p><p><img src="/img/math/example3_4.PNG" alt="window"></p><p>此例中，其实对于这么一个高斯牛顿问题：</p><p>$$<br>\underbrace{\mathbf{J}^{\top} \boldsymbol{\Sigma}^{-1} \mathbf{J}}<em>{\mathbf{H} \text { or } \Lambda} \delta \boldsymbol{\xi}=\underbrace{-\mathbf{J}^{\top} \boldsymbol{\Sigma}^{-1} \mathbf{r}}</em>{\mathbf{b}}<br>$$</p><p>在marg之前，被marg的变量$x_m$以及对应的测量$\mathcal{S}_{m}$，它们构建的那部分最小二乘信息矩阵为：</p><p>$$<br>\begin{aligned} \mathbf{b}<em>{m}(k) &amp;=\left[\begin{array}{c}{\mathbf{b}</em>{m m}(k)} \\ {\mathbf{b}<em>{m r}(k)}\end{array}\right]=-\sum</em>{(i, j) \in \mathcal{S}<em>{m}} \mathbf{J}</em>{i j}^{\top}(k) \mathbf{\Sigma}<em>{i j}^{-1} \mathbf{r}</em>{i j} \\ \boldsymbol{\Lambda}<em>{m}(k) &amp;=\left[\begin{array}{cc}{\boldsymbol{\Lambda}</em>{m r}(k)} &amp; {\boldsymbol{\Lambda}<em>{m r}(k)} \\ {\boldsymbol{\Lambda}</em>{r m}(k)} &amp; {\boldsymbol{\Lambda}<em>{r r}(k)}\end{array}\right]=\sum</em>{(i, j) \in \mathcal{S}<em>{m}} \mathbf{J}</em>{i j}^{\top}(k) \boldsymbol{\Sigma}<em>{i j}^{-1} \mathbf{J}</em>{i j}(k) \end{aligned}<br>$$</p><p>marg之后，变量$x_{m}$的测量信息是这样传递给剩下的变量$x_{r}$的：</p><p>$$<br>\begin{array}{l}{\mathbf{b}<em>{p}(k)=\mathbf{b}</em>{m r}(k)-\boldsymbol{\Lambda}<em>{r m}(k) \boldsymbol{\Lambda}</em>{m m}^{-1}(k) \mathbf{b}<em>{m m}(k)} \\ {\boldsymbol{\Lambda}</em>{p}(k)=\boldsymbol{\Lambda}<em>{r r}(k)-\boldsymbol{\Lambda}</em>{r m}(k) \boldsymbol{\Lambda}<em>{m m}^{-1}(k) \boldsymbol{\Lambda}</em>{m r}(k)}\end{array}<br>$$</p><p>其中下标$p$表示prior，即这些信息将构建一个关于$x_{r}$的先验信息。</p><p>在$k^{\prime}$时刻，新残差$r_{27}$和先验信息$b_{p}(k)，\Lambda_{p}(k)$以及残差$r_{56}$构建新的最小二乘问题：</p><p>$$<br>\begin{array}{c}{\mathbf{b}\left(k^{\prime}\right)=\mathbf{\Pi}^{\top} \mathbf{b}<em>{p}(k)-\sum</em>{(i, j) \in \mathcal{S}<em>{a}\left(k^{\prime}\right)} \mathbf{J}</em>{i j}^{\top}\left(k^{\prime}\right) \mathbf{\Sigma}<em>{i j}^{-1} \mathbf{r}</em>{i j}\left(k^{\prime}\right)} \\ {\mathbf{\Lambda}\left(k^{\prime}\right)=\mathbf{\Pi}^{\top} \mathbf{\Lambda}<em>{p}(k) \mathbf{\Pi}+\sum</em>{(i, j) \in \mathcal{S}<em>{a}\left(k^{\prime}\right)} \mathbf{J}</em>{i j}^{\top}\left(k^{\prime}\right) \mathbf{\Sigma}<em>{i j}^{-1} \mathbf{J}</em>{i j}\left(k^{\prime}\right)}\end{array}<br>$$</p><p>$$\mathbf{\Pi}=\left[\begin{array}{ll}{\mathbf{I}<em>{\operatorname{dim} \mathbf{x}</em>{r}}} &amp; {\mathbf{0}}\end{array}\right]$$</p><p>其中$\mathbf{\Pi}$用来将矩阵的维度进行扩张。$S_{a}$用来表示除被marg掉的测量以外的其他测量，如$r_{56}，r_{27}$。</p><blockquote><p>此处和被marg掉的变量相关的边（测量）也被丢弃了，所以先验信息中它们关于剩下的变量$x_{r}$的雅克比在后续求解中不能更新。而保留下来的边关于剩下的变量$x_{r}$的雅克比在后续求解中是不断更新的（在最新的线性化点处计算）</p></blockquote><h2 id="First-Estimate-Jacobians"><a href="#First-Estimate-Jacobians" class="headerlink" title="First Estimate Jacobians"></a>First Estimate Jacobians</h2><p>就在上面这个例子中</p><p><img src="/img/math/example3_1.PNG" alt="window"></p><p>它在添加新的节点中信息矩阵的更新过程如下：</p><p><img src="/img/math/example3_2.PNG" alt="window"></p><p>此时，我们会发现$\xi_{2}$自身的信息矩阵部分是由两部分组成的，此时如果这两部分的计算时使用的$\xi_{2}$（线性化点）的状态不一样，就可能会导致信息矩阵的零空间发生变化，引入错误信息。</p><p>之所以线性化点会不一样，是因为在marg掉$\xi_{1}$时，新得到的蓝色的小一维雅克比矩阵是直接通过舒尔补计算得到的，所以此时当时计算这个雅克比的$\xi_{2}$点的状态是迭代更新前的，此时新加入的粉红部分的雅克比要想保持与其一致，其在对$\xi_{2}$进行偏导计算时，也需要使用迭代更新前的状态才行。</p><blockquote><p>此时FEJ的做法是：不同残差对同一个状态求雅克比时，线性化点必须一致。这样就能避免零空间退化而使得不客观变量变得可观。</p></blockquote><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1] 深蓝学院vio课程讲义</li><li>[2] Walter M R, Eustice R M, Leonard J J. Exactly Sparse Extended Information Filters for Feature-based SLAM[J]. Int.j.robotics Res, 2007, 26(4):335-359.</li><li>[3] Dong-Si T C , Mourikis A I . Consistency analysis for sliding-window visual odometry[J]. Proceedings - IEEE International Conference on Robotics and Automation, 2012:5202-5209.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>舒尔补与marginalization</title>
    <link href="/2019/07/27/2019-07-27-schur-complement-marginalization/"/>
    <url>/2019/07/27/2019-07-27-schur-complement-marginalization/</url>
    
    <content type="html"><![CDATA[<p>在slam中经常会使用滑动窗口法来控制非线性优化的计算量级，此时当从现有的窗口中去除旧的变量时，如何调整<a href="https://xhy3054.github.io/covariance-information-matrix/">信息矩阵</a>就成为了一个棘手的问题。这篇博客就是要介绍如何使用舒尔补来简单的完成这个任务。</p><h1 id="舒尔补"><a href="#舒尔补" class="headerlink" title="舒尔补"></a>舒尔补</h1><p>给定任意的矩阵块M，如下所示：</p><p>$$<br>\mathbf{M}=\left[\begin{array}{ll}{\mathbf{A}} &amp; {\mathbf{B}} \\ {\mathbf{C}} &amp; {\mathbf{D}}\end{array}\right]<br>$$</p><ul><li>如果，矩阵块D是可逆的，则$\mathbf{A}-\mathbf{B D}^{-1} \mathbf{C}$称之为D关于M的舒尔补。</li><li>如果，矩阵块A是可逆的，则$\mathbf{D}-\mathbf{C A}^{-1} \mathbf{B}$称之为A关于M的舒尔补。</li></ul><h2 id="舒尔补的来由"><a href="#舒尔补的来由" class="headerlink" title="舒尔补的来由"></a>舒尔补的来由</h2><p>当我们想要将矩阵M变成上三角或者下三角过程中，都会遇到舒尔补，如下：</p><p>$$<br>\left[\begin{array}{cc}{\mathbf{I}} &amp; {\mathbf{0}} \\ {-\mathbf{C A}^{-1}} &amp; {\mathbf{I}}\end{array}\right]\left[\begin{array}{ll}{\mathbf{A}} &amp; {\mathbf{B}} \\ {\mathbf{C}} &amp; {\mathbf{D}}\end{array}\right]=\left[\begin{array}{cc}{\mathbf{A}} &amp; {\mathbf{B}} \\ {\mathbf{0}} &amp; {\Delta_{\mathbf{A}}}\end{array}\right]<br>$$</p><p>$$<br>\left[\begin{array}{cc}{\mathbf{A}} &amp; {\mathbf{B}} \\ {\mathbf{C}} &amp; {\mathbf{D}}\end{array}\right]\left[\begin{array}{cc}{\mathbf{I}} &amp; {-\mathbf{A}^{-1} \mathbf{B}} \\ {\mathbf{0}} &amp; {\mathbf{I}}\end{array}\right]=\left[\begin{array}{cc}{\mathbf{A}} &amp; {0} \\ {\mathbf{C}} &amp; {\Delta_{\mathbf{A}}}\end{array}\right]<br>$$</p><p>其中，不论是上三角还是下三角，都是$\Delta_{\mathrm{A}}=\mathbf{D}-\mathbf{C A}^{-1} \mathbf{B}$。联合起来，可以<strong>将M便形成对角形</strong>：</p><p>$$<br>\left[\begin{array}{cc}{\mathbf{I}} &amp; {\mathbf{0}} \\ {-\mathbf{C A}^{-1}} &amp; {\mathbf{I}}\end{array}\right]\left[\begin{array}{ll}{\mathbf{A}} &amp; {\mathbf{B}} \\ {\mathbf{C}} &amp; {\mathbf{D}}\end{array}\right]\left[\begin{array}{rr}{\mathbf{I}} &amp; {-\mathbf{A}^{-1} \mathbf{B}} \\ {\mathbf{0}} &amp; {\mathbf{I}}\end{array}\right]=\left[\begin{array}{cc}{\mathbf{A}} &amp; {\mathbf{0}} \\ {\mathbf{0}} &amp; {\Delta_{\mathbf{A}}}\end{array}\right]<br>$$</p><p>反过来，我们又能<strong>从对角形恢复成矩阵M</strong>:</p><p>$$<br>\left[\begin{array}{cc}{\mathbf{I}} &amp; {\mathbf{0}} \\ {\mathbf{C A}^{-1}} &amp; {\mathbf{I}}\end{array}\right]\left[\begin{array}{cc}{\mathbf{A}} &amp; {\mathbf{0}} \\ {\mathbf{0}} &amp; {\Delta_{\mathbf{A}}}\end{array}\right]\left[\begin{array}{cc}{\mathbf{I}} &amp; {\mathbf{A}^{-1} \mathbf{B}} \\ {\mathbf{0}} &amp; {\mathbf{I}}\end{array}\right]=\left[\begin{array}{cc}{\mathbf{A}} &amp; {\mathbf{B}} \\ {\mathbf{C}} &amp; {\mathbf{D}}\end{array}\right]<br>$$</p><p>此处注意有这么个性质：</p><p>$$<br>\left[\begin{array}{cc}{\mathbf{I}} &amp; {-\mathbf{A}^{-1} \mathbf{B}} \\ {\mathbf{0}} &amp; {\mathbf{I}}\end{array}\right]\left[\begin{array}{cc}{\mathbf{I}} &amp; {\mathbf{A}^{-1} \mathbf{B}} \\ {\mathbf{0}} &amp; {\mathbf{I}}\end{array}\right]=\mathbf{I}<br>$$</p><p>所以还可以这样<strong>计算M的的逆</strong>：</p><p>$$<br>\left[\begin{array}{cc}{\mathbf{A}} &amp; {\mathbf{B}} \\ {\mathbf{C}} &amp; {\mathbf{D}}\end{array}\right]^{-1}=\left[\begin{array}{cc}{\mathbf{I}} &amp; {-\mathbf{A}^{-1} \mathbf{B}} \\ {\mathbf{0}} &amp; {\mathbf{I}}\end{array}\right]\left[\begin{array}{cc}{\mathbf{A}^{-1}} &amp; {\mathbf{0}} \\ {\mathbf{0}} &amp; {\Delta_{\mathbf{A}}^{-1}}\end{array}\right]\left[\begin{array}{cc}{\mathbf{I}} &amp; {\mathbf{0}} \\ {-\mathbf{C A}^{-1}} &amp; {\mathbf{I}}\end{array}\right]<br>$$</p><h1 id="将舒尔补应用于多元高斯分布"><a href="#将舒尔补应用于多元高斯分布" class="headerlink" title="将舒尔补应用于多元高斯分布"></a>将舒尔补应用于多元高斯分布</h1><p>假设多元变量$x$服从高斯分布，且由两部分组成：$\mathbf{x}=\left[\begin{array}{l}{a} \\ {b}\end{array}\right]$，变量之间构成的协方差矩阵为：</p><p>$$<br>\mathbf{K}=\left[\begin{array}{cc}{A} &amp; {C^{\top}} \\ {C} &amp; {D}\end{array}\right]<br>$$</p><p>其中$A=\operatorname{cov}(a, a), D=\operatorname{cov}(b, b), C=\operatorname{cov}(a, b)$。由此变量$x$的概率分布为：</p><p>$$<br>P(a, b)=P(a) P(b | a) \propto \exp \left(-\frac{1}{2}\left[\begin{array}{l}{a} \\ {b}\end{array}\right]^{\top}\left[\begin{array}{cc}{A} &amp; {C^{\top}} \\ {C} &amp; {D}\end{array}\right]^{-1}\left[\begin{array}{l}{a} \\ {b}\end{array}\right]\right)<br>$$ </p><p>利用上面介绍的舒尔补的性质，我们可以对高斯分布进行分解，得到如下：</p><p>$$<br>\begin{array}{l}{P(a, b)} \\ {\propto \exp \left(-\frac{1}{2}\left[\begin{array}{l}{a} \\ {b}\end{array}\right]^{\top}\left[\begin{array}{cc}{A} &amp; {C^{\top}} \\ {C} &amp; {D}\end{array}\right]^{-1}\left[\begin{array}{l}{a} \\ {b}\end{array}\right]\right)} \\ {\propto \exp \left(-\frac{1}{2}\left[\begin{array}{c}{a} \\ {b}\end{array}\right]^{\top}\left[\begin{array}{cc}{I} &amp; {-A^{-1} C^{\top}} \\ {0} &amp; {I}\end{array}\right]\left[\begin{array}{cc}{A^{-1}} &amp; {0} \\ {0} &amp; {\Delta_{\mathrm{A}}^{-1}}\end{array}\right]\left[\begin{array}{cc}{I} &amp; {0} \\ {-C A^{-1}} &amp; {I}\end{array}\right]\left[\begin{array}{c}{a} \\ {b}\end{array}\right]\right)} \\ {\propto \exp \left(-\frac{1}{2}\left[a^{\top} \quad\left(b-C A^{-1} a\right)^{\top}\right]\left[\begin{array}{cc}{A^{-1}} &amp; {0} \\ {0} &amp; {\Delta_{\mathrm{A}}^{-1}}\end{array}\right]\left[\begin{array}{c}{a} \\ {b-C A^{-1} a}\end{array}\right]\right)} \\ {\propto \exp \left(-\frac{1}{2}\left(a^{\top} A^{-1} a\right)+\left(b-C A^{-1} a\right)^{\top} \Delta_{\mathrm{A}}^{-1}\left(b-C A^{-1} a\right)\right)} \\ {\propto \underbrace{\exp \left(-\frac{1}{2} a^{\top} A^{-1} a\right)}<em>{p(a)} \underbrace{\exp \left(-\frac{1}{2}\left(b-C A^{-1} a\right)^{\top} \Delta</em>{\mathrm{A}}^{-1}\left(b-C A^{-1} a\right)\right)}_{p(b | a)}} \end{array}<br>$$</p><p>这意味着我们能从多元高斯分布$P(a,b)$中分解得到<strong>边界概率</strong>$p(a)$和<strong>条件概率</strong>p(b|a)</p><h2 id="原先分布的协方差矩阵与信息矩阵"><a href="#原先分布的协方差矩阵与信息矩阵" class="headerlink" title="原先分布的协方差矩阵与信息矩阵"></a>原先分布的协方差矩阵与信息矩阵</h2><p>我们已知的协方差矩阵的逆就是信息矩阵，它们是如下的关系：</p><p>$$<br>\left[\begin{array}{cc}{A} &amp; {C^{\top}} \\ {C} &amp; {D}\end{array}\right]^{-1}=\left[\begin{array}{cc}{A^{-1}+A^{-1} C^{\top} \Delta_{\mathrm{A}}^{-1} C A^{-1}} &amp; {-A^{-1} C^{\top} \Delta_{\mathrm{A}}^{-1}} \\ {-\Delta_{\mathrm{A}}^{-1} C A^{-1}} &amp; {\Delta_{\mathrm{A}}^{-1}}\end{array}\right] \triangleq\left[\begin{array}{cc}{\Lambda_{a a}} &amp; {\Lambda_{a b}} \\ {\Lambda_{b a}} &amp; {\Lambda_{b b}}\end{array}\right]<br>$$</p><h2 id="分离出来的边界概率分布"><a href="#分离出来的边界概率分布" class="headerlink" title="分离出来的边界概率分布"></a>分离出来的边界概率分布</h2><blockquote><p>分离出来的边界概率分布就是$p(a)$，它<strong>是在滑动窗口法中使用的方法</strong>，它是marg掉b之后剩下的分布。</p></blockquote><p>分离出来的边界概率分布的协方差矩阵就是从联合分布K中取对应的矩阵块A就行了。</p><p>$$<br>\begin{array}{l}{P(a)=\int_{b} P(a, b)} \\ {P(a) \propto \exp \left(-\frac{1}{2} a^{\top} A^{-1} a\right) \sim \mathcal{N}(0, A)}\end{array}<br>$$</p><p>分离出来的边界概率分布的信息矩阵是：</p><p>$$<br>A^{-1}=\Lambda_{a a}-\Lambda_{a b} \Lambda_{b b}^{-1} \Lambda_{b a}<br>$$</p><blockquote><p>此处我们会发现，分离出来的边界分布变量之间的协方差是不变的，但是信息矩阵改变了。这是因为信息矩阵中的相关计算是遵循链式法则，在分离出来的变量固定住以后，原本不想关的变量可以变成相关的。</p></blockquote><h2 id="分离出来的条件概率分布"><a href="#分离出来的条件概率分布" class="headerlink" title="分离出来的条件概率分布"></a>分离出来的条件概率分布</h2><p>分离出来a后的条件概率分布的协方差矩阵变为a对应的舒尔补，均值也变了。</p><p>$$<br>P(b | a) \propto \exp \left(-\frac{1}{2}\left(b-C A^{-1} a\right)^{\top} \Delta_{\mathrm{A}}^{-1}\left(b-C A^{-1} a\right)\right)<br>$$</p><p>分离出来的条件概率分布的信息矩阵是：</p><p>$$<br>\Delta_{A}^{-1}=\Lambda_{b b}<br>$$</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>其实我们在marg掉变量的时候，我们需要搞清楚自己想要获得的是边界概率还是条件概率。在滑动窗口中是保留边界概率。从联合分布得到边际概率</p></blockquote><p>从上面的分析我们可以发现，<strong>边界概率对于协方差矩阵的操作是很容易的，但是不好操作信息矩阵。条件概率分布相反，对于信息矩阵容易操作，但是不好操作协方差矩阵。</strong></p><p>对于原分布：</p><p>$$<br>P(\boldsymbol{a}, \boldsymbol{b})=\mathcal{N}\left(\left[\begin{array}{c}{\boldsymbol{\mu}<em>{a}} \\ {\boldsymbol{\mu}</em>{b}}\end{array}\right],\left[\begin{array}{cc}{\boldsymbol{\Sigma}<em>{a a}} &amp; {\boldsymbol{\Sigma}</em>{a b}} \\ {\boldsymbol{\Sigma}<em>{b a}} &amp; {\boldsymbol{\Sigma}</em>{b b}}\end{array}\right]\right)=\mathcal{N}^{-1}\left(\left[\begin{array}{c}{\boldsymbol{\eta}<em>{a}} \\ {\boldsymbol{\eta}</em>{b}}\end{array}\right],\left[\begin{array}{cc}{\boldsymbol{\Lambda}<em>{a a}} &amp; {\mathbf{\Lambda}</em>{a a}} \\ {\boldsymbol{\Lambda}<em>{b a}} &amp; {\boldsymbol{\Lambda}</em>{b b}}\end{array}\right]\right)<br>$$</p><p>两种marg变量的方式后剩下的可以用表格总结如下：</p><p><img src="/img/math/marg.PNG" alt="marg"></p><blockquote><p>schur补的操作在slam中十分常见，其实在前面<a href="https://xhy3054.github.io/bundle-adjustment-solve/">BA的博客</a>已经提到过一次了，这次系统的、概念性的介绍一下。它的主要作用是消元简化计算。在ba的介绍中中侧重加速解方程，此处介绍侧重加速求解边界概率。</p></blockquote><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1] 深蓝学院vio课程讲义</li><li>[2] <a href="https://gbhqed.wordpress.com/2010/02/21/conditional-and-marginal-distributions-of-a-multivariate-gaussian">Huang. Conditional and marginal distributions of a multivariate Gaussian</a>.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多元高斯分布的协方差矩阵与信息矩阵</title>
    <link href="/2019/07/25/2019-07-25-covariance-information-matrix/"/>
    <url>/2019/07/25/2019-07-25-covariance-information-matrix/</url>
    
    <content type="html"><![CDATA[<p><strong>零均值</strong>的多元高斯分布有如下概率形式：</p><p>$$<br>p(\mathbf{x}) - \frac{1}{Z} \exp \left(-\frac{1}{2} \mathbf{x}^{\top} \mathbf{\Sigma}^{-1} \mathbf{x}\right)<br>$$</p><p>其中$\mathbf{\Sigma}$是<strong>协方差矩阵</strong>，协方差矩阵的逆可以记作$\mathbf{\Lambda}=\mathbf{\Sigma}^{-1}$，也叫<strong>信息矩阵</strong>。当变量$\mathbf{x}$是三维变量时，协方差矩阵为：</p><p>$$<br>\boldsymbol{\Sigma} = \left[\begin{array}{ccc}{\Sigma_{11}} &amp; {\Sigma_{12}} &amp; {\Sigma_{13}} \\ {\Sigma_{21}} &amp; {\Sigma_{22}} &amp; {\Sigma_{23}} \\ {\Sigma_{31}} &amp; {\Sigma_{32}} &amp; {\Sigma_{33}} \end{array}\right]<br>$$</p><p>其中$\Sigma_{i j} = E\left(x_{i} x_{j}\right)$</p><blockquote><p>其实在应用中，往往我们直接操作的是信息矩阵，而不是协方差矩阵。下面从一个例子来体会一下协方差矩阵与信息矩阵。</p></blockquote><h1 id="example"><a href="#example" class="headerlink" title="example"></a>example</h1><p>假设$x_{2}$为室外的温度，$x_{1},x_{3}$分别是房间1与房间3的室内温度：</p><p>$$<br>\begin{aligned} x_{2} &amp;= v_{2} \\ x_{1} &amp;= w_{1} x_{2} + v_{1} \\ x_{3} &amp;= w_{3} x_{2}+v_{3} \end{aligned}<br>$$ </p><p>其中，$v_{i}$为相互独立，且各自服从协方差为$\sigma_{i}^{2}$的高斯分布。根据上面它们之间的联系，我们可以求出$x$的协方差矩阵，首先：</p><p>$$<br>\begin{aligned} \Sigma_{11}=E\left(x_{1} x_{1}\right) &amp;=E\left(\left(w_{1} v_{2}+v_{1}\right)\left(w_{1} v_{2}+v_{1}\right)\right) \\ &amp;=w_{1}^{2} E\left(v_{2}^{2}\right)+2 w_{1} E\left(v_{1} v_{2}\right)+E\left(v_{1}^{2}\right) \\ &amp;=w_{1}^{2} \sigma_{2}^{2}+\sigma_{1}^{2} \end{aligned}<br>$$</p><p>然后同理，可以求出另外两个对角元素为$\Sigma_{22}=\sigma_{2}^{2}, \Sigma_{33}=w_{3}^{2} \sigma_{2}^{2}+\sigma_{3}^{2}$。而对于协方差矩阵的非对角元素有：</p><p>$$<br>\begin{array}{l}{\Sigma_{12}=E\left(x_{1} x_{2}\right)=E\left(\left(w_{1} v_{2}+v_{1}\right) v_{2}\right)=w_{1} \sigma_{2}^{2}} \\ {\Sigma_{13}=E\left(\left(w_{1} v_{2}+v_{1}\right)\left(w_{3} v_{2}+v_{3}\right)\right)=w_{1} w_{3} \sigma_{2}^{2}}\end{array}<br>$$</p><p>依次类似，可以得到完整的<strong>协方差矩阵</strong>为：</p><p>$$<br>\boldsymbol{\Sigma}=\left[\begin{array}{ccc}{w_{1}^{2} \sigma_{2}^{2}+\sigma_{1}^{2}} &amp; {w_{1} \sigma_{2}^{2}} &amp; {w_{1} w_{3} \sigma_{2}^{2}} \\ {w_{1} \sigma_{2}^{2}} &amp; {\sigma_{2}^{2}} &amp; {w_{3} \sigma_{2}^{2}} \\ {w_{1} w_{3} \sigma_{2}^{2}} &amp; {w_{3} \sigma_{2}^{2}} &amp; {w_{3}^{2} \sigma_{2}^{2}+\sigma_{3}^{2}}\end{array}\right]<br>$$</p><p><strong>信息矩阵是协方差矩阵的逆矩阵</strong>，此处我们可以通过计算联合高斯分布来得到协方差矩阵的逆：</p><p>$$<br>\begin{aligned} p\left(x_{1}, x_{2}, x_{3}\right) &amp;=p\left(x_{2}\right) p\left(x_{1} | x_{2}\right) p\left(x_{3} | x_{2}\right) \\ &amp;=\frac{1}{Z_{2}} \exp \left(-\frac{x_{2}^{2}}{2 \sigma_{2}^{2}}\right) \frac{1}{Z_{1}} \exp \left(-\frac{\left(x_{1}-w_{1} x_{2}\right)^{2}}{2 \sigma_{1}^{2}}\right) \frac{1}{Z_{3}} \exp \left(-\frac{\left(x_{3}-w_{3} x_{2}\right)^{2}}{2 \sigma_{3}^{2}}\right) \end{aligned}<br>$$</p><p>利用指数性质，可以计算出联合概率分布如下：</p><p>$$<br>\begin{array}{l}{p\left(x_{1}, x_{2}, x_{3}\right)} \\ {\quad=\frac{1}{Z} \exp \left(-\frac{x_{2}^{2}}{2 \sigma_{2}^{2}}-\frac{\left(x_{1}-w_{1} x_{2}\right)^{2}}{2 \sigma_{1}^{2}}-\frac{\left(x_{3}-w_{3} x_{2}\right)^{2}}{2 \sigma_{3}^{2}}\right)} \\ {\quad=\frac{1}{Z} \exp \left(-x_{2}^{2}\left[\frac{1}{2 \sigma_{2}^{2}}+\frac{w_{1}^{2}}{2 \sigma_{1}^{2}}-\frac{w_{3}^{2}}{2 \sigma_{3}^{2}}\right]-x_{1}^{2} \frac{1}{2 \sigma_{1}^{2}}+2 x_{1} x_{2} \frac{w_{1}}{2 \sigma_{1}^{2}}-x_{3}^{2} \frac{1}{2 \sigma_{3}^{2}}+2 x_{3} x_{2} \frac{w_{3}}{2 \sigma_{3}^{2}}\right)} \\ {\quad=\frac{1}{Z} \exp \left(-\frac{1}{2}\left[\begin{array}{ccc}{x_{1}} &amp; {x_{2}} &amp; {x_{3}}\end{array}\right]\left[\begin{array}{cccc}{\frac{1}{\sigma_{1}^{2}}} &amp; {-\frac{w_{1}}{\sigma_{1}^{2}}} &amp; {0} \\ {-\frac{w_{1}}{\sigma_{1}^{2}}} &amp; {\frac{w_{1}^{2}}{\sigma_{1}^{2}}+\frac{1}{\sigma_{2}^{2}}+\frac{w_{3}^{2}}{\sigma_{1}^{2}}} &amp; {-\frac{w_{3}}{\sigma_{3}^{2}}} \\ {0} &amp; {-\frac{w_{3}}{\sigma_{3}^{2}}} &amp; {\frac{1}{\sigma_{3}^{2}}}\end{array}\right]\left[\begin{array}{c}{x_{1}} \\ {x_{2}} \\ {x_{3}}\end{array}\right]\right)}\end{array}<br>$$</p><p>所以，这里上面矩阵就是协方差矩阵的逆，也就是信息矩阵：</p><p>$$<br>\boldsymbol{\Lambda}=\mathbf{\Sigma}^{-1}=\left[\begin{array}{ccc}{\frac{1}{\sigma_{1}^{2}}} &amp; {-\frac{w_{1}}{\sigma_{1}^{2}}} &amp; {0} \\ {-\frac{w_{1}}{\sigma_{1}^{2}}} &amp; {\frac{w_{1}^{2}}{\sigma_{1}^{2}}+\frac{1}{\sigma_{1}^{2}}+\frac{w_{3}^{2}}{\sigma_{1}^{2}}} &amp; {-\frac{w_{3}}{\sigma_{3}^{2}}} \\ {0} &amp; {-\frac{w_{3}^{2}}{\sigma_{3}^{2}}} &amp; {\frac{1}{\sigma_{3}^{2}}}\end{array}\right]<br>$$</p><p>由上，可以看到当在协方差矩阵中，$x_{1}$与$x_{3}$之间是相关的，而在信息矩阵中，它们是相互独立的（相关系数为0）,这是因为，我们在推导信息矩阵时是使用了联合分布的<strong>链式法则</strong>，信息矩阵中$x_{1}$与$x_{3}$的相关性在$x_{2}$确定之后计算的，此时它们是相互独立的。</p><h2 id="上述例子中去掉-x-3"><a href="#上述例子中去掉-x-3" class="headerlink" title="上述例子中去掉$x_{3}$"></a>上述例子中去掉$x_{3}$</h2><p>协方差矩阵直接只计算前两个相关的协方差矩阵即可，也就是去掉划线的部分</p><p><img src="/img/math/cov.PNG" alt="marg"><br>变为：</p><p><img src="/img/math/cov1.PNG" alt="marg"></p><p>至于信息矩阵，只需要把信息矩阵公式中$x_{3}$相关的部分（蓝色）去掉：</p><p><img src="/img/math/information.PNG" alt="marg"><br>得到：</p><p><img src="/img/math/information1.PNG" alt="marg"></p><blockquote><p>之所以要移除一个变量，然后再算它的信息矩阵，是因为在实际应用中经常会用到这样的操作，上面只讲了原理，下面会抽时间讲讲如何快速实现，会需要<strong>舒尔补(Schur’s complement)</strong>与<strong>边缘化(marginalization)</strong>。</p></blockquote><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><blockquote><p>此处需要注意，协方差矩阵与信息矩阵都可以用来表示多元变量之间的相关性。但是，协方差矩阵是衡量的变量之间<strong>边界概率关系</strong>，通常是直接相关性，信息矩阵会有间接相关性，衡量的是变量之间的<strong>条件概率关系</strong>。因此，在计算中我们会发现<strong>有些协方差矩阵中相关的两个量在信息矩阵中不相关，有些协方差矩阵中不相关的两个量在信息矩阵中相关</strong>。</p></blockquote><p>比如在下面这个例子中</p><p>$$<br>x_{2}=w_{1} x_{1}+w_{3} x_{3}+v_{2}<br>$$</p><p><img src="/img/math/sample2.PNG" alt="marg"></p><p>协方差矩阵为：</p><p>$$<br>\boldsymbol{\Sigma}=\left[\begin{array}{cccc}{\sigma_{1}^{2}} &amp; {w_{1} \sigma_{1}^{2}} &amp; {0} \\ {w_{1} \sigma_{1}^{2}} &amp; {\sigma_{2}^{2}+w_{1}^{2} \sigma_{1}^{2}+w_{3}^{2} \sigma_{3}^{2}} &amp; {w_{3} \sigma_{3}^{2}} \\ {0} &amp; {w_{3} \sigma_{3}^{2}} &amp; {\sigma_{3}^{2}}\end{array}\right]<br>$$</p><p>信息矩阵为：</p><p>$$<br>\left[\begin{array}{ccc}{\frac{1}{\sigma_{1}^{2}}+\frac{w_{1}^{2}}{\sigma_{2}^{2}}} &amp; {-\frac{w_{1}}{\sigma_{2}^{2}}} &amp; {\frac{w_{1} w_{3}}{\sigma_{2}^{2}}} \\ {-\frac{w_{1}}{\sigma_{2}^{2}}} &amp; {\frac{1}{\sigma_{2}^{2}}} &amp; {-\frac{w_{3}}{\sigma_{2}^{2}}} \\ {\frac{w_{1} w_{3}}{\sigma_{2}^{2}}} &amp; {-\frac{w_{3}}{\sigma_{2}^{2}}} &amp; {\frac{1}{\sigma_{3}^{2}}+\frac{w_{3}^{2}}{\sigma_{2}^{2}}}\end{array}\right]<br>$$</p><blockquote><p>$x_{1}$与$x_{3}$在协方差矩阵中不相关，在信息矩阵中相关。这是因为协方差矩阵中是直接相关性，信息矩阵可以使用链式法则推导，其中当$x_2$固定后，这两个变量就会变成相关的了。</p></blockquote><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1] 深蓝学院vio课程讲义</li><li>[2] David Mackay. “The humble Gaussian distribution”. In:(2006).</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>imu的数学模型与误差标定问题</title>
    <link href="/2019/07/11/2019-07-11-imu-calibration/"/>
    <url>/2019/07/11/2019-07-11-imu-calibration/</url>
    
    <content type="html"><![CDATA[<h1 id="IMU数学模型"><a href="#IMU数学模型" class="headerlink" title="IMU数学模型"></a>IMU数学模型</h1><h2 id="加速度计"><a href="#加速度计" class="headerlink" title="加速度计"></a>加速度计</h2><p>首先，对于世界坐标系，一般我们会使用最常见的东北天(ENU)坐标系G（无关远点位置，只与姿态有关）。</p><div style="text-align: center"><img src="/img/vio/ENU.PNG"/></div>在这个坐标系中，重力加速度为<p>$$g^G = (0,0,-9.81)^T$$。</p><p>此时，<strong>假设IMU坐标系就是ENU坐标系</strong>，则$R_{IB}=I$，静止时有（其中$a_{m}$是测量值）：</p><p>$$a = 0$$</p><p>$$a_{m} = -g$$</p><p>所以，不静止时：（此处对a和g符号不做区分标记，因为假设body系与Global系一样）</p><p>$$a_{m} = a - g $$</p><blockquote><p>由上可知，其实在物体做自由落体时imu测量的加速度才是0，静止时反而是$-g$，这个是由加速度计的测量原理决定的。</p></blockquote><p>上面讲的是在IMU坐标系也是ENU坐标系时的情况（此时位置无关，只关乎姿态）。大多数实际应用中，<strong>IMU坐标系（Body）一般是与ENU坐标系有一个姿态的变化</strong>的。此时，得到的理论测量值为：</p><p>$$ a_{m}^{B} = R_{BG} (a^{G} - g^{G}) $$</p><blockquote><p>此处$R_{BG}$是将Global坐标转换到Body坐标姿态的旋转矩阵。此处可以看出，global坐标系的位置与body坐标系的位置与在两个系下测量的加速度大小无关。但是，与姿态有关。</p></blockquote><h2 id="陀螺仪"><a href="#陀螺仪" class="headerlink" title="陀螺仪"></a>陀螺仪</h2><p>相比较于加速度计，陀螺仪相对简单。如果不考虑误差，则</p><p>$$ w_{m}^{B} = w^{B} $$</p><blockquote><p>我们会发现此处并没有向加速度计一样，将global坐标系下的角速度转换到陀螺仪的测量值，而是直接使用body系下的角速度。这是因为旋转叠加时（比如四元数和旋转矩阵表示姿态时），全局姿态是直接乘以body系下的更新量的就可以得到新的全局姿态的。</p></blockquote><h2 id="恢复运动轨迹"><a href="#恢复运动轨迹" class="headerlink" title="恢复运动轨迹"></a>恢复运动轨迹</h2><p>imu最后输出的是一个离散的加速度、角速度序列。我们想做的是利用这些恢复出运动的轨迹（也就是一个位姿的序列）。</p><p>下面会介绍两种离散积分的方法。<strong>欧拉法与中值法</strong>。</p><p>这两种方法，都是已知了$k$时刻的位姿，$k$时刻与$k+1$时刻的测量值（加速度与角速度）。目的是求得$k+1$时刻的位姿。</p><h3 id="欧拉法"><a href="#欧拉法" class="headerlink" title="欧拉法"></a>欧拉法</h3><p>欧拉法，是直接使用$k$时刻的测量值$a,w$来积分。</p><p>$$<br>\mathbf{p}<em>{w b</em>{k+1}}=\mathbf{p}<em>{w b</em>{k}}+\mathbf{v}_{k}^{w} \Delta t+\frac{1}{2} \mathbf{a} \Delta t^{2}<br>$$</p><p>$$<br>\mathbf{v}<em>{k+1}^{w}=\mathbf{v}</em>{k}^{w}+\mathbf{a} \Delta t<br>$$</p><p>$$<br>\mathbf{q}<em>{w b</em>{k+1}}=\mathbf{q}<em>{w b</em>{k}} \otimes\left[\begin{array}{c}{1} \\ {\frac{1}{2} \omega \delta t}\end{array}\right]<br>$$</p><p>其中</p><p>$$<br>\mathbf{a} = \mathbf{q}<em>{w b</em>{k}} \mathbf{a}^{b_{k}} - \mathbf{g}^{w}<br>$$</p><p>$$<br>\boldsymbol{\omega} = \boldsymbol{\omega}^{b_{k}}<br>$$</p><h3 id="中值法"><a href="#中值法" class="headerlink" title="中值法"></a>中值法</h3><p>中值法，使用两个相邻时刻$k$到$k+1$的位姿是用两个时刻的测量值$a,w$的平均值来离散积分。</p><p>$$<br>\mathbf{p}<em>{w b</em>{k+1}}=\mathbf{p}<em>{w b</em>{k}}+\mathbf{v}_{k}^{w} \Delta t+\frac{1}{2} \mathbf{a} \Delta t^{2}<br>$$</p><p>$$<br>\mathbf{v}<em>{k+1}^{w}=\mathbf{v}</em>{k}^{w}+\mathbf{a} \Delta t<br>$$</p><p>$$<br>\mathbf{q}<em>{w b</em>{k+1}}=\mathbf{q}<em>{w b</em>{k}} \otimes\left[\begin{array}{c}{1} \\ {\frac{1}{2} \omega \delta t}\end{array}\right]<br>$$</p><p>其中</p><p>$$<br>\mathbf{a} = \frac{1}{2} \left(\mathbf{q}<em>{w b</em>{k}} \mathbf{a}^{b_{k}} + \mathbf{q}<em>{w b</em>{k+1}} \mathbf{a}^{b_{k+1}} \right) - \mathbf{g}^{w}<br>$$</p><p>$$<br>\boldsymbol{\omega} = \frac{1}{2} \left(\boldsymbol{\omega}^{b_{k}} + \boldsymbol{\omega}^{b_{k+1}} \right)<br>$$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; imudata.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; ++i) &#123;<br><br>        MotionData imupose = imudata[i];<br>        MotionData imupose1 = imudata[i+<span class="hljs-number">1</span>];<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">        // 欧拉积分</span><br><span class="hljs-comment">        //delta_q = [1 , 1/2 * thetax , 1/2 * theta_y, 1/2 * theta_z]</span><br><span class="hljs-comment">        Eigen::Quaterniond dq;</span><br><span class="hljs-comment">        Eigen::Vector3d dtheta_half =  imupose.imu_gyro * dt /2.0;</span><br><span class="hljs-comment">        dq.w() = 1;</span><br><span class="hljs-comment">        dq.x() = dtheta_half.x();</span><br><span class="hljs-comment">        dq.y() = dtheta_half.y();</span><br><span class="hljs-comment">        dq.z() = dtheta_half.z();</span><br><span class="hljs-comment">        Eigen::Vector3d acc_w = Qwb * (imupose.imu_acc) + gw;</span><br><span class="hljs-comment">        Pwb = Pwb + Vw * dt + 0.5 * dt * dt * acc_w;</span><br><span class="hljs-comment">        Vw = acc_w * dt + Vw;</span><br><span class="hljs-comment">        Qwb = Qwb * dq;</span><br><span class="hljs-comment">        Qwb.normalize();</span><br><span class="hljs-comment">*/</span><br><br>        <span class="hljs-comment">/// 中值积分</span><br>        Eigen::Quaterniond dq;<br>        Eigen::Vector3d dtheta_half = (imupose.imu_gyro + imupose1.imu_gyro)*dt/<span class="hljs-number">4.0</span>;<br>        dq.<span class="hljs-built_in">w</span>() = <span class="hljs-number">1</span>;<br>        dq.<span class="hljs-built_in">x</span>() = dtheta_half.<span class="hljs-built_in">x</span>();<br>        dq.<span class="hljs-built_in">y</span>() = dtheta_half.<span class="hljs-built_in">y</span>();<br>        dq.<span class="hljs-built_in">z</span>() = dtheta_half.<span class="hljs-built_in">z</span>();<br>        Eigen::Quaterniond Qwb1 = Qwb * dq;<br>        Qwb1.<span class="hljs-built_in">normalize</span>();<br>        Eigen::Vector3d acc_w = (Qwb * imupose.imu_acc + Qwb1 * imupose1.imu_acc)*<span class="hljs-number">0.5</span> + gw;<br>        Pwb = Pwb + Vw * dt + <span class="hljs-number">0.5</span> * dt * dt * acc_w;<br>        Vw = acc_w * dt + Vw;  <br>        Qwb = Qwb1;<br><br>        <span class="hljs-comment">//存储位姿</span><br>        save_points&lt;&lt;imupose.timestamp&lt;&lt;<span class="hljs-string">&quot; &quot;</span><br>                   &lt;&lt;Qwb.<span class="hljs-built_in">w</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span><br>                   &lt;&lt;Qwb.<span class="hljs-built_in">x</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span><br>                   &lt;&lt;Qwb.<span class="hljs-built_in">y</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span><br>                   &lt;&lt;Qwb.<span class="hljs-built_in">z</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span><br>                   &lt;&lt;<span class="hljs-built_in">Pwb</span>(<span class="hljs-number">0</span>)&lt;&lt;<span class="hljs-string">&quot; &quot;</span><br>                   &lt;&lt;<span class="hljs-built_in">Pwb</span>(<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-string">&quot; &quot;</span><br>                   &lt;&lt;<span class="hljs-built_in">Pwb</span>(<span class="hljs-number">2</span>)&lt;&lt;<span class="hljs-string">&quot; &quot;</span><br>                   &lt;&lt;std::endl;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>此处推荐一个生成imu数据、加噪声与测试的<a href="https://github.com/HeYijia/vio_data_simulation">工具</a>，这里中值积分与欧拉积分可以参考上面的我的代码，因为工具里可能不一定提供了。</p></blockquote><h3 id="旋转积分"><a href="#旋转积分" class="headerlink" title="旋转积分"></a>旋转积分</h3><blockquote><p>上面恢复姿态轨迹的积分用了四元数的形式，下面我想多介绍几个</p></blockquote><p>此处$w$是imu的测量结果，也就是局部角速度。因为这个<strong>旋转积分的结果是姿态</strong>，因此下面会分别介绍使用四元数、SO3还有欧拉角下的积分方式。</p><ul><li>四元数的形式：</li></ul><p>$$<br>\mathbf{q}<em>{w b^{\prime}}=\mathbf{q}</em>{w b} \otimes\left[\begin{array}{c}{1} \\ {\frac{1}{2} \boldsymbol{\omega} \Delta t}\end{array}\right]<br>$$</p><ul><li>$SO3$形式：</li></ul><p>$$<br>\mathbf{R}<em>{w b^{\prime}}=\mathbf{R}</em>{w b} \exp (\boldsymbol{\omega} \cdot \Delta t)<br>$$</p><ul><li>欧拉角形式：</li></ul><p>$$<br>\vartheta w b^{\prime}=\vartheta_{w b}+E_{w b} \cdot \omega \Delta t<br>$$</p><blockquote><p>我们可以发现，这三种方法，<strong>对于全局姿态的变化</strong>，旋转矩阵与四元数都是直接使用imu的测量（也就是局部角速度）进行更新的。只有在欧拉角的形式里，$E_{w b}$表示将IMU body坐标系下的角速度转化成欧拉角速度。此处可以推导出$E_{w b}$，这个是三种方法中唯一一个需要转换的地方。<strong>原因的话，我觉得这是因为累加与累乘的区别，欧拉角不支持乘法。如果使用角度来表示旋转矩阵与四元数，此时对角度的更新也得使用加法（原来角度加上角速度与时间的积即为新的角度），但是四元数与旋转矩阵本身是只支持乘法的，它们是直接乘以局部扰动即可</strong>。</p></blockquote><h3 id="欧拉角速度到imu输出角速度"><a href="#欧拉角速度到imu输出角速度" class="headerlink" title="欧拉角速度到imu输出角速度"></a>欧拉角速度到imu输出角速度</h3><p>这个挺有必要的，因为用欧拉角来表示姿态还是很方便的。</p><ul><li>step1:绕着惯性坐标系的z轴旋转，得到新的坐标系$b^{1}$</li></ul><ul><li>step2:绕着新坐标系$b^{1}$的y轴旋转得到坐标系$b^{2}$</li></ul><ul><li>step3:绕着新坐标系$b^{2}$的x轴旋转得到坐标系$b^{3}$，$b^{3}$就是我们的body坐标系</li></ul><p>欧拉角速度到body角速度：</p><p>$$<br>\begin{aligned} \boldsymbol{\omega} &amp;=R(\psi) R(\theta)\left\{\begin{array}{c}{0} \\ {0} \\ {\frac{d \phi}{d t}}\end{array}\right\}+R(\psi)\left\{\begin{array}{c}{0} \\ {\frac{d \theta}{d t}} \\ {0}\end{array}\right\}+\left\{\begin{array}{c}{\frac{d \psi}{d t}} \\ {0} \\ {0}\end{array}\right\} \\ &amp;=\left[\begin{array}{ccc}{1} &amp; {0} &amp; {-\sin \theta} \\ {0} &amp; {\cos \psi} &amp; {\sin \psi \cos \theta} \\ {0} &amp; {-\sin \psi} &amp; {\cos \psi \cos \theta}\end{array}\right]\left\{\begin{array}{l}{\frac{d \psi}{d t}} \\ {\frac{d \psi}{d t}} \\ {\frac{d \phi}{d t}}\end{array}\right\} \end{aligned}<br>$$</p><p>上面取逆就得到，如下body到欧拉角的变换：</p><p>$$<br>\frac{d \boldsymbol{\vartheta}}{d t}=\left[\begin{array}{ccc}{1} &amp; {\sin \psi \tan \theta} &amp; {\cos \psi \tan \theta} \\ {0} &amp; {\cos \psi} &amp; {-\sin \psi} \\ {0} &amp; {\sin \psi / \cos \theta} &amp; {\cos \psi / \cos \theta}\end{array}\right] \vec{\omega}<br>$$</p><h1 id="误差与标定"><a href="#误差与标定" class="headerlink" title="误差与标定"></a>误差与标定</h1><p>加速度计和陀螺仪的误差可以分为确定性误差与随机误差。</p><h2 id="确定性误差"><a href="#确定性误差" class="headerlink" title="确定性误差"></a>确定性误差</h2><p>确定性误差可以事先标定确定，包括：bias，scale …</p><h3 id="bias"><a href="#bias" class="headerlink" title="bias"></a>bias</h3><p>理论上，当没有外部作用时，IMU传感器的输出应该为0。但是，实际上数据存在一个偏置b。</p><h3 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h3><p>scale可以看成是实际数值和传感器输出值之间的比值。</p><div style="text-align: center"><img src="/img/vio/scale.PNG"/></div><h3 id="Nonorthogonality-Misalignment-Errors"><a href="#Nonorthogonality-Misalignment-Errors" class="headerlink" title="Nonorthogonality/Misalignment Errors"></a>Nonorthogonality/Misalignment Errors</h3><p>在多轴IMU传感器制作的时候，由于制作工艺的问题的问题，会使得$xyz$轴可能不垂直，这个也叫<strong>轴间误差</strong>。</p><div style="text-align: center"><img src="/assets/img/vio/misalign.PNG"/></div><p>轴间误差使得本来x轴的分量会对测量到的y轴与z轴的分量有影响。将其与scale误差相结合，会得到如下的测量与实际的对应关系。</p><p>$$\left[\begin{array}{l}{a_{m x}} \\ {a_{m y}} \\ {a_{m z}}\end{array}\right]=\left[\begin{array}{lll}{s_{x x}} &amp; {m_{x y}} &amp; {m_{x z}} \\ {m_{y x}} &amp; {s_{y y}} &amp; {m_{y z}} \\ {m_{z x}} &amp; {m_{z y}} &amp; {s_{z z}}\end{array}\right]\left[\begin{array}{l}{a_{x}} \\ {a_{y}} \\ {a_{z}}\end{array}\right]$$</p><h3 id="其他确定性误差"><a href="#其他确定性误差" class="headerlink" title="其他确定性误差"></a>其他确定性误差</h3><p>bias与scale的误差是会受温度影响的，并且在运行中也许也会改变。</p><h2 id="确定新误差的标定（六面法）"><a href="#确定新误差的标定（六面法）" class="headerlink" title="确定新误差的标定（六面法）"></a>确定新误差的标定（六面法）</h2><blockquote><p>以加速度计为例，陀螺仪同理</p></blockquote><p>指将加速度计的3个轴分别朝上或者朝下水平放置一段时间（对于陀螺仪就是在三个旋转轴上正反旋转，不过需要高精度转台），采集六个面的数据完成标定。</p><h3 id="3个轴都是正交时"><a href="#3个轴都是正交时" class="headerlink" title="3个轴都是正交时"></a>3个轴都是正交时</h3><p>$$ bias =  \frac{l_{f}^{up} + l_{f}^{down}}{2} $$</p><p>$$ scale = \frac{l_{f}^{up} - l_{f}^{down}}{2*g} $$</p><blockquote><p>其中，$l$为加速度计某个轴的测量值，$g$为当地的重力加速度。</p></blockquote><h3 id="当具有轴间误差时"><a href="#当具有轴间误差时" class="headerlink" title="当具有轴间误差时"></a>当具有轴间误差时</h3><p>此时实际加速度和测量值之间的关系为：</p><p>$$<br>\left[\begin{array}{l}{l_{a x}} \\ {l_{a y}} \\ {l_{a z}}\end{array}\right]=\left[\begin{array}{lll}{s_{x x}} &amp; {m_{x y}} &amp; {m_{x z}} \\ {m_{y x}} &amp; {s_{y y}} &amp; {m_{y z}} \\ {m_{z x}} &amp; {m_{z y}} &amp; {s_{z z}}\end{array}\right]\left[\begin{array}{l}{a_{x}} \\ {a_{y}} \\ {a_{z}}\end{array}\right]+\left[\begin{array}{l}{b_{a x}} \\ {b_{a y}} \\ {b_{a z}}\end{array}\right]<br>$$</p><p>水平静止放置6面的时候，加速度的理论值为：</p><p>$$<br>a_{1}=\left[\begin{array}{l}{g} \\ {0} \\ {0}\end{array}\right], a_{2}=\left[\begin{array}{c}{-g} \\ {0} \\ {0}\end{array}\right], a_{3}=\left[\begin{array}{l}{0} \\ {g} \\ {0}\end{array}\right], a_{4}=\left[\begin{array}{c}{0} \\ {-g} \\ {0}\end{array}\right], a_{5}=\left[\begin{array}{l}{0} \\ {0} \\ {g}\end{array}\right], a_{6}=\left[\begin{array}{c}{0} \\ {0} \\ {-g}\end{array}\right]<br>$$</p><p>对应的测量值矩阵L:</p><p>$$<br>\mathbf{L}=\left[\begin{array}{llllll}{\mathbf{l}<em>{1}} &amp; {\mathbf{l}</em>{2}} &amp; {\mathbf{l}<em>{3}} &amp; {\mathbf{l}</em>{4}} &amp; {\mathbf{l}<em>{5}} &amp; {\mathbf{l}</em>{6}}\end{array}\right]<br>$$</p><p>利用最小二乘就能够把12个变量求出来。</p><h2 id="随机误差"><a href="#随机误差" class="headerlink" title="随机误差"></a>随机误差</h2><p>随机误差主要有两部分，一个是高斯白噪声，一个是bias随机游走。</p><h3 id="高斯白噪声"><a href="#高斯白噪声" class="headerlink" title="高斯白噪声"></a>高斯白噪声</h3><p>IMU数据连续时间上受到一个均值为0，方差为$\sigma$，各时刻之间相互独立的高斯过程$n(t)$:</p><p>$$<br>\begin{array}{l}{E[n(t)] \equiv 0} \\ {E\left[n\left(t_{1}\right) n\left(t_{2}\right)\right]=\sigma^{2} \delta\left(t_{1}-t_{2}\right)}\end{array}<br>$$</p><p>其中$\delta()$表示狄拉克函数。</p><p>不过需要说明的是，实际上，IMU传感器获取的数据为离散采样，离散和连续高斯白噪声的方差之间存在如下转换关系：</p><p>$$<br>\begin{aligned} n_{d}[k] &amp; \triangleq n\left(t_{0}+\Delta t\right) \simeq \frac{1}{\Delta t} \int_{t_{0}}^{t_{0}+\Delta t} n(\tau) d t \\ E\left(n_{d}[k]^{2}\right) &amp;=E\left(\frac{1}{\Delta t^{2}} \int_{t_{0}}^{t_{0}+\Delta t} \int_{t_{0}}^{t_{0}+\Delta t} n(\tau) n(t) d \tau d t\right) \\ &amp;=E\left(\frac{\sigma^{2}}{\Delta t^{2}} \int_{t_{0}}^{t_{0}+\Delta t} \int_{t_{0}}^{t_{0}+\Delta t} \delta(t-\tau) d \tau d t\right) \\ &amp;=E\left(\frac{\sigma^{2}}{\Delta t}\right) \end{aligned}<br>$$</p><blockquote><p>即离散的序列的方差是连续的方差除以$\Delta t$（传感器的采样时间），也就是乘以采样频率f。(下面$\sigma$是标准差，一般参数文件里写的也是标准差)</p></blockquote><p>$$<br>\sigma_{d} = \sigma \frac{1}{\sqrt{\Delta t}}<br>$$</p><h3 id="bias-1"><a href="#bias-1" class="headerlink" title="bias"></a>bias</h3><h3 id="随机游走"><a href="#随机游走" class="headerlink" title="随机游走"></a>随机游走</h3><p>通常使用维纳过程来建模bias随时间连续变化的过程，离散时间下称之为随机游走。</p><p>$$<br>\dot{b}(t)=n(t)=\sigma_{b} w(t)<br>$$</p><p>bias的变化的导数是其中$w$是方差为1的白噪声。</p><p>同样，离散和连续之间的转换为：</p><p>$$<br>\begin{aligned} b_{d}[k] \triangleq &amp; b\left(t_{0}\right)+\int_{t_{0}}^{t_{0}+\Delta t} n(t) d t \\ E\left(\left(b_{d}[k]-b_{d}[k-1]\right)^{2}\right) &amp;=E\left(\int_{t_{0}+\Delta t}^{t_{0}+\Delta t} \int_{t_{0}}^{t_{0}+\Delta t} n(t) n(\tau) d \tau d t\right) \\ &amp;=E\left(\sigma_{b}^{2} \int_{t_{0}}^{t_{0}+\Delta t} \int_{t_{0}}^{t_{0}+\Delta t} \delta(t-\tau) d \tau d t\right) \\ &amp;=E\left(\sigma_{b}^{2} \Delta t\right) \end{aligned}<br>$$</p><blockquote><p>bias随机游走离散序列的噪声方差是连续的方差乘以$\Delta t$倍（传感器的采样时间），也就是除以采样频率f。</p></blockquote><p>$$<br>\sigma_{bd}=\sigma_{b}\sqrt{\Delta t}<br>$$</p><h2 id="随机误差的标定（艾伦方差标定）"><a href="#随机误差的标定（艾伦方差标定）" class="headerlink" title="随机误差的标定（艾伦方差标定）"></a>随机误差的标定（艾伦方差标定）</h2><p>Allan方差法是20世纪60年代由美国国家标准局的David Allan提出的，它是一种基于时域的分析方法。具体流程如下：</p><ol><li><p>保持传感器绝对静止获取数据</p></li><li><p>对数据进行分段，设置时间段的时长，如下图所示。</p></li><li><p>将传感器数据按照时间段进行平均。</p></li><li><p>计算方差，绘制艾伦曲线。</p></li></ol><div style="text-align: center"><img src="/img/vio/allan.PNG"/></div><ul><li><p>此处的艾伦方差的计算公式如下（将每个时间段长度作为一个变量，将每个时间段的数据求均值，计算方差）：</p><div style="text-align: center"><img src="/img/vio/allan2.PNG"  width="400" height="110"/></div></li><li><p>忽略其他噪声的影响，Allan方差可以近似为各种噪声的和，化简为：</p><div style="text-align: center"><img src="/img/vio/allan3.png"  width="600" height="70"/></div></li></ul><blockquote><p>其中，Q:量化噪声误差系数；N：角速度随机游走误差系数；B：零偏不稳定性误差系数；K：速率随机游走误差系数；R：速率斜坡误差系数</p></blockquote><div style="text-align: center"><img src="/img/vio/allan4.png"   width="740" height="250"/></div>(ps:其中表格中B那一项是乘法不是除法，写错了)<p>这里，绘制出来的艾伦曲线如下图所示：</p><div style="text-align: center"><img src="/img/vio/allan1.PNG"/></div><blockquote><p>其中t=1，斜率为-0.5处纵坐标的值为<strong>高斯白噪声方差</strong>，斜率为0.5，t=3处的纵坐标的值为<strong>随机游走方差</strong>。</p></blockquote><p>下面给出两个github上的比较好用的标定工具。</p><ol><li><p><a href="https://github.com/gaowenliang/imu_utils">imu_utils</a>，额注意，这个工具的结果关于bias那一项输出的是bias稳定性的方差，不是随机游走的方差，因此，我们需要此工具生成的艾伦方差曲线自行完成bias随机游走方差的获得。。</p></li><li><p><a href="https://github.com/rpng/kalibr_allan">kalibr_allan</a></p></li></ol><h2 id="加上误差模型后的理论测量值"><a href="#加上误差模型后的理论测量值" class="headerlink" title="加上误差模型后的理论测量值"></a>加上误差模型后的理论测量值</h2><ul><li>加速度计</li></ul><p>$$<br>\mathbf{a}<em>{m}^{B}=\mathbf{S}</em>{a} \mathbf{R}<em>{B G}\left(\mathbf{a}^{G}-\mathbf{g}^{G}\right)+\mathbf{n}</em>{a}+\mathbf{b}_{a}<br>$$</p><ul><li>陀螺仪</li></ul><p>$$<br>\boldsymbol{\omega}<em>{m}^{B}=\mathbf{S}</em>{g} \boldsymbol{\omega}^{B}+\mathbf{n}<em>{g}+\mathbf{b}</em>{g}<br>$$</p><ul><li>低端传感器，可能会出现加速度影响陀螺仪的值的情况，也就是下面的第二项：</li></ul><p>$$<br>\boldsymbol{\omega}<em>{m}^{B}=\mathbf{S}</em>{g} \boldsymbol{\omega}^{B}+\mathbf{s}<em>{g a} \mathbf{a}^{B}+\mathbf{n}</em>{g}+\mathbf{b}_{g}<br>$$</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] 深蓝学院vio课程</li><li>[2] <a href="https://blog.csdn.net/Diannie/article/details/88062687">https://blog.csdn.net/Diannie/article/details/88062687</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>多传感器融合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旋转矩阵是正交矩阵与伴随性质的证明</title>
    <link href="/2019/07/03/2019-07-03-ratation-matrix/"/>
    <url>/2019/07/03/2019-07-03-ratation-matrix/</url>
    
    <content type="html"><![CDATA[<h2 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h2><p>正交矩阵的定义如下：如果</p><p>$$ AA^T &#x3D; E $$</p><p>其中E为单位矩阵，则称n阶实矩阵A为正交矩阵。</p><p>所以正交矩阵的性质如下：</p><ol><li><p>正交矩阵的每一列、行都是单位向量，并且两两正交。最简单的正交矩阵就是单位阵。</p></li><li><p>正交矩阵的逆等于正交矩阵的转置。由此可以推断出正交矩阵的行列式的值肯定为正负1。</p></li></ol><blockquote><p>所有的矩阵都可以看成一种变换。正交矩阵的变换可以看成，如果作用在一组空间基向量上，它会<strong>将一组空间基向量(单位正交的)变换成另外一组空间基向量（还是单位正交的）</strong>。</p></blockquote><h2 id="向量与坐标"><a href="#向量与坐标" class="headerlink" title="向量与坐标"></a>向量与坐标</h2><p>对于三维空间中的任意一个向量$a$，它在一组基$\left(e_{1}, e_{2}, e_{3}\right)$下的表示如下：</p><p>$$<br>\boldsymbol{a}&#x3D;\left[\boldsymbol{e}<em>{1}, \boldsymbol{e}</em>{2}, \boldsymbol{e}<em>{3}\right]\left[\begin{array}{c}{a</em>{1}} \ {a_{2}} \ {a_{3}}\end{array}\right]&#x3D;a_{1} e_{1}+a_{2} \boldsymbol{e}<em>{2}+a</em>{3} \boldsymbol{e}_{3}<br>$$</p><p>两个向量$a,b$的内积可以写成：</p><p>$$<br>a \cdot b&#x3D;a^{\mathrm{T}} b&#x3D;\sum_{i&#x3D;1}^{3} a_{i} b_{i}&#x3D;|\boldsymbol{a}||\boldsymbol{b}| \cos \langle\boldsymbol{a}, \boldsymbol{b}\rangle<br>$$</p><p>外积写成：</p><p>$$<br>\boldsymbol{a} \times \boldsymbol{b}&#x3D;\left|\begin{array}{ccc}{\boldsymbol{e}<em>{1}} &amp; {\boldsymbol{e}</em>{2}} &amp; {\boldsymbol{e}<em>{3}} \ {a</em>{1}} &amp; {a_{2}} &amp; {a_{3}} \ {b_{1}} &amp; {b_{2}} &amp; {b_{3}}\end{array}\right|&#x3D;\left[\begin{array}{cc}{a_{2} b_{3}-a_{3} b_{2}} \ {a_{3} b_{1}-a_{1} b_{3}} \ {a_{1} b_{2}-a_{2} b_{1}}\end{array}\right]&#x3D;\left[\begin{array}{ccc}{0} &amp; {-a_{3}} &amp; {a_{2}} \ {a_{3}} &amp; {0} &amp; {-a_{1}} \ {-a_{2}} &amp; {a_{1}} &amp; {0}\end{array}\right] \boldsymbol{b} \triangleq \boldsymbol{a}^{\wedge} \boldsymbol{b}<br>$$</p><p>其中$\boldsymbol{a}^{\wedge}$是向量$a$对应的反对称矩阵：</p><p>$$<br>\boldsymbol{a}^{\wedge}&#x3D;\left[\begin{array}{ccc}{0} &amp; {-a_{3}} &amp; {a_{2}} \ {a_{3}} &amp; {0} &amp; {-a_{1}} \ {-a_{2}} &amp; {a_{1}} &amp; {0}\end{array}\right]<br>$$</p><h2 id="旋转矩阵-是正交矩阵的证明"><a href="#旋转矩阵-是正交矩阵的证明" class="headerlink" title="旋转矩阵(是正交矩阵的证明)"></a>旋转矩阵(是正交矩阵的证明)</h2><p>旋转矩阵，对应了一种变换，在三维空间中，这种变换可以看成将空间中物体绕一条轴旋转一定角度。很容易发现，这是一种正交矩阵。</p><p>证明的话，可以按照如下思路。</p><ul><li><p>首先对于一组单位正交基$\left(e_{1}, e_{2}, e_{3}\right)$经过一次旋转变换后变成了$\left(e_{1}^{\prime}, e_{2}^{\prime}, e_{3}^{\prime}\right)$ </p></li><li><p>那么，对于同一个向量$a$(没有随着坐标系的旋转而发生运动)，所以会有如下等式成立，其中两个竖向量分别是$a$在两个单位正交基下的坐标：</p></li></ul><p>$$<br>\left[e_{1}, e_{2}, e_{3}\right]\left[\begin{array}{l}{a_{1}} \ {a_{2}} \ {a_{3}}\end{array}\right]&#x3D;\left[e_{1}^{\prime}, e_{2}^{\prime}, e_{3}^{\prime}\right]\left[\begin{array}{c}{a_{1}^{\prime}} \ {a_{2}^{\prime}} \ {a_{3}^{\prime}}\end{array}\right]<br>$$</p><ul><li>上述公式左右同时左乘$\left[\begin{array}{c}{e_{1}^{\mathrm{T}}} \ {e_{2}^{\mathrm{T}}} \ {e_{3}^{\mathrm{T}}}\end{array}\right]$，我们会得到如下公式，其中$R$是这次旋转变换对向量$\left[a_{1}^{\prime}, a_{2}^{\prime}, a_{3}^{\prime}\right]^{\mathrm{T}}$的变换矩阵。</li></ul><p>$$<br>\left[\begin{array}{c}{a_{1}} \ {a_{2}} \ {a_{3}}\end{array}\right]&#x3D;\left[\begin{array}{ccc}{e_{1}^{\mathrm{T}} e_{1}^{\prime}} &amp; {e_{1}^{\mathrm{T}} e_{2}^{\prime}} &amp; {e_{1}^{\mathrm{T}} e_{3}^{\prime}} \ {e_{2}^{\mathrm{T}} \boldsymbol{e}<em>{1}^{\prime}} &amp; {\boldsymbol{e}</em>{2}^{\mathrm{T}} \boldsymbol{e}<em>{2}^{\prime}} &amp; {\boldsymbol{e}</em>{2}^{\mathrm{T}} \boldsymbol{e}<em>{3}^{\prime}} \ {\boldsymbol{e}</em>{3}^{\mathrm{T}} \boldsymbol{e}<em>{1}^{\prime}} &amp; {\boldsymbol{e}</em>{3}^{\mathrm{T}} \boldsymbol{e}<em>{2}^{\prime}} &amp; {\boldsymbol{e}</em>{3}^{\mathrm{T}} \boldsymbol{e}<em>{3}^{\prime}}\end{array}\right]\left[\begin{array}{c}{a</em>{1}^{\prime}} \ {a_{2}^{\prime}} \ {a_{3}^{\prime}}\end{array}\right] &#x3D; \boldsymbol{R} a^{\prime}<br>$$</p><p>此处，矩阵$R$<strong>由两组基之间的内积</strong>组成，刻画了前后同一个向量经过一次旋转变换的坐标变换关系。因此，这个$R$就是一个旋转矩阵（只有两个正交基不变，它就不变）。这个矩阵按列看，是第二组基向量在第一组中的坐标表示，按行看，是第一组基向量在第二组中的坐标表示。它们肯定是相互正交的。</p><blockquote><p>我们可以很清楚的发现，旋转矩阵R是一个<strong>正交矩阵</strong>。因为，如果将矩阵$R$转置，其实刚好就是一个$R$的逆操作，将两组正交基顺序交换了。</p></blockquote><h2 id="伴随性质的证明"><a href="#伴随性质的证明" class="headerlink" title="伴随性质的证明"></a>伴随性质的证明</h2><blockquote><p>对任意的旋转矩阵$\bf R$和三维向量$\bf v$，都有$({\bf R v})^{\land} &#x3D; {\bf Rv^{\land}R}^{T} $</p></blockquote><p>这个性质经常在机器人动力学中使用很频繁。今天不小心看到一个<a href="https://fzheng.me/2017/12/10/Rvhat/">证明</a>，于是记录一下。</p><p>此处需要把$()^{\land}$运算符转换成叉乘。我们知道，对于任意${\bf v,u} \in \mathbb{R}^3$，总有${\bf v}^{\land}{\bf v \times u}$。于是：</p><p>$$<br>\begin{aligned} &amp;(\mathbf{R} \mathbf{v})^{\wedge}&#x3D;\mathbf{R} \mathbf{v}^{\wedge} \mathbf{R}^{T} \ \Leftrightarrow &amp;(\mathbf{R} \mathbf{v})^{\wedge} \mathbf{R}&#x3D;\mathbf{R} \mathbf{v}^{\wedge} \ \Leftrightarrow &amp; \forall \mathbf{u} \in \mathbb{R}^{3},(\mathbf{R} \mathbf{v})^{\wedge} \mathbf{R} \mathbf{u}&#x3D;\mathbf{R} \mathbf{v}^{\wedge} \mathbf{u} \ \Leftrightarrow &amp; \forall \mathbf{u} \in \mathbb{R}^{3},(\mathbf{R} \mathbf{v}) \times(\mathbf{R} \mathbf{u})&#x3D;\mathbf{R}(\mathbf{v} \times \mathbf{u}) \end{aligned}<br>$$</p><p>所以上面是一直等价的（倒数第二个式子到最后一个式子等价，因为矩阵乘法满足结合律），我们只需要证明最后一个式子即可，最后一个式子通过利用向量叉乘的旋转变换不变性（参照<a href="https://en.wikipedia.org/wiki/Cross_product#Algebraic_properties">Wikipedia</a>）。</p><blockquote><p>其实最后一个式子很好理解，对于任意${\bf v,u} \in \mathbb{R}^3$，它们是任意三维向量，将他们经过同一个旋转，它们的相对位姿与模长都不会改变，所以$\bf Rv$与$\bf Ru$的叉乘仍然是相对它们垂直、大小也不变的三维向量。</p></blockquote><h2 id="旋转向量与旋转矩阵的指数映射"><a href="#旋转向量与旋转矩阵的指数映射" class="headerlink" title="旋转向量与旋转矩阵的指数映射"></a>旋转向量与旋转矩阵的指数映射</h2><p>指数映射的数学意义就是罗德里杰斯公式。</p><p>对于一个旋转向量a，其对应的矩阵是$R_a$，则有：</p><ul><li><p>指数映射：$ exp(\mathbf{a}^{\wedge}) &#x3D; R_a $</p></li><li><p>这个由叉乘时向量转矩阵形式决定，$ (\mathbf{a}^{\wedge})^T &#x3D; - \mathbf{a}^{\wedge} $</p></li><li><p>这个右叉乘交换性质决定： $ \mathbf{a}^{\wedge} \mathbf{b} &#x3D; - \mathbf{b}^{\wedge} \mathbf{a}$</p></li><li><p>矩阵叉乘性质：$R w^{\wedge} R ^{T} &#x3D; (Rp)^{\wedge} $</p></li><li><p>SO(3)的伴随性质： $ \mathbf{R}^{T} \exp \left(\boldsymbol{\phi}^{\wedge}\right) \mathbf{R}&#x3D;\exp \left(\left(\mathbf{R}^{T} \boldsymbol{\phi}\right)^{\wedge}\right) $</p></li><li><p>扰动模型1</p></li></ul><p>$$<br>\ln \left(\mathbf{R} \exp \left(\phi^{\wedge}\right)\right)^{\vee}&#x3D;\ln (\mathbf{R})^{\vee}+\mathbf{J}_{r}^{-1} \boldsymbol{\phi}<br>$$</p><ul><li>BCH公式</li></ul><p>$$<br>R_1 R_2 &#x3D; \textbf{exp}({\phi_1}^{\wedge})\textbf{exp}({\phi_2}^{\wedge}) \approx \begin{equation} \begin{cases} \textbf{exp}(( J_l(\phi_2)^{-1} \phi_1 + \phi_2    )^{\wedge})  &amp; \textbf{if  } \phi_1 \textbf{ is small}\ \textbf{exp}(( J_r(\phi_1)^{-1} \phi_2+ \phi_1    )^{\wedge})   &amp; \textbf{if  } \phi_2 \textbf{ is small} \end{cases} \end{equation}<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三维中间中旋转的表示方式--欧拉角、旋转矩阵、旋转向量、四元数</title>
    <link href="/2019/06/19/2019-06-19-rotation-3d/"/>
    <url>/2019/06/19/2019-06-19-rotation-3d/</url>
    
    <content type="html"><![CDATA[<p>三维空间中的旋转有很多种表示方式，欧拉角，旋转矩阵，旋转向量，四元数。由于在slam与机器人中会大量用到这方面的知识，所以在这里将此方面的知识总结一下，方便以后查阅。</p><h2 id="欧拉角（Euler-Angle）"><a href="#欧拉角（Euler-Angle）" class="headerlink" title="欧拉角（Euler Angle）"></a>欧拉角（Euler Angle）</h2><blockquote><p>欧拉角可以使用滑翔翼飞行器控制来理解，比如对于下面这张图，一般假设红色轴为z轴，则z轴表示空间的第三维，则去掉这一维度表示飞行器在一个二维平面上；蓝色轴为x轴，也是<strong>飞行器的朝向</strong>，因此绕此轴转动就像是飞行器在做翻滚动作，因此叫翻滚角（roll）；绿色轴为y轴，绕这个轴转动其实就是飞机开始准备向上飞或者向下飞了，因此叫俯仰角（pitch）；同理，绕红色轴也就是z轴转动代表飞机开始调整自身在二维平面上的朝向了，因此叫偏航角（yaw）。</p></blockquote><div style="text-align: center"><img src="/img/rotation/euler_angle.png"/></div><p>在欧拉角的表示中，yaw、pitch、roll的顺序对旋转结果是有影响的。即<strong>给定一组欧拉角角度值，比如yaw=45度，pitch=30度，roll=60度，按照yaw-pitch-roll的顺序旋转和按照yaw-roll-pitch的顺序旋转，最终刚体的朝向是不同的！</strong>换言之，若刚体需要按照两种不同的旋转顺序旋转到相同的朝向，所需要的欧拉角角度值则是不同的！</p><blockquote><p>另外需要注意的是，在欧拉角的表示方式里，三个旋转轴一般是随着刚体在运动，即wikipedia中所谓的intrinsic rotation，见下图动画所示(图来自wikipedia)。相对应的另一种表示方式是，三个旋转轴是固定的，不随刚体旋转而旋转，即extrinsic rotation，这种表示方式在计算机视觉中不是很常用。</p></blockquote><p>欧拉角的优点是非常直观，但是会有以下几个缺点：</p><ol><li>欧拉角表示方式不唯一。由上面分析知道当yaw、pitch、roll的顺序变换后，会有不同的组合可以达到同样的效果。</li><li>万向锁问题。</li></ol><blockquote><p>万向锁问题：因为<strong>飞行器的朝向即为x轴的方向</strong>，所以欧拉角三个轴是一直在变的。比如在yaw-pitch-roll这种顺序的欧拉角姿态调整中，在中间pitch俯仰角度调整为90度时，当前的x轴会与初始的z轴重合，即接下来进行roll的角度调整时其实与第一次yaw角度调整是在同一个轴（初始的z轴）上进行的，这使得系统平白丢失了一个自由度（进行了三次旋转，但是其实两次旋转就可以完成）。</p></blockquote><h2 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h2><p>其实在计算坐标变换时，我们使用最多的表示旋转的方式是其实旋转矩阵。三维空间中的旋转矩阵是<strong>3×3</strong>的矩阵，将欧拉角变换为旋转矩阵的计算方式如下：</p><p>$$<br>\begin{array}{rlr}{R(\alpha, \beta, \gamma)} &amp; {=R_{z}(\alpha) R_{y}(\beta) R_{x}(\gamma)=} \\ {} &amp; {\left(\begin{array}{cc}{\cos \alpha \cos \beta} &amp; {\cos \alpha \sin \beta \sin \gamma-\sin \alpha \cos \gamma} &amp; {\cos \alpha \sin \beta \cos \gamma+\sin \alpha \sin \gamma} \\ {\sin \alpha \cos \beta} &amp; {\sin \alpha \sin \beta \sin \gamma+\cos \alpha \cos \gamma} &amp; {\sin \alpha \sin \beta \cos \gamma-\cos \alpha \sin \gamma} \\ {-\sin \beta} &amp; {\cos \beta \sin \gamma} &amp; {\cos \beta \cos \gamma}\end{array}\right)}\end{array}<br>$$</p><p>$$<br>R_{z}(\alpha)=\left(\begin{array}{ccc}{\cos \alpha} &amp; {-\sin \alpha} &amp; {0} \\ {\sin \alpha} &amp; {\cos \alpha} &amp; {0} \\ {0} &amp; {0} &amp; {1}\end{array}\right)<br>$$</p><p>$$<br>R_{y}(\beta)=\left(\begin{array}{ccc}{\cos \beta} &amp; {0} &amp; {\sin \beta} \\ {0} &amp; {1} &amp; {0} \\ {-\sin \beta} &amp; {0} &amp; {\cos \beta}\end{array}\right)<br>$$</p><p>$$<br>R_{x}(\gamma)=\left(\begin{array}{ccc}{1} &amp; {0} &amp; {0} \\ {0} &amp; {\cos \gamma} &amp; {-\sin \gamma} \\ {0} &amp; {\sin \gamma} &amp; {\cos \gamma}\end{array}\right)<br>$$</p><p>其中，$\alpha$、$\beta$、$\gamma$分别是欧拉角的yaw、pitch和roll角。上述结果是三个旋转矩阵（三个角度上的旋转）连续相乘的结果。</p><p>由上，我们可以看出，如果yaw、pitch和roll的顺序发生改变，矩阵相乘的顺序需要作出相应改变，所得的旋转矩阵的结果也会发生变化。</p><blockquote><p>旋转矩阵虽然有9个元素，但是其实只有三个自由度，所以旋转矩阵各行各列之间一定是互相正交的，同时因为旋转矩阵的不包含尺度变换，因此旋转矩阵一定要是正交矩阵（逆矩阵等于转置矩阵）</p></blockquote><p>此外，其实旋转矩阵也叫作<strong>方向余弦矩阵（Direction Cosine Matrix）</strong>，简称DCM，这种表示叫法在陀螺力学领域较为常用。DCM的名字来历其实是用欧拉角之外的另一种用三个角度值表示三维旋转的方式。这种表示方法原理是：假设刚体在起始朝向时三个坐标轴的向量为$I,J,K$，而刚体在目标朝向时的三个坐标轴的向量为$i,j,k$，则该旋转可以通过三个坐标轴分别与原始坐标轴的夹角表示，如下图所示：</p><div style="text-align: center"><img src="/img/rotation/dcm.png"/></div><p>DCM可以通过三个夹角的余弦计算得到：</p><div style="text-align: center"><img src="/img/rotation/dcm_cal.png"/></div><blockquote><p>DCM就是旋转矩阵。</p></blockquote><h2 id="旋转向量"><a href="#旋转向量" class="headerlink" title="旋转向量"></a>旋转向量</h2><p>旋转向量是使用三维向量的形式来表示旋转。三维空间中的任意一个旋转，都是可以<strong>用绕三维空间中的某个轴旋转过某个角度（轴角表示）</strong>来表示，这就是所谓的$Axis-Angle$表示方法。这种表示方法中，轴$Axis$可以使用一个三维单位向量$(x,y,z)$来表示，$Angle$可以使用一个角度值$\theta$来表示。所以，客观来说，<strong>一个四维向量$(\theta, x, y, z)$就可以表示出三维空间任意的旋转。</strong>但是其实可以使用更紧凑的表示方式–旋转向量$(\theta \ast x, \theta \ast y, \theta \ast z)$来表示三维空间中的任意旋转。</p><blockquote><p>旋转向量$(\theta \ast x, \theta \ast y, \theta \ast z)$的来源是轴角表示。它与旋转矩阵的转换可以通过指数映射与罗德里格斯公式完成。</p></blockquote><h2 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h2><p>旋转矩阵的表示具有冗余性（使用9个量表示3个自由度的旋转），欧拉角和旋转向量是紧凑的，但是具有奇异性。所以，此处我们会再介绍一种常用的表示旋转的方式，<strong>四元数（Quaternion）</strong>。</p><p>四元数使用复数的形式来表示旋转</p><p>$$<br>\boldsymbol{q}=q_{0}+q_{1} i+q_{2} j+q_{3} k<br>$$</p><p>其中$i,j,k$是四元数的三个虚部。这三个虚部满足关系式：</p><p>$$<br>\left\{\begin{array}{l}{i^{2}=j^{2}=k^{2}=-1} \\ {i j=k, j i=-k} \\ {j k=i, k j=-i} \\ {k i=j, i k=-j}\end{array}\right.<br>$$</p><p>所以，也可以使用一个标量与一个向量来表示四元数：</p><p>$$<br>\boldsymbol{q}=[s, \boldsymbol{v}], \quad s=q_{0} \in \mathbb{R}, \boldsymbol{v}=\left[q_{1}, q_{2}, q_{3}\right]^{T} \in \mathbb{R}^{3}<br>$$</p><blockquote><p>同时，我们一般使用<strong>单位四元数</strong>来表示三维空间中任意一个旋转。对于绕单位向量$\boldsymbol{n}=\left[n_{x}, n_{y}, n_{z}\right]^{T}$进行了角度为$\theta$的旋转，这个旋转的四元数形式为：</p></blockquote><p>$$<br>\boldsymbol{q}=\left[\cos \frac{\theta}{2}, n_{x} \sin \frac{\theta}{2}, n_{y} \sin \frac{\theta}{2}, n_{z} \sin \frac{\theta}{2}\right]^{T}<br>$$</p><blockquote><p>此处需要说明的是，对于旋转的角度$\theta$，我们将其加上$2 \pi$，得到的四元数$q$会变为$-q$，所以，四元数有一个性质，<strong>任意旋转可以使用两个互为相反数的四元数来表示。</strong>并且从上面这个公式，我们也可以看出，<strong>使用单位四元数可以表示任意一个旋转</strong>。</p></blockquote><p>并且，对于一个旋转角度为0的旋转，表示它的四元数是：</p><p>$$<br>\boldsymbol{q}_{0}=[ \pm 1,0,0,0]^{T}<br>$$</p><p>反之，从四元数中恢复出轴角可以使用如下：</p><p>$$<br>\left\{\begin{array}{l}{\theta=2 \arccos q_{0}} \\ {\left[n_{x}, n_{y}, n_{z}\right]^{T}=\left[q_{1}, q_{2}, q_{3}\right]^{T} / \sin \frac{\theta}{2}}\end{array}\right.<br>$$</p><blockquote><p>之所以四元数会这么受欢迎（虽然它很不直观），是因为它有一些神奇的性质。</p></blockquote><h3 id="四元数的神奇1"><a href="#四元数的神奇1" class="headerlink" title="四元数的神奇1"></a>四元数的神奇1</h3><p>第一个，我们使用四元数对一个三维点$\boldsymbol{p}=[x, y, z] \in \mathbb{R}^{3}$进行旋转变换（旋转由一个轴角$\boldsymbol{n}, \theta$指定）。此时，首先将三维空间点用一个虚四元数来描述：</p><p>$$<br>\boldsymbol{p}=[0, x, y, z]=[0, \boldsymbol{v}]<br>$$</p><p>这相当于<strong>我们把四元数的三个虚部与空间中的三个轴相对应</strong>。然后用四元数$q$来表示这个旋转：</p><p>$$<br>\boldsymbol{q}=\left[\cos \frac{\theta}{2}, \boldsymbol{n} \sin \frac{\theta}{2}\right]<br>$$</p><p>那么旋转后的点$p^{\prime}$可以表示为如下的乘积：</p><p>$$<br>\boldsymbol{p}^{\prime}=\boldsymbol{q} \boldsymbol{p} \boldsymbol{q}^{-1}<br>$$</p><blockquote><p>最后的计算结果的实部一定为0，所以是纯虚四元数表示一个空间点位置。</p></blockquote><h3 id="四元数的神奇2-乘法"><a href="#四元数的神奇2-乘法" class="headerlink" title="四元数的神奇2(乘法)"></a>四元数的神奇2(乘法)</h3><p>首先四元数的复数形式是：</p><p>$$<br>\boldsymbol{q}=q_{0}+q_{1} i+q_{2} j+q_{3} k<br>$$</p><p>对于两个四元数</p><p>$$\mathbf{q}<em>{1}=\left(\begin{array}{llll}{a</em>{1}} &amp; {b_{1}} &amp; {c_{1}} &amp; {d_{1}}\end{array}\right)^{T} $$ </p><p>$$\mathbf{q}<em>{2}=\left(\begin{array}{llll}{a</em>{2}} &amp; {b_{2}} &amp; {c_{2}} &amp; {d_{2}}\end{array}\right)^{T}$$</p><p>他们的乘积为（不可交换）就是两个复数想成的结果：</p><p>$$<br>\mathbf{q}<em>{1} \mathbf{q}</em>{2}=\left(\begin{array}{c}{a_{1} a_{2}-b_{1} b_{2}-c_{1} c_{2}-d_{1} d_{2}} \\ {a_{1} b_{2}+b_{1} a_{2}+c_{1} d_{2}-d_{1} c_{2}} \\ {a_{1} c_{2}-b_{1} d_{2}+c_{1} a_{2}+d_{1} b_{2}} \\ {a_{1} d_{2}+b_{1} c_{2}-c_{1} b_{2}+d_{1} a_{2}}\end{array}\right)<br>$$</p><blockquote><p>之所以介绍，四元数的乘法，是因为，对于两次旋转的叠加，是可以直接使用四元数的乘法实现。</p></blockquote><p>并且，从上面的乘法，我们也可以看出，对于四元数来说，对应单位矩阵的四元数是（1,0,0,0），同时<strong>四元数的逆其实就等于四元数的共轭</strong>。</p><h3 id="四元数相对时间的导数"><a href="#四元数相对时间的导数" class="headerlink" title="四元数相对时间的导数"></a>四元数相对时间的导数</h3><p>首先，先介绍一个四元数关于轴角的表示（上面也有讲过）：</p><p>$$<br>\boldsymbol{q}=\left[\cos \frac{\theta}{2}, \boldsymbol{n} \sin \frac{\theta}{2}\right]<br>$$</p><p>所以这样，在角度接近0时（时间变化很小时近似角度为0），四元数近似为$[1,  \Delta \phi_{\mathcal{L}} ]$。</p><p>$$<br>\begin{aligned} \dot{\mathbf{q}} &amp; \triangleq \lim <em>{\Delta t \rightarrow 0} \frac{\mathbf{q}(t+\Delta t)-\mathbf{q}(t)}{\Delta t} \\ &amp;=\lim _{\Delta t \rightarrow 0} \frac{\mathbf{q} \otimes \Delta \mathbf{q}</em>{\mathcal{L}}-\mathbf{q}}{\Delta t} \\ &amp;=\lim <em>{\Delta t \rightarrow 0} \frac{\mathbf{q} \otimes\left(\left[\begin{array}{c}{1} \\ {\Delta \boldsymbol{\phi}</em>{\mathcal{L}} / 2}\end{array}\right]-\left[\begin{array}{l}{1} \\ {\mathbf{0}}\end{array}\right]\right)}{\Delta t} \\ &amp;=\lim <em>{\Delta t \rightarrow 0} \frac{\mathbf{q}(t+\Delta t)-\mathbf{q}(t)}{\Delta t} \=&amp; \frac{1}{2} \mathbf{q} \otimes\left[\begin{array}{c}{0} \\ {\boldsymbol{\omega}</em>{\mathcal{L}}}\end{array}\right] \end{aligned}<br>$$</p><p>上式中：</p><p>$$<br>\omega_{\mathcal{L}}(t) \triangleq \frac{d \phi_{\mathcal{L}}(t)}{d t} \triangleq \lim <em>{\Delta t \rightarrow 0} \frac{\Delta \phi</em>{\mathcal{L}}}{\Delta t}<br>$$</p><p>是旋转向量对时间的导数，可以理解为角速度向量</p><h2 id="使用Eigen库"><a href="#使用Eigen库" class="headerlink" title="使用Eigen库"></a>使用Eigen库</h2><p>Eigen库是一个开源的c++线性代数库，提供了快速的有关矩阵的线性代数运算，还包括解方程的功能。同时它还提供了几何模块，可以表示旋转的多种表示方式，包括上面提到的旋转矩阵、旋转向量、四元数等等。</p><ul><li><p><a href="https://github.com/xhy3054/myslam/blob/master/01-prepared/02-3d-motion/useEigen/eigenMatrix.cpp">Eigen的基本矩阵类型与线性代数功能演示</a></p></li><li><p><a href="https://github.com/xhy3054/myslam/tree/master/01-prepared/02-3d-motion/useGeometry">Eigen的几何模块的使用，包括各种旋转表示的互相转换等</a></p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a href="http://www.chrobotics.com/library/understanding-quaternions">http://www.chrobotics.com/library/understanding-quaternions</a></p><p>[2] <a href="https://blog.csdn.net/zhuquan945/article/details/72784274">https://blog.csdn.net/zhuquan945/article/details/72784274</a></p><p>[3] 视觉slam十四讲</p>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动驾驶系统描述</title>
    <link href="/2019/05/30/2019-05-30-auto-drive/"/>
    <url>/2019/05/30/2019-05-30-auto-drive/</url>
    
    <content type="html"><![CDATA[<p>虽然很多人都说自动驾驶是坑，，，但是我就是喜欢在坑里玩泥巴。入坑也有一段时间了，今天主要将要填这个坑需要做的工作总结一下。</p><h1 id="自动驾驶"><a href="#自动驾驶" class="headerlink" title="自动驾驶"></a>自动驾驶</h1><p>一些有的没得今天就不扯了，毕竟历史、事件、定义之类的经常看，经常忘。</p><p>我理解的自动驾驶系统是是由两部分组成的：<strong>感知与决策</strong>。本文主要从这两个大方向入手，对其麾下的一些不可或缺的功能模块进行描述。</p><h2 id="1-感知系统"><a href="#1-感知系统" class="headerlink" title="1. 感知系统"></a>1. 感知系统</h2><blockquote><p>我将感知问题分为两部分，第一是<strong>对世界的感知与理解</strong>，第二个就是<strong>对自身的感知与理解</strong>。</p></blockquote><p>不过这样将有些过于抽象，实际在自动驾驶中我们并不会那么泾渭分明的完成它们，甚至我们更多的是完成的第一部分，第二部分很多往往是预设的东西。一般我们通过实现以下一些功能模块来完成自动驾驶中的感知问题。</p><h3 id="1-1-定位"><a href="#1-1-定位" class="headerlink" title="1.1 定位"></a>1.1 定位</h3><p>定位模块解决的问题就是弄清楚自己在哪里，具体化的说就是估计出汽车相对于地图的位姿（位置与姿态）。</p><blockquote><p>其实光定位的话方法有很多，各种slam，里程计还有全局定位的GPS等。但是目前来看这些方法没有一种是完美的，都会有自己的缺点。目前在自动驾驶领域还好解决一点，因为<strong>全局的GPS搭配局部的slam算法</strong>可以比较好的完成任务。但是对室内机器人来说，由于GPS一般不可用，所以全局定位的问题有些尴尬，具体的场景就是机器人启动时相对地图的全局定位与动态环境下的可靠定位问题。</p></blockquote><h3 id="1-2-静态物体建图"><a href="#1-2-静态物体建图" class="headerlink" title="1.2 静态物体建图"></a>1.2 静态物体建图</h3><p>其实静态建图模块与定位在一定程度上来说是很多模块（比如定位）的基础。而且地图也分为局部地图与全局地图两部分。</p><blockquote><p>其实建图的问题，现在的解决方案也还不是很成熟（可能我见识浅薄）。sfm建立的地图往往是给人看的，但是机器并不能理解。而机器用的稀疏点地图和稠密地图虽然比较实用了，但是功能也有限，语义地图听起来高大上，但是具体形式很值得讨论。毕竟，如果我们建立的地图是给机器人看的话，就需要考虑机器人究竟能从中获得什么。</p></blockquote><h3 id="1-3-动态目标跟踪"><a href="#1-3-动态目标跟踪" class="headerlink" title="1.3 动态目标跟踪"></a>1.3 动态目标跟踪</h3><p>对于动态物体，我们最好不要将它放入地图中，就算放入也要放入可以随时更新的局部地图。由于在行驶过程中动态物体本身的运动是我们需要考虑的因素，因此动态目标检测与跟踪模块必不可少。</p><h3 id="1-4-交通信号检测与识别"><a href="#1-4-交通信号检测与识别" class="headerlink" title="1.4 交通信号检测与识别"></a>1.4 交通信号检测与识别</h3><p>这个模块本质是一种<strong>交通工具之间的交互行为模块</strong>，也许以后随着交通工具之间交互方式的改变，也许这个模块的具体形式也会随之改变。</p><h2 id="2-决策系统"><a href="#2-决策系统" class="headerlink" title="2. 决策系统"></a>2. 决策系统</h2><p>好的，既然已经对于外在的内在的情况有了一定的认知，接下来就是我们<strong>发挥主观能动性达成目的</strong>的时候了。</p><p>在自动驾驶中的决策系统我觉得主要由以下部分组成。</p><h3 id="2-1-路线规划"><a href="#2-1-路线规划" class="headerlink" title="2.1 路线规划"></a>2.1 路线规划</h3><p>（全局）路线规划模块负责规划出一条穿过道路网的路线，让自动驾驶汽车能从起始位置到达终点位置。这部分的工作本质是一个图搜索问题，算法已经比较成熟了，比较有代表性的有$A*$等。</p><blockquote><p>所以路线规划输出的已经可以保持汽车一直在一条路线上，下面需要做的就是如何在这条路线上行驶的更好了。</p></blockquote><h3 id="2-2-行为决策"><a href="#2-2-行为决策" class="headerlink" title="2.2 行为决策"></a>2.2 行为决策</h3><p>当全局路线规划算法规划出了路线后，下面的工作就是沿着这条路线进行行驶。为了使得行驶行为更加的智能，一般我们会在这里设置一个<strong>行为决策层</strong>。这一层的主要任务是：依据感知系统对周围环境环境的实时观测结果，做出最明智的驾驶行为。比如超车、变道、停车等。</p><h3 id="2-3-运动规划"><a href="#2-3-运动规划" class="headerlink" title="2.3 运动规划"></a>2.3 运动规划</h3><p>运动规划层是控制系统中比较底层的模块，它的任务是依据行为决策层决策出来的行为，对局部的路线进行规划，并生成对汽车的控制信息。</p><h1 id="关于实现自动驾驶的讨论"><a href="#关于实现自动驾驶的讨论" class="headerlink" title="关于实现自动驾驶的讨论"></a>关于实现自动驾驶的讨论</h1><p>上面我们讲述了自动驾驶系统中的各个环节，这也叫做$rule-based$的自动驾驶系统。最近其实学界还有另外一种自动驾驶的实现方式。它们的考量是目前$rule-based$的方法完全是基于人类对环境的理解进行的研究，而实际上实现这一工作是机器做的。并且目前的人工智能技术其实和人的感知抽象方式关系不大。所以既然机器看到的世界和人是不一样的，那么为什么不设计一个端到端的神经系统来完成这个任务呢。$end-to-end$方式的做法是设计一个深度神经网络，输入是图片数据，输出是对汽车的控制信息，这样的一个系统中内部特征参数是自动调整的，我们人并不能理解，但是机器可以。</p><h2 id="rule-based方式"><a href="#rule-based方式" class="headerlink" title="rule-based方式"></a>rule-based方式</h2><p>优点：</p><ul><li><p>可解释性强</p></li><li><p>各个模块功能明确，有利于定点提升性能</p></li><li><p>比较容易集成新的功能模块，比如车联网模块等</p></li></ul><p>缺点：</p><ul><li><p>按照人的理解来设计机器的感知决策体系，可能有些设计比较臃肿并且低效</p></li><li><p>目前技术限制，机器智能与人类智能从本质上完全不一样。</p></li></ul><h2 id="end-to-end方式"><a href="#end-to-end方式" class="headerlink" title="end-to-end方式"></a>end-to-end方式</h2><p>优点：</p><ul><li>端到端一步到位，自动调整也许可以抓住最适合机器的特征</li></ul><p>缺点：</p><ul><li><p>可解释性弱</p></li><li><p>不利于新模块的集成</p></li><li><p>自动驾驶中很多行为并没有最优解，具有随意性</p></li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1>]]></content>
    
    
    
    <tags>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ros操作系统入门</title>
    <link href="/2019/05/25/2019-05-25-ros/"/>
    <url>/2019/05/25/2019-05-25-ros/</url>
    
    <content type="html"><![CDATA[<p>很长时间没有用ros了，刚好这几天手头有一台闲置的$turtlebot$，于是就想用它验证一些导航算法。重新看ros的官网教程，写的很好，但是每一节讲的东西很少，而我这里网速不快，每次打开新的网页都要等一会，超级费时间，所以写篇博客将ros的常用操作概括归纳一些，以后忘记了方便查阅。</p><h1 id="ros"><a href="#ros" class="headerlink" title="ros"></a>ros</h1><p>ROS是一个用于开发机器人应用程序的、类似操作系统的机器人软件平台。ROS提供开发机器人应用程序时所需的硬件抽象、子设备控制，以及机器人工程中广泛使用的传感、识别、绘图、运动规划等功能。此外ROS还提供进程之间的消息解析、功能包管理、库和丰富的开发及调试工具。</p><p>ros是一种分布式机器人操作系统，依赖于$linux$（一般支持的linux系统有$ubuntu$系列与$debian$系列），由斯坦福发布，目前，很多机器人的研究都是基于它。其基本框架如下：</p><div style="text-align: center"><img src="/img/ros/kuangjia.PNG"/></div><blockquote><p>上图是一个在机器人上跑起来的ros的整体框架图，下面我的介绍会依次从 安装、环境配置、文件系统、通信机制、基础实践 来展开。</p></blockquote><h2 id="在Ubuntu16-04上安装ros"><a href="#在Ubuntu16-04上安装ros" class="headerlink" title="在Ubuntu16.04上安装ros"></a>在Ubuntu16.04上安装ros</h2><p>$ros$有很多的版本，一般都是和$linux$系统的版本绑定的，在$Ubuntu16.04$上，我们可以安装的是$kinetic$版本。安装过程可以按照<a href="http://wiki.ros.org/kinetic/Installation/Ubuntu">官网教程</a>进行，建议直接安装$desktop-full$版。</p><p>安装完毕记得照着教程初始化$rosdep$、设置环境、安装一些用于构建包的依赖。</p><h2 id="ros的环境管理"><a href="#ros的环境管理" class="headerlink" title="ros的环境管理"></a>ros的环境管理</h2><p>在$ros$安装完毕后，我们会将<code>source /opt/ros/kinetic/etc/ros</code>写入到<code>~/.bashrc</code>中，这样每次打开终端，会自动设置$ros$相关的环境变量。</p><p>同时，通常除了系统的环境变量外，我们基于$ros$的开发通常是以工作空间为单位的，不同的工作空间的运行环境可能是有区别的，因此此时我们需要导入这个工作空间的环境变量，使用<code>source ws/devel/setup.bash</code>。在这个工作空间中我们也可以新建开发一些功能包。</p><blockquote><p>可以理解为ros的每个工作空间为一个项目，工作空间中存在的每一个包代表着该项目需要的一个功能模块。</p></blockquote><h2 id="ros文件系统"><a href="#ros文件系统" class="headerlink" title="ros文件系统"></a>ros文件系统</h2><p>ros文件系统主要指的是在硬盘上ROS源代码的组织形式。主要有包（package）、元包（meta package）、工作空间（workspace）等概念。</p><h3 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h3><blockquote><p>通常工作空间是我们开发某个项目的地方，在这里我们会新开发出一些专用的包来共我们当前的这个项目或应用（node）使用。如下，每个工作空间可以就是一个文件夹，该文件夹中必须存在一个src文件夹，然后使用<code>catkin_make</code>即可对工作空间进行初始化，或者编译。</p></blockquote><ul><li>创建一个名叫<code>catkin_ws</code>的工作空间<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p ~/catkin_ws/src<br><span class="hljs-built_in">cd</span> ~/catkin_ws<br>catkin_make<br><span class="hljs-built_in">source</span> /devel/setup.bash<br></code></pre></td></tr></table></figure></li></ul><hr><div style="text-align: center"><img src="/img/ros/file.PNG"   width="800" height="350"/></div><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><blockquote><p><strong>功能包（package）</strong>是构成一个ROS项目的基本单元。ROS应用程序是以功能包为单位开发的。功能包包括至少一个以上的节点或拥有用于运行其他功能包的节点的配置文件。它还包含功能包所需的所有文件，如用于运行各种进程的ROS依赖库、数据集和配置文件等。</p></blockquote><ul><li>在工作空间中创建包<code>new_package</code>，依赖于包<code>depend_p1</code>与<code>depend_p2</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_ws/src<br>catkin_create_pkg new_package depend_p1 depend_p2 <br></code></pre></td></tr></table></figure></li></ul><hr><ul><li><p>查看一个包的直接依赖<code>rospack depends1 new_packsge</code></p></li><li><p>查看一个包的所有依赖（包括直接与间接）<code>rospack depends new_package</code></p></li><li><p>编译包，直接编译整个工作空间就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_ws<br>catkin_make<br></code></pre></td></tr></table></figure></li></ul><hr><blockquote><p><strong>元功能包（metapackage）</strong>是一个具有共同目的的功能包的集合。例如，导航元功能包包含AMCL、DWA、EKF和map_server等10余个功能包。其实元功能包在功能上已经是一个应用了，但是我们还是需要将其放入工作空间的src文件夹下，这样才构成一个可以编译的项目。</p></blockquote><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li><p>查找ros包<code>roscpp</code>:<code>rospack find roscpp</code></p></li><li><p>进入ros文件系统的某个目录下：<code>roscd 包名称/子目录</code></p></li><li><p>查看ros包的保存路径：<code>echo $ROS_PACKAGE_PATH</code>，结果应该为ros系统目录下的包路径与你当前的工作空间的ros包路径，比如：<code>/home/xhy/catkin_ws/src:/opt/ros/kinetic/share</code></p></li><li><p>罗列ros文件系统某个目录：<code>rosls 包名称/子目录</code></p></li><li><p>ros命令行工具支持<code>tab</code>自动补全功能</p></li><li><p>使用<code>rosed</code>快速编辑指定文件(默认编辑器是vim)：<code>rosed [package_name] [filename]</code>,例如<code>rosed roscpp Logger.msg</code></p></li></ul><div style="text-align: center"><img src="/img/ros/ros_cmd.PNG"/></div><h2 id="ros节点"><a href="#ros节点" class="headerlink" title="ros节点"></a>ros节点</h2><h3 id="主节点"><a href="#主节点" class="headerlink" title="主节点"></a>主节点</h3><p>主节点（master）负责节点到节点的连接和消息通信，类似于名称服务器（Name Server）。roscore是它的运行命令，当您运行主节点时，可以注册每个节点的名字，并根据需要获取信息。没有主节点，就不能在节点之间建立访问和消息交流（如话题和服务）。</p><p>主节点使用XML远程过程调用（XMLRPC，XML-Remote Procedure Call）3与节点进行通信。XMLRPC是一种基于HTTP的协议，主节点不与连接到主节点的节点保持连接。换句话说，节点只有在需要注册自己的信息或向其他节点发送请求信息时才能访问主节点并获取信息。通常情况下，不检查彼此的连接状态。由于这些特点，ROS可用于非常大而复杂的环境。XMLRPC也非常轻便，支持多种编程语言，使其非常适合支持各种硬件和语言的ROS。</p><p>当启动ROS时，主节点将获取用户设置的<code>ROS_MASTER_URI</code>变量中列出的URI地址和端口。除非另外设置，默认情况下，URI地址使用当前的本地IP，端口使用11311。</p><h3 id="普通节点"><a href="#普通节点" class="headerlink" title="普通节点"></a>普通节点</h3><p>节点（node）是指在ROS中运行的最小处理器单元。可以把它看作一个可执行程序。在ROS中，建议为一个目的创建一个节点，建议设计时注重可重用性。例如，在移动机器人的情况下，为了驱动机器人，将每个程序细分化。也就是说，使用传感器驱动、传感器数据转换、障碍物判断、电机驱动、编码器输入和导航等多个细分节点。</p><p>节点在运行的同时，向主节点注册节点的名称，并且还注册发布者（publisher）、订阅者（subscriber）、服务服务器（service server）、服务客户端（service client）的名称，且注册消息形式、URI地址和端口。基于这些信息，每个节点可以使用话题和服务与其他节点交换消息。</p><p>节点使用XMLRPC与主站进行通信，并使用TCP/IP通信系列的XMLRPC或TCPROS进行节点之间的通信。节点之间的连接请求和响应使用XMLRPC，而消息通信使用TCPROS，因为它是节点和节点之间的直接通信，与主节点无关。URI地址和端口则使用存储于运行当前节点的计算机上的名为<code>ROS_HOSTNAME</code>的环境变量作为URI地址，并将端口设置为任意的固有值。</p><p>ros节点是整个机器人控制系统的一个功能单元，运行起来一个ros节点，即运行一个ros程序包中的一个可执行文件。例如<code>rosrun turtlesim turtle_teleop_key</code></p><blockquote><p>ros系统在启动之前，首先需要运行<code>rosore</code>，我们可以将node看做ros操作系统上的应用软件。</p></blockquote><h3 id="roslaunch"><a href="#roslaunch" class="headerlink" title="roslaunch"></a>roslaunch</h3><p>使用<code>rosrun</code>每次只能启动一个节点，我们可以使用<code>roslaunch</code>来启动定义在$launch$文件中的多个节点。</p><p>用法：<code>roslaunch [package] [filename.launch]</code></p><p>launch文件语法解析，运行如下launch文件会启动两个节点</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;launch&gt;<br><br>  &lt;group ns<span class="hljs-operator">=</span><span class="hljs-string">&quot;turtlesim1&quot;</span>&gt;<br>    &lt;node pkg<span class="hljs-operator">=</span><span class="hljs-string">&quot;turtlesim&quot;</span> name<span class="hljs-operator">=</span><span class="hljs-string">&quot;sim&quot;</span> type<span class="hljs-operator">=</span><span class="hljs-string">&quot;turtlesim_node&quot;</span>/&gt;<br>  &lt;/group&gt;<br><br>  &lt;group ns<span class="hljs-operator">=</span><span class="hljs-string">&quot;turtlesim2&quot;</span>&gt;<br>    &lt;node pkg<span class="hljs-operator">=</span><span class="hljs-string">&quot;turtlesim&quot;</span> name<span class="hljs-operator">=</span><span class="hljs-string">&quot;sim&quot;</span> type<span class="hljs-operator">=</span><span class="hljs-string">&quot;turtlesim_node&quot;</span>/&gt;<br>  &lt;/group&gt;<br><br>  &lt;node pkg<span class="hljs-operator">=</span><span class="hljs-string">&quot;turtlesim&quot;</span> name<span class="hljs-operator">=</span><span class="hljs-string">&quot;mimic&quot;</span> type<span class="hljs-operator">=</span><span class="hljs-string">&quot;mimic&quot;</span>&gt;<br>    &lt;remap from<span class="hljs-operator">=</span><span class="hljs-string">&quot;input&quot;</span> to<span class="hljs-operator">=</span><span class="hljs-string">&quot;turtlesim1/turtle1&quot;</span>/&gt;<br>    &lt;remap from<span class="hljs-operator">=</span><span class="hljs-string">&quot;output&quot;</span> to<span class="hljs-operator">=</span><span class="hljs-string">&quot;turtlesim2/turtle1&quot;</span>/&gt;<br>  &lt;/node&gt;<br><br>&lt;/launch&gt;<br></code></pre></td></tr></table></figure><hr><h2 id="ros通信（计算图级网络形式）"><a href="#ros通信（计算图级网络形式）" class="headerlink" title="ros通信（计算图级网络形式）"></a>ros通信（计算图级网络形式）</h2><p>了解ros的通信主要需要了解以下四个概念：节点（node）、消息（messages）、话题（topic）、服务（service）、动作（action）</p><h3 id="ros消息（msg）"><a href="#ros消息（msg）" class="headerlink" title="ros消息（msg）"></a>ros消息（msg）</h3><p>节点之间通过消息（message）来发送和接收数据。消息是诸如integer、floating point和boolean等类型的变量。用户还可以使用诸如消息里包括消息的简单数据结构或列举消息的消息数组的结构。使用消息的通信方法包括TCPROS，UDPROS等，根据情况使用<strong>单向消息</strong>发送/接收方式的话题（topic）和<strong>双向消息</strong>请求（request）/响应（response）方式的服务（service）。</p><p>$msg$文件就是一个描述$ROS$中所使用消息类型的简单文本。通常$msg$文件存放在$package$的$msg$目录下</p><blockquote><p>ros中在一个包里消息$msg$与服务$srv$的创建教程详细可以查看<a href="http://wiki.ros.org/cn/ROS/Tutorials/CreatingMsgAndSrv">官网教程</a></p></blockquote><h3 id="ros话题（topic）"><a href="#ros话题（topic）" class="headerlink" title="ros话题（topic）"></a>ros话题（topic）</h3><p>ros话题是ros中不同节点之间的一种通信方式，一个节点在一个话题上发布消息，另一个节点订阅该话题以接收该消息。</p><p>我们通常使用rostopic来进行话题的相关操作</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros">rostopic -h<br>rostopic is a command-line<span class="hljs-built_in"> tool </span><span class="hljs-keyword">for</span> printing information about ROS Topics.<br><br>Commands:<br>    rostopic bw display bandwidth used by topic<br>    rostopic delay  display delay of topic <span class="hljs-keyword">from</span> timestamp <span class="hljs-keyword">in</span> header<br>    rostopic echo   <span class="hljs-built_in">print</span> messages <span class="hljs-keyword">to</span><span class="hljs-built_in"> screen</span><br><span class="hljs-built_in"></span>    rostopic <span class="hljs-built_in">find</span>   <span class="hljs-built_in">find</span> topics by<span class="hljs-built_in"> type</span><br><span class="hljs-built_in"></span>    rostopic hz display publishing rate of topic    <br>    rostopic <span class="hljs-built_in">info</span>   <span class="hljs-built_in">print</span> information about active topic<br>    rostopic list   list active topics<br>    rostopic pub    publish data <span class="hljs-keyword">to</span> topic<br>    rostopic<span class="hljs-built_in"> type </span>  <span class="hljs-built_in">print</span> topic <span class="hljs-keyword">or</span> field<span class="hljs-built_in"> type</span><br><span class="hljs-built_in"></span><span class="hljs-built_in"></span><br><span class="hljs-built_in">Type </span>rostopic &lt;command&gt; -h <span class="hljs-keyword">for</span> more detailed usage, e.g. <span class="hljs-string">&#x27;rostopic echo -h&#x27;</span><br><br></code></pre></td></tr></table></figure><hr><blockquote><p>话题（topic）就是“故事”。在发布者（publisher）节点关于故事向主节点注册之后，它以消息形式发布关于该故事的广告。希望接收该故事的订阅者（subscriber）节点获得在主节点中以这个话题注册的那个发布者节点的信息。基于这个信息，订阅者节点直接连接到发布者节点，用话题发送和接收消息。</p></blockquote><h3 id="ros的服务"><a href="#ros的服务" class="headerlink" title="ros的服务"></a>ros的服务</h3><p>服务（service）是ros提供的一种同步双向消息通信。其中服务客户端请求对应于特定目的任务的服务，而服务服务器则负责服务响应。</p><p>使用<code>rosservice</code>可以轻松使用ros客户端、服务器框架提供的服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosservice list         输出可用服务的信息<br>rosservice call         调用带参数的服务<br>rosservice <span class="hljs-built_in">type</span>         输出服务类型<br>rosservice find         依据类型寻找服务find services by service <span class="hljs-built_in">type</span><br>rosservice uri          输出服务的ROSRPC uri<br></code></pre></td></tr></table></figure><hr><blockquote><p>一个$srv$文件描述一项服务。它包含两个部分：请求与响应。一般$srv$文件存放在$package$的$srv$目录下。</p></blockquote><div style="text-align: center"><img src="/img/ros/topic_service.PNG"/></div><h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p>动作（action）是在需要像服务那样的双向请求的情况下使用的消息通信方式，不同点是在处理请求之后需要很长的响应，并且需要中途反馈值。动作文件也非常类似于服务，目标（goal）和结果（result）对应于请求和响应。此外，还添加了对应于中途的反馈（feedback）。它由一个设置动作目标（goal）的动作客户端（action client）和一个动作服务器（action server），动作服务器根据目标执行动作，并发送反馈和结果。</p><blockquote><p>动作客户端与动作服务器之间进行异步双向消息通信。</p></blockquote><h3 id="发布与发布者"><a href="#发布与发布者" class="headerlink" title="发布与发布者"></a>发布与发布者</h3><p>发布（publish）是指以与话题的内容对应的消息的形式发送数据。为了执行发布，发布者（publisher）节点在主节点上注册自己的话题等多种信息，并向希望订阅的订阅者节点发送消息。发布者在节点中声明自己是执行发布的个体。单个节点可以成为多个发布者。</p><h3 id="订阅与订阅者"><a href="#订阅与订阅者" class="headerlink" title="订阅与订阅者"></a>订阅与订阅者</h3><p>订阅是指以与话题内容对应的消息的形式接收数据。为了执行订阅，订阅者节点在主节点上注册自己的话题等多种信息，并从主节点接收那些发布此节点要订阅的话题的发布者节点的信息。基于这个信息，订阅者节点直接联系发布者节点来接收消息。订阅者在节点中声明自己执行订阅的个体。单个节点可以成为多个订阅者。</p><blockquote><p>发布和订阅概念中的<strong>话题是异步的</strong>，这是一种根据需要发送和接收数据的好方法。另外，由于它通过一次的连接，发送和接收连续的消息，所以它经常被用于必须连续发送消息的传感器数据。然而，在某些情况下，需要一种共同使用请求和响应的同步消息交换方案。因此，ROS提供叫做<strong>服务（service）的消息同步方法</strong>。服务分为响应请求的服务服务器和请求后接收响应的服务客户端。与话题不同，<strong>服务是一次性的消息通信</strong>。当服务的请求和响应完成时，两个节点的连接被断开。</p></blockquote><blockquote><p>发布者、订阅者、服务服务器、服务客户端、动作服务器和动作客户端都存在于不同的节点中，这些节点需要连接才能进行消息通信。这时候，主节点是帮助节点之间的连接。主节点就像节点名称、话题和服务、动作名称、URI地址和端口以及参数们的名称服务器。换句话说，节点同时向主节点注册自己的信息，并从主节点获取其他节点希望通过主节点访问的节点的信息。然后，节点和节点直接连接进行消息通信。</p></blockquote><h2 id="ros中的参数"><a href="#ros中的参数" class="headerlink" title="ros中的参数"></a>ros中的参数</h2><p>ros中还存在参数服务器（由主节点维护），上面存储一些服务的参数设置，参数可以看作是节点中使用的全局变量。可以使用<code>rosparam</code>进行如下操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">rosparam <span class="hljs-built_in">set</span>            设置参数<br>rosparam get            获取参数<br>rosparam load           从文件读取参数<br>rosparam dump           向文件中写入参数<br>rosparam delete         删除参数<br>rosparam list           列出参数名<br></code></pre></td></tr></table></figure><hr><h2 id="ros基础案例"><a href="#ros基础案例" class="headerlink" title="ros基础案例"></a>ros基础案例</h2><ul><li><p><a href="http://wiki.ros.org/cn/ROS/Tutorials/WritingPublisherSubscriber%28c%2B%2B%29">编写消息发布器与订阅器c++版本</a></p></li><li><p><a href="http://wiki.ros.org/cn/ROS/Tutorials/WritingPublisherSubscriber%28python%29">编写消息发布器与订阅器python版本</a></p></li><li><p><a href="http://wiki.ros.org/cn/ROS/Tutorials/WritingServiceClient%28c%2B%2B%29">编写简单的服务器与客户端c++版本</a></p></li><li><p><a href="http://wiki.ros.org/cn/ROS/Tutorials/WritingServiceClient%28python%29">编写简单的服务器与客户端python版本</a></p></li><li><p><a href="http://wiki.ros.org/cn/ROS/Tutorials/ExaminingServiceClient">验证流程可以查看这里，python节点无需编译，直接运行脚本即可</a></p></li><li><p><a href="http://wiki.ros.org/cn/ROS/Tutorials/Recording%20and%20playing%20back%20data">录制话题数据，通过bag文件</a>   </p></li></ul><blockquote><p><a href="https://github.com/xhy3054/catkin_ws">我的教程工作空间</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇博客主要是对ros的整体概念进行介绍，并且介绍了ros官网基础教程中我个人认为最值得介绍的点。至此，ros的入门算是基本完成了，接下来就是需要使用仿真或者实战对ros进行进一步的操作与体验了。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1]. <a href="http://wiki.ros.org/cn/ROS/Tutorials">http://wiki.ros.org/cn/ROS/Tutorials</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>视觉slam中的一种单目稠密建图方法</title>
    <link href="/2019/05/17/2019-05-17-slam-map/"/>
    <url>/2019/05/17/2019-05-17-slam-map/</url>
    
    <content type="html"><![CDATA[<p>slam是中文全名是同时定位与建图，但是大家更多关注的都是slam的定位作用，而对于建图，也许是因为三维重现、sfm之类的研究方向已经很多了，所以在slam大家对其的关注小了很多。本文主要就是简单讲解一下slam中进行单目稠密建图的一个思路。</p><blockquote><p>之所以只讲单目的稠密建图，这是因为，<strong>首先</strong>，对于RGBD图，我们已知所有点的深度，可以直接生成稠密的点云，可讲的东西不多(其实还是很多的，但我现在了解的还不多)。<strong>其次</strong>，对于稀疏地图，其实很多VO中已经完成了稀疏地图的构建，但是稀疏地图只能用于定位，不能用于导航避障之类的工作。所以很多slam系统中会额外进行稠密地图、甚至语义地图的构建。</p></blockquote><div style="text-align: center"><img src="/img/map/map.PNG"   width="750" height="350"/></div><h1 id="单目稠密建图"><a href="#单目稠密建图" class="headerlink" title="单目稠密建图"></a>单目稠密建图</h1><p>通常在单目VO中，我们通过特征点匹配与三角测量可以获得稀疏地图点的深度，现在我们想要建立稠密的地图，这意味着我们需要获得图片中所有像素点的深度。那么首先我们需要做的一点就是确定第一幅图的某个像素出现在其他图中的位置。此时我们当然可以遍历所有的像素点，然后计算所有像素点的描述子，然后在另一幅图片中寻找与其匹配的点。但是，这种方法先不说效果如何，光想想每一幅图像我们需要计算与匹配的特征描述子数量就够吓人的了。所以这种方法应该是不可取的。</p><blockquote><p>针对这个问题，一种比较有效的方法是使用<strong>极线搜索</strong>与<strong>块匹配</strong>技术。</p></blockquote><h2 id="极线搜索与块匹配"><a href="#极线搜索与块匹配" class="headerlink" title="极线搜索与块匹配"></a>极线搜索与块匹配</h2><p>首先，在slam中建图，我们是可以使用前端的测量结果的，所以我们知道每一帧的相机位姿，也就是相机的外参，根据相机的外参与内参，我们可以将基准帧上的一点$p$（我们也称该点为种子）投影到当前帧的一条射线上，这条线也叫做<strong>极线</strong>（具体原理可以参考<a href="https://xhy3054.github.io/epipolar-geometry/">对极几何</a>）。所以我们想找的点就在这条极线上，而在极线上确定这个点的过程就叫做<strong>极线搜索</strong>。</p><div style="text-align: center"><img src="/img/map/line.PNG"   width="750" height="650"/></div><blockquote><p>只要知道了两帧之间的相对位姿就可以确定极线，不过如果还知道点的初始深度，此时还可以缩小找匹配时的搜索量。</p></blockquote><p>确定极线的方法有很多，我们在这里介绍一种$svo$中确定极线的方法：</p><ol><li><p>在种子$p(x,y)$的深度延长线上，构造两个三维点$P_{1}$与$P_{2}$，这两个三维点来源自同一个像素，只是确定它们的深度不同。在深度滤波器中一般是设置为<code>P1(x,y,z-n*sigma)</code>与<code>P2(x,y,z+n*sigma)</code>，其中$z$是种子的初始深度，$sigma$是深度的方差，$n$可以调节成不同的值，比如$1,2,3…$等，一般取$3$。</p></li><li><p>将$P_{1}$与$P_{2}$利用帧间位姿，投影到当前帧，投影点为$u_{1}$与$u_{2}$，连接$u_{1}$与$u_{2}$就是我们所要的极线（此处是一个线段）</p></li></ol><h3 id="块匹配"><a href="#块匹配" class="headerlink" title="块匹配"></a>块匹配</h3><p>其实极线搜索我们一般都是采用了<strong>块匹配</strong>的方式。所谓的块匹配就是说对于极线上的一个点，我们判断它与参考点的相关性，是通过在点周围取一个$w \times w$的小块，然后在基线上也取很多同样大小的小块进行比较。比较的方法有很多，主要是衡量两个小块的相似性。</p><p>此处，我们假设对于一个像素点$p_{1}$，我们将其周围的小块记成$\boldsymbol{A} \in \mathbb{R}^{w \times w}$，把极线上的每个点的小块记为$\boldsymbol{B}_{i}, i=1, \dots, n$。那么，下列方法都可以用来计算小块之间的差异。</p><ul><li>SAD(Sum of Absolute Difference)。取两个小块的差的绝对值之和（这个结果越大，说明越不匹配，越接近0，块的相似度越高）：</li></ul><p>$$<br>S(\boldsymbol{A}, \boldsymbol{B})<em>{S A D}=\sum</em>{i, j}|\boldsymbol{A}(i, j)-\boldsymbol{B}(i, j)|<br>$$</p><ul><li>SSD(Sum of Squared Distance)。即取两个小块的差的平方和（这个结果越大，说明越不匹配，越接近0，块的相似度越高）：</li></ul><p>$$<br>S(\boldsymbol{A}, \boldsymbol{B})<em>{S S D}=\sum</em>{i, j}(\boldsymbol{A}(i, j)-\boldsymbol{B}(i, j))^{2}<br>$$</p><ul><li>NCC(Normalized Cross Correlation)。即计算两个小块的归一化互相关（这个结果越大，说明相似度越高，0时代表完全不相关）：</li></ul><p>$$<br>S(\boldsymbol{A}, \boldsymbol{B})<em>{N C C}=\frac{\sum</em>{i, j} \boldsymbol{A}(i, j) \boldsymbol{B}(i, j)}{\sqrt{\sum_{i, j} \boldsymbol{A}(i, j)^{2} \sum_{i, j} \boldsymbol{B}(i, j)^{2}}}<br>$$</p><blockquote><p>上述三种方法是比较常见的三种方法，现实中我们使用的方法可能要更复杂一点，比如在$svo$中使用的是$ZMSSD$对$8 \times 8$的矩形$patch$计算相似性，与此同时，通常我们在计算小块的差异之前，还需要做一些预处理操作，比如去均值（减小亮度影响）、根据参考帧与当前帧间的运动首先将块进行对应的仿射变换再进行匹配等。</p></blockquote><h2 id="深度滤波器"><a href="#深度滤波器" class="headerlink" title="深度滤波器"></a>深度滤波器</h2><p>在使用极线搜索与块匹配确定了匹配的像素之后，使用<a href="https://xhy3054.github.io/triangulation/">三角测量</a>便可以确定出该点的深度。但是我们知道，测量出来的像素也许是有噪声的，所以单次测量出来的深度其实是一个不确定值，我们可以假设它服从一种概率分布（lsd中假设为高斯分布），通过对于多帧不断的进行上述操作，我们可以尝试对测量出来的深度进行优化。这样，如何估计每个像素点的深度就变成了一个状态估计的问题，此时会存在滤波器与非线性优化两种求解的思路。</p><p>我们当然可以直接构造非线性最小二乘，然后使用非线性优化的方法进行求解，但是要知道我们是对整幅图像的所有像素进行深度估计，这样做计算量会很大，因此很多稠密建图的工作都是使用滤波器的方法更新深度，其中$LSD$使用的是卡尔曼滤波器，$SVO$提出了一种深度滤波器的方法。有时间会详细介绍这种方法。</p><h2 id="常见问题与改进"><a href="#常见问题与改进" class="headerlink" title="常见问题与改进"></a>常见问题与改进</h2><ul><li>使用块匹配的方法很依赖图像环境，比如梯度明显的小块可能比较好区分，梯度不明显的像素容易引起误匹配。</li></ul><div style="text-align: center"><img src="/img/map/gradient.PNG"   width="750" height="600"/></div><ul><li><p>在深度滤波器中假设深度满足高斯分布其实是不合理的，因为深度通常不像是高斯分布是一个对称的分布，而是一边短（因为深度不会小于相机焦距，近似0），一边长（深度可以是很深甚至无穷远）,所以我们可以采用<strong>逆深度</strong>的概念，即假设深度的倒数（即将$d$改为$d^{-1}$）为高斯分布，这样会得到更好的结果。</p></li><li><p>假设相机发生了旋转，那么块的相似性很难保持（比如上黑下白的图像库旋转会变成上白下黑）,所以我们需要计算<strong>仿射矩阵</strong>（通过三点法确定），通过仿射矩阵将基准帧中的块$A$里的像素坐标逐一映射到当前帧中，这样映射的所有坐标就组成了块$B$。</p></li><li><p>由上面的介绍，我们会发现对每个像素的深度估计的过程都是相同但是独立的，因此我们可以<strong>并行的</strong>处理他们。GPU编程会比较适合。</p></li><li><p>使用<strong>统计滤波器</strong>去除孤立点。（统计每个点与它最近的N个点的距离值分布，去除距离均值过大的点）</p></li><li><p>使用<strong>体素滤波器</strong>去除重叠点。因为我们重建是基于很多图片，不可避免一个点可能在好多图片都观察到了，此时体素滤波器保证在某一个一定大小的立方体（也叫体素）内仅有一个点，相当于对三维空间进行了降采样，从而节省存储空间。体素滤波器可以根据不同的需求设置不同的<strong>分辨率</strong></p></li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1] 视觉slam十四讲</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>视觉slam中的回环检测概述</title>
    <link href="/2019/05/14/2019-05-14-loop-closing/"/>
    <url>/2019/05/14/2019-05-14-loop-closing/</url>
    
    <content type="html"><![CDATA[<p>在slam中，前端负责提供轨迹与地图的初值，后端负责对轨迹与地图进行优化。在小范围的环境中，前端与后端便已经够用了。但是当活动的范围增加以后，这一类只依靠内部传感器（相机、imu等）的定位方法不可避免的会出现<strong>累积误差</strong>，这时因为虽然我们可以使用ba等优化方式进行优化，但是这种优化方式毕竟还是局部的（比如某一个位姿下会有大部分的地图点是看不到的）。</p><h1 id="回环检测"><a href="#回环检测" class="headerlink" title="回环检测"></a>回环检测</h1><h2 id="回环检测与累积误差"><a href="#回环检测与累积误差" class="headerlink" title="回环检测与累积误差"></a>回环检测与累积误差</h2><p>拿视觉slam来说，虽然对于当前位姿的估计我会使用ba进行优化，但是这个ba一般是基于局部地图的优化，首先必然会存在误差（ba只是尽量减小它），然后以后某一时刻的位姿会依赖此处的位姿结果进行估计，于是累积误差就出现了。</p><p>一般累积误差最常见的是位姿的累积误差，在单目视觉中，还会出现尺度的累积误差。</p><p>针对上述的累积误差问题，我们可以使用回环检测来修正。一般回环检测的步骤如下：</p><ol><li><p>检测到回环的发生</p></li><li><p>计算回环侯选帧与当前帧的运动</p></li><li><p>验证回环是否成立</p></li><li><p>闭环</p></li></ol><blockquote><p>回环检测可以修正累积误差，并且在各种图优化模型中，加入回环的约束可以有效的提高优化结果的精度。</p></blockquote><h2 id="检测回环"><a href="#检测回环" class="headerlink" title="检测回环"></a>检测回环</h2><p>检测回环的方法很多。朴素的方法：</p><ol><li><p>最简单的方法是对任意两幅图像都做一遍特征匹配，根据正确匹配的数量确定哪两幅图像存在关联。这种方法朴素但是有效，缺点是任意两幅图像做特征匹配，计算量实在太大，因此不实用。</p></li><li><p>随机抽取历史数据进行回环检测，比如在$n$帧中随机抽5帧与当前帧比较。时间效率提高很多，但是抽到回环几率不高，也就是检测效率不高。</p></li></ol><p>系统的方法：</p><ol><li><p>基于里程计几何关系的方法</p><ul><li>大概思路是当我们发现当前相机运动到之前的某个位置附近时，检测他们是否存在回环</li><li>缺点：由于累积误差，很难确定运动到了之前某个位置</li></ul></li><li><p>基于外观的方法</p><ul><li>仅仅依靠两幅图像的相似性确定回环</li><li>核心问题是<strong>如何计算图像的相似性</strong>。</li><li>这个问题可以看成一个二分类问题，并且slam特性要求这个分类准确率必须要高，召回率可以相对低一点。</li></ul></li></ol><blockquote><p>目前最广泛使用并且最有效的方法是基于外观的一种方法，<a href="https://xhy3054.github.io/bow/">使用词袋模型进行回环检测</a></p></blockquote><h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><h3 id="相似性评分的处理"><a href="#相似性评分的处理" class="headerlink" title="相似性评分的处理"></a>相似性评分的处理</h3><p>使用词袋模型，对于任意两张图片我们都可以给出一个相似性评分，但是有些环境本身就很相似，比如每间办公室中的桌椅可能款式一样，使得任意两幅图像之间的相似度都挺高的。考虑这种情况，我们通常会取一个<strong>先验相似度</strong> $s\left(\boldsymbol{v}<em>{t}, \boldsymbol{v}</em>{t-\Delta t}\right)$，它表示某一时刻关键帧图像与上一时刻关键帧的相似性。然后其他的分之都参照这个值进行归一化：</p><p>$<br>s\left(\boldsymbol{v}<em>{t}, \boldsymbol{v}</em>{t_{j}}\right)^{\prime}&#x3D;s\left(\boldsymbol{v}<em>{t}, \boldsymbol{v}</em>{t_{j}}\right) &#x2F; s\left(\boldsymbol{v}<em>{t}, \boldsymbol{v}</em>{t-\Delta t}\right)<br>$</p><blockquote><p>一般我们会假设，如果当前帧与之前某关键帧的相似度超过当前帧与上一个关键帧相似度的$3$倍，我们才会认为可能存在回环。这样处理可以<strong>避免引入绝对的相似性阈值</strong>。</p></blockquote><h2 id="关键帧的处理"><a href="#关键帧的处理" class="headerlink" title="关键帧的处理"></a>关键帧的处理</h2><p>由于上面采用的相似性评分方式，如果我们在选取关键帧时选的很近，会使得两个相邻关键帧之间相似性太高，这样历史中的回环会很难检测出来。所以<strong>用于回环检测的关键帧最后是稀疏一些，彼此不太相同，同时又能涵盖整个环境。</strong></p><h2 id="回环聚类"><a href="#回环聚类" class="headerlink" title="回环聚类"></a>回环聚类</h2><p>如果我们的机器人将第$1$帧与第$n$帧检测出了回环，那么很有可能接下来的第$n+1$帧、第$n+2$帧都会和第$1$帧构成回环。但是确认第$1$帧与第$n$帧的回环对整个轨迹优化帮助很大，接下来的第$n+1$帧与第1帧的回环帮助就没那么大了。因为我们之前已经消除了累积误差，更多的回环带来的帮助不会更大。此时，我们<strong>通常把相近的回环聚成一类，使得算法不要检测同一类的回环。</strong></p><h2 id="回环检测后的验证"><a href="#回环检测后的验证" class="headerlink" title="回环检测后的验证"></a>回环检测后的验证</h2><p>使用词袋的回环检测完全依赖外观，因此会出现由于外观相似而出现的错误检测（比如酒店里布置完全一样的两件客房）。所以在回环检测后，我们会进行验证。</p><p>验证方法很多，比如</p><ol><li><p><strong>时间一致性检测</strong>。设立回环的缓存机制，认为单次检测到的回环不足以构成良好的约束，而是在一段时间内一直检测到的回环才是正确的回环。</p></li><li><p><strong>空间一致性检测</strong>。对回环检测到的两帧进行特征匹配，估计相机运动。再将运动放到之前的位姿图中检测是否出入过大。</p></li></ol><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>词袋模型，本身是一种非监督的机器学习过程（基于树结构的聚类，数结构加速查找）。而回环检测本身是一个分类问题，只是这个分类问题是一种稠密的分类，分类类别近似于连续变量。</p><p>由于目前基于词袋模型的物体识别已经明显不如神经网络了，而回环检测又是意向相似的问题，之后这部分的工作也许可以尝试使用深度学习来替换。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1] 视觉slam十四讲</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bundle Adjustment等优化方法在视觉slam中的应用与求解</title>
    <link href="/2019/05/07/2019-05-07-bundle-adjustment-solve/"/>
    <url>/2019/05/07/2019-05-07-bundle-adjustment-solve/</url>
    
    <content type="html"><![CDATA[<p>在视觉slam与sfm中，BA是很常见的参数优化方法。它的全名是 Bundle Adjustment，中文翻译有捆集调整、光束法平差等。</p><blockquote><p>BA的主要思想是<strong>最小化重投影误差</strong>，以其作为目标函数来优化位姿、地图点、相机参数等。</p></blockquote><h1 id="计算投影点"><a href="#计算投影点" class="headerlink" title="计算投影点"></a>计算投影点</h1><p>根据以前的两篇博客<a href="https://xhy3054.github.io/camerca-module/">相机成像模型</a>与<a href="https://xhy3054.github.io/camera-calibration-undistort/">相机畸变与标定</a>，我们可以知道将一个地图点投影到像素平面上流程如下：</p><ul><li><p>首先，世界坐标系下有一个固定的点P，<strong>世界坐标</strong>是 $P_{w}$</p></li><li><p>获得点P的<strong>相机坐标系坐标</strong>，可以利用相机外参R与t得到 $ P_{c} = RP_{w} + t $</p></li><li><p>在2中获得的 $P_c$ 仍然是三维的 (X,Y,Z) ，将其投影到归一化平面 $Z=1$ 上，得到<strong>归一化相机坐标</strong>：$ P_{C} = [X/Z, Y/Z, 1]^T $</p></li><li><p>此处加入<strong>畸变</strong>因素，畸变公式如下(其中，$x=X/Z, y=Y/Z$)：</p></li></ul><p>$$ x_{distorted} = x( 1 + k_{1} r^2 + k_{2} r^4 + k_{3} r^6) + [ 2p_{1}xy + p_{2}(r^2+2x^2)]  \\ y_{distorted} = y( 1 + k_{1} r^2 + k_{2} r^4 + k_{3} r^6) + [ p_{1}(r^2+ 2y^2)+ 2p_{2}xy]   $$</p><ul><li>最后一步，利用内参K，将归一化相机坐标转换成<strong>像素坐标</strong>： $ P_{uv} = KP_{distorted} $</li></ul><p>$$ u = f_{x} x_{distorted} + c_{x} \\ v = f_{y} y_{distorted} + c_{y}  $$</p><blockquote><p>上述过程就是前面<a href="https://xhy3054.github.io/state-estimation-nonlinear-least-square/">状态估计之非线性最小二乘</a>中提到的<strong>观测方程</strong>。之前我们抽象的将其记作$z = h(x, y)$。</p></blockquote><h1 id="BA的目标函数"><a href="#BA的目标函数" class="headerlink" title="BA的目标函数"></a>BA的目标函数</h1><p>在BA中，待优化的变量有相机的位姿$x$，即外参$R,t$，它对应的李代数为$\xi$；地图点y的三维坐标$p$。而观测数据是像素坐标$\boldsymbol{z} \triangleq\left[u, v\right]^{T}$。所以每次观测方程的误差是</p><p>$$<br>e=z-h(\xi, p)<br>$$</p><p>我们将不同时刻对不同地图点的观测都考虑进来，比如$$\boldsymbol{z}<em>{i j}$$为在位姿$$\boldsymbol{\xi}</em>{i}$$处观察地图点$$\boldsymbol{p}_{j}$$产生的数据，那么整体的<strong>目标函数</strong>为：</p><p>$$<br>\frac{1}{2} \sum_{i=1}^{m} \sum_{j=1}^{n}\left|\boldsymbol{e}<em>{i j}\right|^{2}=\frac{1}{2} \sum</em>{i=1}^{m} \sum_{j=1}^{n}\left|\boldsymbol{z}<em>{i j}-h\left(\boldsymbol{\xi}</em>{i}, \boldsymbol{p}_{j}\right)\right|^{2}<br>$$</p><blockquote><p>BA的任务就是求解这个最小二乘问题。</p></blockquote><h1 id="BA的求解"><a href="#BA的求解" class="headerlink" title="BA的求解"></a>BA的求解</h1><p>由上面我们知道我们需要求解的是一个非线性优化问题，很自然的我们想到高斯牛顿等方法。使用这些方法，我们首先将所有待优化的变量组织成一个向量$x$，这个向量便是目标函数的自变量：</p><p>$$<br>\boldsymbol{x}=\left[\boldsymbol{\xi}<em>{1}, \ldots, \boldsymbol{\xi}</em>{m}, \boldsymbol{p}<em>{1}, \ldots, \boldsymbol{p}</em>{n}\right]^{T}<br>$$</p><p>我们每次迭代时都需要寻找一个$$\Delta \boldsymbol{x}$$，它是自变量的迭代增量。利用高斯牛顿的原理，我们为自变量添加一个增量时，目标函数变为：</p><p>$$<br>\frac{1}{2}|f(\boldsymbol{x}+\Delta \boldsymbol{x})|^{2} \approx \frac{1}{2} \sum_{i=1}^{m} \sum_{j=1}^{n}\left|\boldsymbol{e}<em>{i j}+\boldsymbol{F}</em>{i j} \Delta \boldsymbol{\xi}<em>{i}+\boldsymbol{E}</em>{i j} \Delta \boldsymbol{p}_{j}\right|^{2}<br>$$</p><p>其中$$\boldsymbol{F}<em>{i j}$$表示j地图点投影到i时刻相机像素平面投影残差对i时刻相机姿态的偏导数，而$\boldsymbol{E}</em>{i,j}$表示j地图点投影到i时刻相机像素平面上的投影残差对j地图点的三维世界坐标的偏导数。</p><p>我们将相机位姿变量放在一起：</p><p>$$<br>\boldsymbol{x}<em>{c}=\left[\boldsymbol{\xi}</em>{1}, \boldsymbol{\xi}<em>{2}, \ldots, \boldsymbol{\xi}</em>{m}\right]^{T} \in \mathbb{R}^{6 m}<br>$$</p><p>将地图点三维坐标变量放在一起：</p><p>$$<br>\boldsymbol{x}<em>{p}=\left[\boldsymbol{p}</em>{1}, \boldsymbol{p}<em>{2}, \ldots, \boldsymbol{p}</em>{n}\right]^{T} \in \mathbb{R}^{3 n}<br>$$</p><p>然后使用大矩阵表示矩阵简化上面公式</p><p>$$<br>\frac{1}{2}|f(\boldsymbol{x}+\Delta \boldsymbol{x})|^{2}=\frac{1}{2}\left|\boldsymbol{e}+\boldsymbol{F} \Delta \boldsymbol{x}<em>{c}+\boldsymbol{E} \Delta \boldsymbol{x}</em>{p}\right|^{2}<br>$$</p><p>此处我们将原本由很多小型二次项之和的形式变成了一个更整体的样子。此处$E$与$F$是整体目标函数对整体变量的导数，他们是比较大的偏导数矩阵，其中有很多项是0。</p><h2 id="使用高斯牛顿进行求解"><a href="#使用高斯牛顿进行求解" class="headerlink" title="使用高斯牛顿进行求解"></a>使用高斯牛顿进行求解</h2><p>上面已经将投影误差进行了泰勒一阶展开，此时不论是使用高斯牛顿还是LM方法对其进行优化，都需要求解一个方程</p><p>$$<br>\boldsymbol{H} \Delta \boldsymbol{x}=\boldsymbol{g}<br>$$</p><p>如果使用$GN$法，则$H$取$\boldsymbol{J}^{T} \boldsymbol{J}$；如果使用$LM$法，则$H$取$\boldsymbol{J}^{T} \boldsymbol{J}+\lambda \boldsymbol{I}$。不管哪种方法，其中$J$都是</p><p>$$<br>J=[\begin{array}{cc} \boldsymbol{F} &amp; \boldsymbol{E} \end{array}]<br>$$</p><p>如果是高斯牛顿，则$H$矩阵为</p><p>$$<br>\boldsymbol{H}=\boldsymbol{J}^{T} \boldsymbol{J}=\left[ \begin{array}{cc}{\boldsymbol{F}^{T} \boldsymbol{F}} &amp; {\boldsymbol{F}^{T} \boldsymbol{E}} \\ {\boldsymbol{E}^{T} \boldsymbol{F}} &amp; {\boldsymbol{E}^{T} \boldsymbol{E}}\end{array}\right]<br>$$</p><blockquote><p>其实无论是$GN$还是$LM$方法，我们都需要求上述的$H$矩阵。不过这个矩阵的维度非常大，直接计算很耗时。</p></blockquote><h3 id="H矩阵的稀疏性与边缘化"><a href="#H矩阵的稀疏性与边缘化" class="headerlink" title="H矩阵的稀疏性与边缘化"></a>H矩阵的稀疏性与边缘化</h3><blockquote><p><strong>H矩阵的稀疏性是由该问题的图优化模型的固有属性决定的</strong>。</p></blockquote><p>如下一个图模型，由两个相机位姿节点与六个地图坐标节点组成，总共有八条边。</p><div style="text-align: center"><img src="/img/BA/graph.PNG"   width="750" height="350"/></div><p>对于上述图模型，我们构建目标函数，并求解其$J$与$H$矩阵，会得到如下形式的结果。</p><div style="text-align: center"><img src="/img/BA/jacobian.PNG"   width="750" height="350"/></div><p><strong>对于一条边（一个误差项），只对其关联的节点的偏导数不为0。</strong>图中$H$矩阵的行列维度都是节点的个数，前两行（与前两列）是相机姿态节点的关联关系，后六行（与后六列）是地图点坐标节点的关联关系。图中$J$矩阵的行数是图中边的个数，列数是图中节点的个数，每一行是对每一个误差项（边）求的偏导数向量，每一列可以理解为对应的节点都关联到了哪条边上。</p><div style="text-align: center"><img src="/img/BA/link.PNG"   width="750" height="350"/></div><p>上图中的H矩阵除了对角线上的元素外与图的<strong>邻接矩阵</strong>具有完全一致的结构。由上，我们可以讲H矩阵划分成如下四个部分组成。</p><div style="text-align: center"><img src="/img/BA/Hessa.PNG"   width="500" height="400"/></div><blockquote><p>注意，这个矩阵的独特性质是，<strong>左上角的矩阵$B$与右下角的矩阵$C$是两个对角矩阵，E矩阵如何由图的性质决定。</strong>这种稀疏性是由这种图模型的连接属性决定的，这种图模型有一个特点，<strong>那就是每个相机位姿节点只与地图点节点关联，与其他相机节点不关联（因为没考虑运动方程）这使得$B$是对角矩阵，而地图点节点只与相机节点关联，与其他地图点不关联，这使得$C$是对角矩阵。</strong></p></blockquote><p>这样，对应的增量方程$H \Delta x=g$也就变为</p><p>$$<br>\left[ \begin{array}{cc}{\boldsymbol{B}} &amp; {\boldsymbol{E}} \\ {\boldsymbol{E}^{T}} &amp; {\boldsymbol{C}}\end{array}\right] \left[ \begin{array}{c}{\Delta \boldsymbol{x}<em>{c}} \\ {\Delta \boldsymbol{x}</em>{p}}\end{array}\right]=\left[ \begin{array}{c}{\boldsymbol{v}} \\ {\boldsymbol{w}}\end{array}\right]<br>$$</p><p>我们可以<strong>利用$H$的稀疏性来加速求解这个方程</strong>。有很多方法，在slam中最常用的是：$Schur$消元，也叫作$Marginalization$（边缘化）</p><p>B的维度是相机位姿节点的个数，C的维度是地图点的个数，通常前者远远小于后者。然后对角矩阵求逆的难度远远小于普通矩阵求逆，我们可以对上述方程组进行高斯消元，消去右上角的非对角部分$E$：</p><p>$$<br>\left[ \begin{array}{cc}{\boldsymbol{I}} &amp; {-\boldsymbol{E} \boldsymbol{C}^{-1}} \\ {\mathbf{0}} &amp; {\boldsymbol{I}}\end{array}\right] \left[ \begin{array}{cc}{\boldsymbol{B}} &amp; {\boldsymbol{E}} \\ {\boldsymbol{E}^{T}} &amp; {\boldsymbol{C}}\end{array}\right] \left[ \begin{array}{c}{\Delta \boldsymbol{x}<em>{c}} \\ {\Delta \boldsymbol{x}</em>{p}}\end{array}\right]=\left[ \begin{array}{cc}{\boldsymbol{I}} &amp; {-\boldsymbol{E} C^{-1}} \\ {\mathbf{0}} &amp; {\boldsymbol{I}}\end{array}\right] \left[ \begin{array}{c}{\boldsymbol{v}} \\ {\boldsymbol{w}}\end{array}\right]<br>$$</p><p>整理可得</p><p>$$<br>\left[ \begin{array}{cc}{\boldsymbol{B}-\boldsymbol{E} \boldsymbol{C}^{-1} \boldsymbol{E}^{T}} &amp; {\mathbf{0}} \\ {\boldsymbol{E}^{T}} &amp; {\boldsymbol{C}}\end{array}\right] \left[ \begin{array}{c}{\Delta \boldsymbol{x}<em>{c}} \\ {\Delta \boldsymbol{x}</em>{p}}\end{array}\right]=\left[ \begin{array}{c}{\boldsymbol{v}-\boldsymbol{E} \boldsymbol{C}^{-1} \boldsymbol{w}} \\ {\boldsymbol{w}}\end{array}\right]<br>$$</p><p>这样，第一行方程组就变成与$\Delta x_{p}$无关了，此时我们将其单独拿出来，得到仅关于位姿部分的增量方程</p><p>$$<br>\left[\boldsymbol{B}-\boldsymbol{E} \boldsymbol{C}^{-1} \boldsymbol{E}^{T}\right] \Delta \boldsymbol{x}_{c}=\boldsymbol{v}-\boldsymbol{E} \boldsymbol{C}^{-1} \boldsymbol{w}<br>$$</p><p>这个线性方程组的维度与$B$矩阵一致。求解这个方程的计算量就会远远小于求解原方程了。最后再将这个方程的解$\Delta x_{c}$带入原方程，就可以求解出$\Delta x_{p}$了。<strong>这就是边缘化求解的整个过程</strong>了。</p><p>上述方程左边的系数我们记为$S$，它是有其物理意义的。$S$矩阵的非对角线上的非零矩阵块，表示了该处对应的两个相机位姿节点之间存在共同观测的地图点。如下</p><div style="text-align: center"><img src="/img/BA/schur.PNG"   width="750" height="420"/></div><blockquote><p>上图只列出了前四个相机位姿节点的共视关系，整个方形矩阵是所有相机位姿节点的共视关系。</p></blockquote><h3 id="Schur-消元的优势"><a href="#Schur-消元的优势" class="headerlink" title="$Schur$消元的优势"></a>$Schur$消元的优势</h3><ol><li><p>在消元过程中，由于$C$为对角块，所以$C^{-1}$容易求解</p></li><li><p>求解了$\Delta x_{c}$之后，路标部分的增量方程可以通过$$\Delta \boldsymbol{x}<em>{p}=\boldsymbol{C}^{-1}\left(\boldsymbol{w}-\boldsymbol{E}^{T} \Delta \boldsymbol{x}</em>{c}\right)$$求得。这也用到了$C^{-1}$易于求解的特性。</p></li><li><p>我们发现上面的消元过程其实不需要$B$矩阵是对角矩阵，即考虑运动方程也可以。</p></li><li><p>不一定非要只消元地图点，也可以反过来消元相机位姿节点，选择比较有效的做法即可。</p></li></ol><h2 id="BA中的核函数"><a href="#BA中的核函数" class="headerlink" title="BA中的核函数"></a>BA中的核函数</h2><p>在上面的分析中，我们使用误差项的二范数平方和作为目标函数，这种做法会使得如果出现误匹配之类的情况，错误边对整体优化的影响会很大，因为错误边的误差的二范数平方增长太快了。</p><p>此时我们可以使用一些核函数来代替二范数平方的操作，使得误差的增长不是那么快，同时可以保证自己的光滑性质。我们也叫它们<strong>鲁棒核函数</strong>。</p><p>一种常见的核函数是$Huber$核：</p><p>$$<br>H(e)=\left\{\begin{array}{ll}{\frac{1}{2} e^{2}} &amp; {\text { if }|e| \leq \delta} \\ {\delta\left(|e|-\frac{1}{2} \delta\right)} &amp; {\text { otherwise }}\end{array}\right.<br>$$</p><blockquote><p>还有一些其他的核函数，比如$Cauchy$核、$Tukey$核等等，在$g2o$与$Ceres$等优化库中都有提供。</p></blockquote><h2 id="工程实例"><a href="#工程实例" class="headerlink" title="工程实例"></a>工程实例</h2><ol><li><p><a href="">使用g2o求解BA</a></p></li><li><p><a href="">使用ceres求解BA</a></p></li></ol><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="pose-graph的优化"><a href="#pose-graph的优化" class="headerlink" title="pose graph的优化"></a>pose graph的优化</h2><blockquote><p>通常在slam的后端优化中，在经过几轮的ba迭代后（几轮观测后），地图点的位置便已经近乎固定了，此时如果继续在新的相机帧进来后进行全局的ba优化，会有些浪费计算资源。</p></blockquote><p>此时，我们一般倾向于只优化相机位姿节点，即构建一个只由pose组成的图，并对其进行优化，这就叫做<strong>位姿图(pose graph)的优化</strong>，具体推导过程与ba类似，计算雅克比什么的，可以自行翻阅资料。</p><h2 id="因子图优化"><a href="#因子图优化" class="headerlink" title="因子图优化"></a>因子图优化</h2><blockquote><p><strong>因子图</strong>是基于概率图（主要是贝叶斯网络）的图优化。</p></blockquote><p>因子图是一种无向图，节点有两种，一种是需要优化的<strong>变量节点</strong>（比如slam中的位姿与路标），一种是不需要优化的<strong>因子节点</strong>（比如slam中的观测与输入）。因子图与普通的图优化都是最小二乘问题，并且稀疏性也类似。</p><p>因子图比较特殊的地方在于，其可以<strong>增量式</strong>的处理后端优化。比如，在<strong>里程计的因子图优化</strong>中，当新的节点与边被加入到图中时，我们只需要考虑最后一个与之相连的节点，可以近似的认为早先节点的估计值不发生变换（其实还是会有影响的，不过相比于最近的节点而言很小），因此可以节省很多计算量，<strong>每次新加节点时，没必要对整个图进行优化</strong>。</p><blockquote><p>需要注意的一点是，如果图中包含回环检测的部分，那么受影响的范围应该是当前回环上的所有节点，也就是这部分回环的轨迹都需要进行调整。</p></blockquote><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1]. 视觉slam十四讲</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态估计之卡尔曼滤波</title>
    <link href="/2019/05/06/2019-05-06-state-estimation-filter/"/>
    <url>/2019/05/06/2019-05-06-state-estimation-filter/</url>
    
    <content type="html"><![CDATA[<p>本文主要介绍如何使用滤波器(卡尔曼滤波器与扩展卡尔曼滤波器)进行状态估计。</p><h1 id="状态估计问题"><a href="#状态估计问题" class="headerlink" title="状态估计问题"></a>状态估计问题</h1><p>首先列出状态估计方程，由运动方程与观测方程组成</p><p>$$<br>\left{\begin{array}{l}{\boldsymbol{x}<em>{k}&#x3D;f\left(\boldsymbol{x}</em>{k-1}, \boldsymbol{u}<em>{k}\right)+\boldsymbol{w}</em>{k}} \ {\boldsymbol{z}<em>{k}&#x3D;h\left(\boldsymbol{x}</em>{k}\right)+\boldsymbol{\upsilon}_{k}}\end{array}\right. \quad k&#x3D;1, \ldots, N<br>$$</p><p>其中</p><ul><li>$x_{k}$   是相机在k时刻的位姿，我们一般可以使用变换矩阵或者其李代数表示它。</li><li>$u_{k}$   是k时刻系统的输入（在slam中通常是运动传感器的读数）</li><li>$w_{k}$   是运动过程中的噪声</li><li>$z_{k}$   是指在$x_k$处进行了一次观测得到的观测值</li><li>${\upsilon}_{k}$  是观测过程中的噪声</li></ul><h1 id="贝叶斯法则"><a href="#贝叶斯法则" class="headerlink" title="贝叶斯法则"></a>贝叶斯法则</h1><p>对于上述状态估计问题，我们想做的是估计出现在状态的分布</p><p>$$<br>P\left(\boldsymbol{x}<em>{k} | \boldsymbol{x}</em>{0}, \boldsymbol{u}<em>{1 : k}, \boldsymbol{z}</em>{1 : k}\right)<br>$$</p><p>按照贝叶斯法则，我们可以有如下结论</p><p>$$<br>P\left(\boldsymbol{x}<em>{k} | \boldsymbol{x}</em>{0}, \boldsymbol{u}<em>{1 : k}, \boldsymbol{z}</em>{1 : k}\right) \propto P\left(\boldsymbol{z}<em>{k} | \boldsymbol{x}</em>{k}\right) P\left(\boldsymbol{x}<em>{k} | \boldsymbol{x}</em>{0}, \boldsymbol{u}<em>{1 : k}, \boldsymbol{z}</em>{1 : k-1}\right)<br>$$</p><p>其中左边是<strong>后验</strong>概率分布（k时刻状态已经发生），右边第一项是<strong>似然</strong>概率分布（即根据运动方程计算得到），第二项是<strong>先验</strong>概率分布（k时刻状态还没发生）。</p><h1 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h1><h2 id="原理推导"><a href="#原理推导" class="headerlink" title="原理推导"></a>原理推导</h2><p>要使用卡尔曼滤波方法对上述后验概率分布进行估计，我们首先需要两条假设</p><ol><li>上述系统满足<strong>马尔可夫性</strong>，当前状态只与前一状态有关</li><li>系统是<strong>线性高斯</strong>系统，高斯分布经过线性变换仍然是高斯分布</li></ol><p>满足上述假设的状态估计问题可以重写为</p><p>$$<br>\left{\begin{array}{l}{\boldsymbol{x}<em>{k}&#x3D;\boldsymbol{A}</em>{k} \boldsymbol{x}<em>{k-1}+\boldsymbol{u}</em>{k}+\boldsymbol{w}<em>{k}} \ {\boldsymbol{z}</em>{k}&#x3D;\boldsymbol{C}<em>{k} \boldsymbol{x}</em>{k}+\boldsymbol{v}_{k}}\end{array}\right. \quad k&#x3D;1, \ldots, N<br>$$</p><p>其中第一个为运动方程，第二个为测量方程，并且<strong>所有的状态与噪声均满足高斯分布</strong>。这里噪声满足如下零均值高斯分布</p><p>$$<br>\boldsymbol{w}<em>{k} \sim N(\mathbf{0}, \boldsymbol{R}) . \quad \boldsymbol{v}</em>{k} \sim N(\mathbf{0}, \boldsymbol{Q})<br>$$</p><p>由于马尔科夫性，假设我们已经有了$k-1$时刻状态的<strong>后验概率分布</strong>：均值 $$\hat{x}<em>{k-1}$$ 与协方差 $$\hat{P}</em>{k-1}$$ ，现在需要做的是<strong>根据k时刻的输入与观测数据，确定$x_{k}$的后验概率分布</strong>。</p><blockquote><p>此处需要先声明，对于噪声的协方差R与Q，为了方便我们省略了他们的下标。而我们用尖帽子表示后验，横线表示先验。</p></blockquote><p>卡尔曼滤波的<strong>第一步</strong>是依据运动方程确定$x_{k}$的先验概率分布。如下</p><p>$$<br>P\left(\boldsymbol{x}<em>{k} | \boldsymbol{x}</em>{0}, \boldsymbol{u}<em>{1 : k}, \boldsymbol{z}</em>{1 : k-1}\right)&#x3D;N\left(\boldsymbol{A}<em>{k} \hat{\boldsymbol{x}}</em>{k-1}+\boldsymbol{u}<em>{k}, \boldsymbol{A}</em>{k} \hat{\boldsymbol{P}}<em>{k-1} \boldsymbol{A}</em>{k}^{T}+\boldsymbol{R}\right)<br>$$</p><p>其中，利用线性高斯系统的性质（其实就是<strong>根据上述运动方程</strong>），我们得到$x_{k}$的先验分布也是高斯分布，并且均值与方差如下：</p><p>$$<br>\overline{\boldsymbol{x}}<em>{k}&#x3D;\boldsymbol{A}</em>{k} \hat{\boldsymbol{x}}<em>{k-1}+\boldsymbol{u}</em>{k}, \quad \overline{\boldsymbol{P}}<em>{k}&#x3D;\boldsymbol{A}</em>{k} \hat{\boldsymbol{P}}<em>{k-1} \boldsymbol{A}</em>{k}^{T}+\boldsymbol{R}<br>$$</p><p><strong>下一步，我们由观测方程得到似然分布</strong><br>$$<br>P\left(\boldsymbol{z}<em>{k} | \boldsymbol{x}</em>{k}\right)&#x3D;N\left(\boldsymbol{C}<em>{k} \boldsymbol{x}</em>{k}, \boldsymbol{Q}\right)<br>$$</p><p><strong>然后</strong>，由贝叶斯法则我们知道，后验概率分布与似然分布和先验概率分布的乘积成正比，即</p><p>$$<br>N\left(\hat{\boldsymbol{x}}<em>{k}, \hat{\boldsymbol{P}}</em>{k}\right) \propto N\left(\boldsymbol{C}<em>{k} \boldsymbol{x}</em>{k}, \boldsymbol{Q}\right) \cdot N\left(\overline{\boldsymbol{x}}<em>{k}, \overline{\boldsymbol{P}}</em>{k}\right)<br>$$</p><p><strong>因为上述三个分布都是高斯分布，上述等式两侧又成正比，所以我们无需关系高斯分布系数部分内容，只需要保证等式两侧指数部分是相等的即可</strong>。即得到下式</p><p>$$<br>\left(\boldsymbol{x}<em>{k}-\hat{\boldsymbol{x}}</em>{k}\right)^{T} \hat{\boldsymbol{P}}<em>{k}^{-1}\left(\boldsymbol{x}</em>{k}-\hat{\boldsymbol{x}}<em>{k}\right)&#x3D;\left(\boldsymbol{z}</em>{k}-\boldsymbol{C}<em>{k} \boldsymbol{x}</em>{k}\right)^{T} \boldsymbol{Q}^{-1}\left(\boldsymbol{z}<em>{k}-\boldsymbol{C}</em>{k} \boldsymbol{x}<em>{k}\right)+\left(\boldsymbol{x}</em>{k}-\overline{\boldsymbol{x}}<em>{k}\right)^{T} \boldsymbol{P}</em>{k}^{-1}\left(\boldsymbol{x}<em>{k}-\overline{\boldsymbol{x}}</em>{k}\right)<br>$$</p><p>为了保证上面等式成立，我们将两边展开，另$x_{k}$的二次系数与一次系数两边相等。对于<strong>二次系数</strong>，我们得到</p><p>$$<br>\hat{\boldsymbol{P}}<em>{k}^{-1}&#x3D;\boldsymbol{C}</em>{k}^{T} \boldsymbol{Q}^{-1} \boldsymbol{C}<em>{k}+\overline{\boldsymbol{P}}</em>{k}^{-1}<br>$$</p><p>这个等式给出了$x_{k}$分布的协方差的计算过程，此处另$$ \boldsymbol{K}&#x3D;\hat{\boldsymbol{P}}<em>{k} \boldsymbol{C}</em>{k}^{T} \boldsymbol{Q}^{-1} $$，并将上式左右同时乘以$$\hat{P}_{k}$$，有</p><p>$$<br>\boldsymbol{I}&#x3D;\hat{\boldsymbol{P}}<em>{k} \boldsymbol{C}</em>{k}^{T} \boldsymbol{Q}^{-1} \boldsymbol{C}<em>{k}+\hat{\boldsymbol{P}}</em>{k} \overline{\boldsymbol{P}}<em>{k}^{-1}&#x3D;\boldsymbol{K} \boldsymbol{C}</em>{k}+\hat{\boldsymbol{P}}<em>{k} \overline{\boldsymbol{P}}</em>{k}^{-1}<br>$$</p><p>于是，我们得到卡尔曼滤波中$$\hat{P}_{k}$$的更新公式</p><p>$$<br>\hat{\boldsymbol{P}}<em>{k}&#x3D;\left(\boldsymbol{I}-\boldsymbol{K} \boldsymbol{C}</em>{k}\right) \overline{\boldsymbol{P}}_{k}<br>$$</p><p>其中，K的更新公式是</p><p>$$<br>\boldsymbol{K}&#x3D;\overline{\boldsymbol{P}}<em>{k} \boldsymbol{C}</em>{k}^{T}\left(\boldsymbol{C}<em>{k} \overline{\boldsymbol{P}}</em>{k} \boldsymbol{C}_{k}^{T}+\boldsymbol{Q}\right)^{-1}<br>$$</p><p>同样，由<strong>一次项系数</strong>相同可以得到</p><p>$$<br>-2 \hat{\boldsymbol{x}}<em>{k}^{T} \hat{\boldsymbol{P}}</em>{k}^{-1} \boldsymbol{x}<em>{k}&#x3D;-2 \boldsymbol{z}</em>{k}^{T} \boldsymbol{Q}^{-1} \boldsymbol{C}<em>{k} \boldsymbol{x}</em>{k}-2 \overline{\boldsymbol{x}}<em>{k}^{T} \overline{\boldsymbol{P}}</em>{k}^{-1} \boldsymbol{x}_{k}<br>$$</p><p>整理可得卡尔曼滤波中$\hat{x}_{k}$的更新公式</p><p>$$<br>\begin{aligned} \hat{\boldsymbol{x}}<em>{k} &amp;&#x3D;\hat{\boldsymbol{P}}</em>{k} \boldsymbol{C}<em>{k}^{T} \boldsymbol{Q}^{-1} \boldsymbol{z}</em>{k}+\hat{\boldsymbol{P}}<em>{k} \overline{\boldsymbol{P}}</em>{k}^{-1} \overline{\boldsymbol{x}}<em>{k} \ &amp;&#x3D;\boldsymbol{K} \boldsymbol{z}</em>{k}+\left(\boldsymbol{I}-\boldsymbol{K} \boldsymbol{C}<em>{k}\right) \overline{\boldsymbol{x}}</em>{k} \ &amp;&#x3D;\overline{\boldsymbol{x}}<em>{k}+\boldsymbol{K}\left(\boldsymbol{z}</em>{k}-\boldsymbol{C}<em>{k} \overline{\boldsymbol{x}}</em>{k}\right) \end{aligned}<br>$$</p><h2 id="卡尔曼滤波实现步骤归纳"><a href="#卡尔曼滤波实现步骤归纳" class="headerlink" title="卡尔曼滤波实现步骤归纳"></a>卡尔曼滤波实现步骤归纳</h2><p>首先再将问题列出来（运动方程与测量方程）：<br>$$<br>\left{\begin{array}{l}{\boldsymbol{x}<em>{k}&#x3D;\boldsymbol{A}</em>{k} \boldsymbol{x}<em>{k-1}+\boldsymbol{u}</em>{k}+\boldsymbol{w}<em>{k}} \ {\boldsymbol{z}</em>{k}&#x3D;\boldsymbol{C}<em>{k} \boldsymbol{x}</em>{k}+\boldsymbol{v}<em>{k}}\end{array}\right. \quad k&#x3D;1, \ldots, N<br>$$<br>其中$u_k$为系统输入，两个方程噪声均按照高斯白噪声处理：<br>$$<br>\boldsymbol{w}</em>{k} \sim N(\mathbf{0}, \boldsymbol{R}) . \quad \boldsymbol{v}_{k} \sim N(\mathbf{0}, \boldsymbol{Q})<br>$$<br>由上面推导，我们可以将卡尔曼滤波归纳成如下<strong>预测</strong>与<strong>更新</strong>两个步骤：</p><ul><li><strong>预测</strong>（根据运动方程更新先验）：</li></ul><p>$$<br>\overline{\boldsymbol{x}}<em>{k}&#x3D;\boldsymbol{A}</em>{k} \hat{\boldsymbol{x}}<em>{k-1}+\boldsymbol{u}</em>{k}, \quad \overline{\boldsymbol{P}}<em>{k}&#x3D;\boldsymbol{A}</em>{k} \hat{\boldsymbol{P}}<em>{k-1} \boldsymbol{A}</em>{k}^{T}+\boldsymbol{R}<br>$$</p><ul><li><strong>更新</strong>：<br>首先计算K（卡尔曼增益，计算需要预测步骤计算的先验协方差$\overline{\boldsymbol{P}}_{k}$，测量方程的雅克比矩阵$C_k$，还有测量噪声$v_k$的协方差$Q$）</li></ul><p>$$<br>\boldsymbol{K}&#x3D;\overline{\boldsymbol{P}}<em>{k} C</em>{k}^{T}\left(\boldsymbol{C}<em>{k} \overline{\boldsymbol{P}}</em>{k} \boldsymbol{C}_{k}^{T}+\boldsymbol{Q}\right)^{-1}<br>$$</p><p>最后对后验概率的分布进行跟新（需要测量误差$z_k - C_k \overline{x}_k$，测量方程的雅克比矩阵$C_k$，还有卡尔曼增益$K$）</p><p>$$<br>\begin{aligned} \hat{\boldsymbol{x}}<em>{k} &amp;&#x3D;\overline{\boldsymbol{x}}</em>{k}+\boldsymbol{K}\left(\boldsymbol{z}<em>{k}-\boldsymbol{C}</em>{k} \overline{\boldsymbol{x}}<em>{k}\right) \ \hat{\boldsymbol{P}}</em>{k} &amp;&#x3D;\left(\boldsymbol{I}-\boldsymbol{K} \boldsymbol{C}<em>{k}\right) \overline{\boldsymbol{P}}</em>{k} \end{aligned}<br>$$</p><blockquote><p>卡尔曼滤波是线性系统的最优无偏估计</p></blockquote><h1 id="扩展卡尔曼滤波"><a href="#扩展卡尔曼滤波" class="headerlink" title="扩展卡尔曼滤波"></a>扩展卡尔曼滤波</h1><blockquote><p>上面的卡尔曼滤波是基于线性系统的，而我们实际工程遇到的问题一般都是非线性的，比如说slam中的运动方程与观测方程一般都是非线性函数。而一个高斯分布，经过非线性变换后，往往不再是高斯分布了。为了将卡尔曼滤波器的结果扩展到非线性系统中，我们通常会取一定的近似，将一个非高斯分布近似成高斯分布。</p></blockquote><p>在扩展卡尔曼滤波器(Extended Kalman Filter, EKF)中，我们一般在某个点附近考虑运动方程及观测方程的<strong>一阶泰勒展开</strong>，只保留一阶项，即线性的部分，然后按照线性系统的方法进行推导.</p><p>经过线性化（一阶泰勒展开）之后，我们得到的<strong>运动方程</strong>如下</p><p>$$<br>\boldsymbol{x}<em>{k} \approx f\left(\hat{\boldsymbol{x}}</em>{k-1}, \boldsymbol{u}<em>{k}\right)+\left.\frac{\partial f}{\partial \boldsymbol{x}</em>{k-1}}\right|<em>{\hat{\boldsymbol{x}}</em>{k-1}}\left(\boldsymbol{x}<em>{k-1}-\hat{\boldsymbol{x}}</em>{k-1}\right)+\boldsymbol{w}_{k}<br>$$</p><p><strong>观测方程</strong>如下</p><p>$$<br>z_{k} \approx h\left(\overline{x}<em>{k}\right)+\left.\frac{\partial h}{\partial x</em>{k}}\right|<em>{\overline{x}</em>{k}}\left(x_{k}-\hat{x}<em>{k}\right)+n</em>{k}<br>$$</p><p>此处，我们另两个方程中的<strong>两个偏导数</strong>为</p><p>$$<br>\boldsymbol{F}&#x3D;\left.\frac{\partial f}{\partial \boldsymbol{x}<em>{k-1}}\right|</em>{\hat{\boldsymbol{x}}_{k-1}}<br>$$</p><p>$$<br>\boldsymbol{H}&#x3D;\left.\frac{\partial h}{\partial \boldsymbol{x}<em>{k}}\right|</em>{\overline{\boldsymbol{x}}_{k}}<br>$$</p><p>然后，根据运动方程，我们得到的<strong>先验概率分布</strong>为</p><p>$$<br>P\left(\boldsymbol{x}<em>{k} | \boldsymbol{x}</em>{0}, \boldsymbol{u}<em>{1 : k}, \boldsymbol{z}</em>{0 : k-1}\right)&#x3D;N\left(f\left(\hat{\boldsymbol{x}}<em>{k-1}, \boldsymbol{u}</em>{k}\right), \boldsymbol{F} \hat{\boldsymbol{P}}<em>{k-1} \boldsymbol{F}^{\mathrm{T}}+\boldsymbol{R}</em>{k}\right)<br>$$</p><p>根据观测方程，我们得到的<strong>似然概率分布</strong>为</p><p>$$<br>P\left(\boldsymbol{z}<em>{k} | \boldsymbol{x}</em>{k}\right)&#x3D;N\left(h\left(\overline{\boldsymbol{x}}<em>{k}\right)+\boldsymbol{H}\left(\boldsymbol{x}</em>{k}-\overline{\boldsymbol{x}}<em>{k}\right), \boldsymbol{Q}</em>{k}\right)<br>$$</p><p>下面的推导与卡尔曼滤波相同，通过贝叶斯公式使得高斯分布中的指数部分相同。</p><h2 id="扩展卡尔曼滤波实现步骤总结"><a href="#扩展卡尔曼滤波实现步骤总结" class="headerlink" title="扩展卡尔曼滤波实现步骤总结"></a>扩展卡尔曼滤波实现步骤总结</h2><blockquote><p>EKF说到底就是将原本的非线性系统近似成了线性系统，然后每次都会重新计算运动方程和测量方程的雅克比矩阵，然后使用每次近似的线性方程进行卡尔曼滤波的步骤。</p></blockquote><ul><li><strong>预测</strong></li></ul><p>$$<br>\overline{\boldsymbol{x}}<em>{k}&#x3D;f\left(\hat{\boldsymbol{x}}</em>{k-1}, \boldsymbol{u}<em>{k}\right), \quad \overline{\boldsymbol{P}}</em>{k}&#x3D;\boldsymbol{F} \hat{\boldsymbol{P}}<em>{k} \boldsymbol{F}^{T}+\boldsymbol{R}</em>{k}<br>$$</p><ul><li><strong>更新</strong>，先计算K（卡尔曼增益）</li></ul><p>$$<br>\boldsymbol{K}<em>{k}&#x3D;\overline{\boldsymbol{P}}</em>{k} \boldsymbol{H}^{\mathrm{T}}\left(\boldsymbol{H} \overline{\boldsymbol{P}}<em>{k} \boldsymbol{H}^{\mathrm{T}}+\boldsymbol{Q}</em>{k}\right)^{-1}<br>$$</p><p>然后更新后验分布的均值与方差</p><p>$$<br>\hat{\boldsymbol{x}}<em>{k}&#x3D;\overline{\boldsymbol{x}}</em>{k}+\boldsymbol{K}<em>{k}\left(\boldsymbol{z}</em>{k}-h\left(\overline{\boldsymbol{x}}<em>{k}\right)\right) \ \hat{\boldsymbol{P}}</em>{k}&#x3D;\left(\boldsymbol{I}-\boldsymbol{K}<em>{k} \boldsymbol{H}\right) \overline{\boldsymbol{P}}</em>{k}<br>$$</p><h2 id="EKF的评价"><a href="#EKF的评价" class="headerlink" title="EKF的评价"></a>EKF的评价</h2><ul><li><p>优点</p><ul><li>推导简单清楚，适用各种传感器形式</li><li>易于做多传感器融合</li></ul></li><li><p>缺点</p><ul><li>一阶马尔可夫性过于简单，不能充分利用所有的信息</li><li>一阶泰勒展开线性化遇到非线性严重的模型会误差比较大，并且只能局部近似</li><li>需要存储所有状态量的均值与协方差矩阵，存储量呈平方增长</li><li>对outlier很敏感</li><li>假设都是高斯分布，不是对所有情况都适用</li></ul></li></ul><blockquote><p>还有一些其他的滤波方法，比如粒子滤波、IF（信息滤波器）、UKF（Unscented KF）等等。其中粒子滤波不是假设高斯分布。</p></blockquote><h1 id="Multi-State-Constraint-Kalman-Filter"><a href="#Multi-State-Constraint-Kalman-Filter" class="headerlink" title="Multi-State Constraint Kalman Filter"></a>Multi-State Constraint Kalman Filter</h1><blockquote><p>MSCKF本质上就是一个EKF滤波器，只是它和它的名字一样，是<strong>多状态约束下的卡尔曼滤波器</strong>。MSCKF被提出主要为了解决EKF-SLAM维数爆炸的问题。传统的EKF-SLAM中一般会将路标（特征点）加入到状态向量中与IMU状态一起更新，这样在环境很大时，路标的数量会非常大，状态向量维数会非常大，计算起来耗时长。MSCKF并不会将路标加入到状态向量中，而是将当前滑窗中的多个状态加入到状态向量中，根据滑窗中的多个状态来临时三角化出3d路标用来更新状态向量。</p></blockquote><p>MSCKF并不会将路标加入到状态向量中，因此每次想获得重投影误差时需要先计算出路标3d位置。MSCKF根据历史相机位姿和观测来三角化计算特征点的3D坐标。这又带来了一个问题：如何确保三角化的精度呢？如果三角化误差太大，那么观测模型就会不准，最终会使得VIO精度太差。MSCKF做法是当特征点跟踪丢失后再进行三角化，特征点跟丢表示该特征的观测不会再继续增加了，这时利用所有的历史观测三角化。所以MSCKF中观测更新的时机是特征点跟丢。</p><h2 id="MSCKF实现步骤总结"><a href="#MSCKF实现步骤总结" class="headerlink" title="MSCKF实现步骤总结"></a>MSCKF实现步骤总结</h2><ul><li><strong>预测</strong>：IMU积分与状态扩增：每次读入一张图片，利用imu积分来计算当前状态并加入到状态向量中，同时扩充状态协方差；</li><li><strong>更新</strong>：<ul><li>特征三角化：根据历史相机状态（滑窗）三角化出3d特征点的位置（一般使用非线性优化求解）；</li><li>状态更新：利用测量方程（重投影方程）对状态向量进行更新（包括滑窗中的历史状态）；</li><li>滑窗维护：如果滑窗中相机状态个数超过阈值，移除最老的相机状态以及对应的协方差；</li></ul></li></ul><h2 id="MSCKF的评价"><a href="#MSCKF的评价" class="headerlink" title="MSCKF的评价"></a>MSCKF的评价</h2><p><strong>优点</strong></p><ul><li>可以适应更剧烈的运动、一段时间的纹理缺失等。</li><li>耗时短，精度高。</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1]. 视觉slam十四讲 </li><li>[2]. <a href="https://zhuanlan.zhihu.com/p/78011006">https://zhuanlan.zhihu.com/p/78011006</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>非线性最小二乘优化方法总结</title>
    <link href="/2019/04/29/2019-04-29-nonlinear-optimization/"/>
    <url>/2019/04/29/2019-04-29-nonlinear-optimization/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是非线性优化"><a href="#什么是非线性优化" class="headerlink" title="什么是非线性优化"></a>什么是非线性优化</h1><blockquote><p>对于最优化问题，如果目标函数是非线性的，那就是非线性优化问题，如果目标函数是凸函数，那就是凸优化问题。</p></blockquote><p>首先需要说明的是，最初的问题其实是一个<strong>最优化问题</strong>。所谓的最优化问题其实就是寻找最优解的问题，一般形式是寻找函数的最大值或者最小值(一般都是将问题转换成求解目标函数的最小值)。</p><p>而<strong>非线性优化问题就是针对一个非线性函数求最值的问题</strong>。其实，在我们初高中的时候就已经求解过非线性优化的问题了，比如对于如下非线性函数:</p><p>$$ f(x) &#x3D; x^2 + 2x + 1 $$</p><p>求解上面这个非线性函数的最小值，我们可以很轻松的解决，因为这时一个及其简单的非线性优化问题，我们可以直接通过导数为0求解出最小值。<strong>但是对于机器学习中的很多非线性目标函数，我们很难像这样直接求解</strong>。</p><h2 id="非线性最小二乘问题"><a href="#非线性最小二乘问题" class="headerlink" title="非线性最小二乘问题"></a>非线性最小二乘问题</h2><p>首先，什么是<strong>非线性最小二乘问题</strong>，一般它的形式如下：</p><p>$$ \min_{x} \frac{1}{2} {\mid \mid f(x) \mid \mid}^2_{2}$$</p><p>此处自变量$x \in R^{n} $，f是任意的非线性函数，我们可以假设它有m维：$f(x) \in R^{m}$。</p><p>对于不方便直接求解（令导数为0求得所有候选点然后比较）的最小二乘问题，此时一般使用如下迭代的方法求解最小二乘问题。</p><ol><li><p>给定某个初始值$x_{0}$</p></li><li><p>对于第k次迭代，寻找一个增量${\Delta}x_{k}$，使得${\mid \mid f(x_{k} + {\Delta}x_{k}) \mid \mid}^2_{2}$达到极小值</p></li><li><p>若${\Delta}x_{k}$足够小，则停止</p></li><li><p>否则，另$x_{k+1} &#x3D; x_{k} + {\Delta}x_{k}$，返回到第2步</p></li></ol><p>上述迭代中很重要的一点是增量$\Delta x_{k}$如何确定，下面会开始讲解一些代表性的方法。首先将目标函数在x附近进行泰勒展开：</p><p>$$ {\mid \mid f(x + \Delta x ) \mid \mid}^2_{2} \approx {\mid \mid f(x) \mid \mid}^2_{2} + J(x) \Delta x + \dfrac{1}{2} \Delta x^T H \Delta x $$</p><p>上面J是函数${\mid \mid f(x) \mid \mid}^2$关于x的<strong>雅可比(Jacobian)矩阵</strong>，而H是其<strong>海塞(Hessian)矩阵</strong>。</p><blockquote><p>对于<strong>输入与输出都是向量的函数</strong>，雅可比矩阵是这个函数的一阶偏导数矩阵，海塞矩阵是二阶偏导数矩阵，详细可自行查阅相关资料，此处仅简短说明。</p></blockquote><h2 id="最速下降法（梯度下降法，一阶）"><a href="#最速下降法（梯度下降法，一阶）" class="headerlink" title="最速下降法（梯度下降法，一阶）"></a>最速下降法（梯度下降法，一阶）</h2><p><strong>梯度下降法</strong>是只考虑一阶导数的优化方法，优化思想是使用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也叫做最速下降法。（没什么计算，单纯想法是向负梯度方向前进）</p><p>$$ \Delta x &#x3D; - \lambda J $$</p><p>缺点：</p><ol><li>靠近极小值时收敛速度减慢</li><li>直线搜索时会产生很多问题</li><li>可能会出现“之”字形的下降</li></ol><h3 id="梯度下降法的改进"><a href="#梯度下降法的改进" class="headerlink" title="梯度下降法的改进"></a>梯度下降法的改进</h3><p>由于梯度下降法在接近最优解的区域收敛速度明显变慢，因此会需要很多次的迭代，因此出现了一些改进的方法</p><ol><li>批量梯度下降法(Batch Gradient Descent, BGD)</li><li>随机梯度下降法(Stochastic Gradient Descent, SGD)等</li></ol><h2 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h2><p><strong>牛顿法</strong>同时考虑一阶与二阶梯度信息，增量方程为</p><p>$$ \Delta x &#x3D; argmin [{\mid \mid f(x) \mid \mid}^2_{2} + J(x) \Delta x + \dfrac{1}{2} \Delta x^T H \Delta x ] $$</p><p>上式中右侧等式关于$\Delta x$求导并另它为零，就得到了增量的解。</p><p>$$ H \Delta x &#x3D; -J^T $$</p><blockquote><p>牛顿法很好，但是需要计算目标函数的海塞矩阵，这在问题规模较大时十分困难。因此出现了下面两种实用的改进方法</p></blockquote><h2 id="高斯牛顿法"><a href="#高斯牛顿法" class="headerlink" title="高斯牛顿法"></a>高斯牛顿法</h2><p>高斯牛顿法的做法是将$f(x)$(注意，上面都是${\mid \mid f(x) \mid \mid}^2$)进行泰勒展开：</p><p>$$ f(x + \Delta x) \approx f(x) + J(x) \Delta x $$</p><p>此处的$J(x)$是函数$f(x)$关于x的雅可比矩阵。因为目标是寻找一个下降矢量$\Delta x$使得${\mid \mid f(x + \Delta x) \mid \mid}^2$达到最小。为了求$\Delta x$，我们会求解如下的最小二乘问题</p><p>$$ \Delta x^{\ast} &#x3D; argmin \dfrac{1}{2} {\mid \mid f(x) + J(x) \Delta x \mid \mid }^2  $$</p><p>对上式右侧对$\Delta x$进行求导并另其为0，会得到如下方程组</p><p>$$ {J(x)}^T J(x) \Delta x &#x3D; - {J(x)}^T f(x) $$</p><p>上面这个等式是一个关于$\Delta x$的线性方程组，我们称它为<strong>增量方程</strong>，也叫<strong>高斯牛顿方程</strong>或者<strong>正规方程</strong>。我们可以将左侧系数定义为$H$，右侧系数定义为$g$，上式变为</p><p>$$ H \Delta x &#x3D; g $$</p><blockquote><p>与牛顿法对比，高斯牛顿法用$J^T J$作为牛顿法中海塞矩阵的近似，从而省略了H的计算。整个<strong>优化问题的核心变成求解增量方程</strong>。</p></blockquote><p><strong>缺点</strong>：</p><ol><li>由于优化过程中我们需要求解增量方程，所以一般这要求H矩阵是可逆的（而且正定的），但实际数据中计算得到的$J^T J$却只有半正定性。也就是说，在使用高斯牛顿法时，可能出现$J^T J$为奇异矩阵或者病态的情况，此时增量稳定性较差，导致算法不收敛。</li><li>即使H非奇异也非病态，如果我们求出的步长$\Delta x$太大，也会导致我们采用的局部近似不够准确，甚至我们都没法保证它迭代收敛。</li></ol><blockquote><p>对了，高斯牛顿法只能处理二次函数，使用时必须将目标函数转化为二次的。</p></blockquote><h2 id="列文伯格-马夸尔特方法"><a href="#列文伯格-马夸尔特方法" class="headerlink" title="列文伯格-马夸尔特方法"></a>列文伯格-马夸尔特方法</h2><blockquote><p>由于高斯牛顿法中采用的近似二阶泰勒展开只能在展开点附近有较好的近似效果，所以我们很自然的想到给$\Delta$添加一个<strong>信赖区域</strong>，使得其不会过大。</p></blockquote><p>确定信赖区域的方法：根据我们的近似模型和实际函数之间的差异来确定信赖区域，如果差异小，我们就让范围尽可能大；如果差异大，我们就缩小这个近似范围。使用如下参数</p><p>$$ \rho &#x3D; \dfrac{f(x + \Delta x) - f(x)}{J(x) \Delta x} $$</p><p>来判断泰勒近似是否够好，分子是实际函数下降的值，分母是近似模型下降的值。</p><ol><li>给定初始值$x_{0}$，以及初始优化半径$\mu$</li><li>对于第k次迭代，求解 $\Delta x_{k} &#x3D; argmin \dfrac{1}{2} {\mid \mid f(x_{k}) + J(x_{k}) \Delta x_{k} \mid \mid}^2 , s.t. {\mid \mid D \Delta x_{k} \mid \mid}^2 \le \mu$，此处$\mu$是信赖区域的半径，D在后面会说明</li><li>计算$\rho$</li><li>若$\rho &gt; \dfrac{3}{4}$，则$\mu &#x3D; 2 \mu$</li><li>若$\rho &lt; \dfrac{1}{4}$，则$\mu &#x3D; 0.5 \mu$</li><li>如果$\rho$大于某阈值，则认为近似可行。另$x_{k+1} &#x3D; x_{k} + \Delta x_{k}$</li><li>判断算法是否收敛。如果不收敛则返回第2步，否则结束。</li></ol><p>上面近似范围扩大的倍数与阈值都是经验值，可以替换成别的数值。在第二步$\Delta x$的求解中，我们将增量限定在一个半径为$\mu$的球里，带上D之后，这个球可以看成一个椭球。通常D为单位矩阵时，是一个正球体。</p><p>现在我们来确定LM方法中的$\Delta x$，首先使用拉格朗日乘子法将上述带不等式约束的优化问题转换成一个无约束的优化问题</p><p>$$ \Delta x_{k} &#x3D; argmin \dfrac{1}{2} {\mid \mid f(x_{k}) + J(x_{k}) \Delta x_{k} \mid \mid}^2 + \dfrac{\lambda}{2} {\mid \mid D \Delta x \mid \mid}^2  $$</p><p>此处的$\lambda$为拉格朗日乘子。上述做法类似于高斯牛顿法中的做法，对上述问题求解，我们得到下式：</p><p>$$ (H + \lambda D_{T}D)\Delta x &#x3D; g  $$</p><p>由上我们发现该问题的核心仍然是计算增量的线性方程，相比较高斯牛顿法的方程，LM中多了一项$\lambda D_{T}D$。考虑上式的简化版本，我们另$D&#x3D;I$，这个方程变为：</p><p>$$ (H + \lambda I)\Delta x &#x3D; g $$</p><p>我们发现，<strong>当$\lambda$比较小时，LM方法近似与高斯牛顿法；当$\lambda$比较大时，说明附近的二次近似不太好，LM方法近似于最速下降法。</strong></p><blockquote><p>列文伯格-马夸尔特方法可在一定程度上米面线性方程组的系数矩阵的非奇异和病态问题，提供更稳定、准确的增量$\Delta x$。尽管它的收敛速度可能会比高斯牛顿法更慢，也被叫做阻尼牛顿法。</p></blockquote><h2 id="LM算法的另一种理解方式"><a href="#LM算法的另一种理解方式" class="headerlink" title="LM算法的另一种理解方式"></a>LM算法的另一种理解方式</h2><p>忽略上面对LM算法来源的说明，其实LM算法主要核心方程是：</p><p>$$<br>\left(\mathbf{J}^{\top} \mathbf{J}+\mu \mathbf{I}\right) \Delta \mathbf{x}_{\mathrm{lm}}&#x3D;-\mathbf{J}^{\top} \mathbf{f} \quad \text { with } \quad \mu \geq 0<br>$$</p><p>上面这个式子的求解结果为（其中$\mathbf{F}^{\prime \top}$即为$\mathbf{J}^{\top} \mathbf{f}$）：</p><p>$$<br>\Delta \mathbf{x}<em>{\mathrm{lm}}&#x3D;-\sum</em>{j&#x3D;1}^{n} \frac{\mathbf{v}<em>{j}^{\top} \mathbf{F}^{\prime \top}}{\lambda</em>{j}+\mu} \mathbf{v}_{j}<br>$$</p><p>其中，$\lambda_j$ 是 $\mathbf{J}^{\top} \mathbf{J}$ 的第j个特征值，$\mathbf{v}_{j}$是其对应的特征向量。（这个式子可以自行推导）</p><p>上面阻尼因子$\mu$作用如下：</p><ul><li><p>$\mu$大于0保证了$\left(\mathbf{J}^{\top} \mathbf{J}+\mu \mathbf{I}\right)$正定，迭代朝着下降方向进行。</p></li><li><p>$\mu$非常大，说明此时高斯牛顿的一次泰勒展开近似效果不好，更新方式偏向近似最速下降法。</p></li><li><p>$\mu$比较小，说明此时高斯牛顿的一次泰勒展开近似效果挺好的，更新方式偏向近似高斯牛顿法。</p></li></ul><p>这种方法的核心问题其实是阻尼因子$\mu$的更新策略，更新一般是根据上面提到的$\rho$来进行的。首先，</p><p>$$<br>\begin{aligned} F(\mathbf{x}+\Delta \mathbf{x}) \approx L(\Delta \mathbf{x}) &amp; \equiv \frac{1}{2} (\mathbf{f}(\mathbf{x}) + \mathbf{J} \Delta \mathbf{x})^2 \ &amp;&#x3D;\frac{1}{2} \mathbf{f}^{\top} \mathbf{f}+\Delta \mathbf{x}^{\top} \mathbf{J}^{\top} \mathbf{f}+\frac{1}{2} \Delta \mathbf{x}^{\top} \mathbf{J}^{\top} \mathbf{J} \Delta \mathbf{x} \ &amp;&#x3D;F(\mathbf{x})+\Delta \mathbf{x}^{\top} \mathbf{J}^{\top} \mathbf{f}+\frac{1}{2} \Delta \mathbf{x}^{\top} \mathbf{J}^{\top} \mathbf{J} \Delta \mathbf{x} \end{aligned}<br>$$</p><p>其次有</p><p>$$<br>\left(\mathbf{J}^{\top} \mathbf{J}+\mu \mathbf{I}\right) \Delta \mathbf{x}_{\mathrm{lm}}&#x3D;-\mathbf{J}^{\top} \mathbf{f} \quad \text { with } \quad \mu \geq 0<br>$$</p><p>而$\rho$为（分母为更新前后目标函数的变化，分子为近似中应该变化的大小）：</p><p>$$<br>\rho&#x3D;\frac{F(\mathbf{x})-F\left(\mathbf{x}+\Delta \mathbf{x}<em>{\operatorname{lm}}\right)}{L(\mathbf{0})-L\left(\Delta \mathbf{x}</em>{\mathrm{lm}}\right)} &#x3D; \frac{F(\mathbf{x})-F\left(\mathbf{x}+\Delta \mathbf{x}<em>{\operatorname{lm}}\right)}{\frac{1}{2} \Delta \mathbf{x}</em>{\operatorname{lm}}^{\top}\left(\mu \Delta \mathbf{x}_{1 \mathrm{m}}+\mathbf{b}\right)}<br>$$</p><p>在上面已经提到了一种阻尼因子更新的策略（1963年由Marquardt提出）：</p><p>$$<br>\begin{aligned} \text { if } \rho &amp;&lt;0.25 \ \mu &amp; :&#x3D;\mu * 2 \ \text { elseif } \rho &amp;&gt;0.75 \ \mu &amp; :&#x3D;\mu &#x2F; 3 \end{aligned}<br>$$</p><p>但是这个策略不是很好，会出现阻尼因子来回波动的情况，目前在ceres与g2o等优化库中一般采用Nielsen策略：</p><p>$$<br>\begin{array}{l}{\text { if } \rho&gt;0} \ {\qquad \mu :&#x3D;\mu * \max \left{\frac{1}{3}, 1-(2 \rho-1)^{3}\right} ; \quad \nu :&#x3D;2} \ {\text { else }} \ {\qquad \mu :&#x3D;\mu * \nu ; \quad \nu :&#x3D;2 * \nu}\end{array}<br>$$</p><p>在设置阻尼因子$\mu$的初始值时，一般采取的策略是（最大的那个特征值乘以一个常数）：</p><p>$$<br>\mu_{0}&#x3D;\tau \cdot \max \left{\left(\mathbf{J}^{\top} \mathbf{J}\right)_{i i}\right}<br>$$</p><p>其中可以按需设置$\tau \sim\left[10^{-8}, 1\right]$</p><h2 id="Dogleg方法"><a href="#Dogleg方法" class="headerlink" title="Dogleg方法"></a>Dogleg方法</h2><p>这种方法与LM方法思想类似，它是高斯牛顿与梯度下降法的混合。</p><p>它的做法是，在信任区域内部，使用高斯牛顿法；否则，使用最速下降法。如果最速下降方向在有效范围内部，使用高斯牛顿与梯度下降的混合，在外部，缩小到Region的边界。</p><h2 id="鲁棒核函数"><a href="#鲁棒核函数" class="headerlink" title="鲁棒核函数"></a>鲁棒核函数</h2><p>由于最小二乘法会将残差进行平方，因此如果出现outlier，此时它的误差也会进行平方，如果这个误差很大，会很影响优化的进行，所以通常会在残差上加上一个<strong>鲁棒核函数</strong>来最小化outlier的影响。作用形式如下：</p><p>$$<br>\min <em>{\mathbf{x}} \frac{1}{2} \sum</em>{k} \rho\left(\left|f_{k}(\mathbf{x})\right|^{2}\right)<br>$$</p><p>将误差的平方项记作$s_{k}&#x3D;\left|f_{k}(\mathbf{x})\right|^{2}$，则鲁棒核误差函数进行二阶泰勒展开有：</p><p>$$<br>\frac{1}{2} \rho(s)&#x3D;\frac{1}{2}\left(\text { const }+\rho^{\prime} \Delta s+\frac{1}{2} \rho^{\prime \prime} \Delta^{2} s\right)<br>$$</p><p>上述函数中的$\Delta s_{k}$的计算稍微复杂一点为：</p><p>$$<br>\begin{aligned} \Delta s_{k} &amp;&#x3D;\left|f_{k}(\mathbf{x}+\Delta \mathbf{x})\right|^{2}-\left|f_{k}(\mathbf{x})\right|^{2} \ &amp; \approx\left|f_{k}+\mathbf{J}<em>{k} \Delta \mathbf{x}\right|^{2}-\left|f</em>{k}(\mathbf{x})\right|^{2} \ &amp;&#x3D;2 f_{k}^{\top} \mathbf{J}<em>{k} \Delta \mathbf{x}+(\Delta \mathbf{x})^{\top} \mathbf{J}</em>{k}^{\top} \mathbf{J}_{k} \Delta \mathbf{x} \end{aligned}<br>$$</p><p>将上面两式合并，最终可以近似得到下解：</p><p>$$<br>\begin{aligned} \sum_{k} \mathbf{J}<em>{k}^{\top}\left(\rho^{\prime} I+2 \rho^{\prime \prime} f</em>{k} f_{k}^{\top}\right) \mathbf{J}<em>{k} \Delta \mathbf{x} &amp;&#x3D;-\sum</em>{k} \rho^{\prime} \mathbf{J}<em>{k}^{\top} f</em>{k} \ \sum_{k} \mathbf{J}<em>{k}^{\top} W \mathbf{J}</em>{k} \Delta \mathbf{x} &amp;&#x3D;-\sum_{k} \rho^{\prime} \mathbf{J}<em>{k}^{\top} f</em>{k} \end{aligned}<br>$$</p><h3 id="柯西鲁棒核函数"><a href="#柯西鲁棒核函数" class="headerlink" title="柯西鲁棒核函数"></a>柯西鲁棒核函数</h3><p>柯西鲁棒核函数定义为：</p><p>$$<br>\rho(s)&#x3D;c^{2} \log \left(1+\frac{s}{c^{2}}\right)<br>$$</p><p>其中c为控制参数。对s的一阶导和二阶导为：</p><p>$$<br>\rho^{\prime}(s)&#x3D;\frac{1}{1+\frac{s}{c^{2}}}, \quad \rho^{\prime \prime}(s)&#x3D;-\frac{1}{c^{2}}\left(\rho^{\prime}(s)\right)^{2}<br>$$</p><h2 id="非线性优化方法存在的问题"><a href="#非线性优化方法存在的问题" class="headerlink" title="非线性优化方法存在的问题"></a>非线性优化方法存在的问题</h2><ol><li><p>首先，对目标函数进行非线性优化有一个很大的前提，那就是<strong>目标函数连续可导</strong>。所以如果目标函数不连续或者不可导，我们就需要想办法使其变得连续可导。比如在slam中处理姿态估计的问题，当姿态使用旋转矩阵与平移变量表示时，显然是不可导的。此时由于欧式矩阵群是一个李群，所以我们会将目标函数映射到其李代数上，此时目标函数就会连续可导了。</p></li><li><p><strong>初值敏感，并且非线性优化方法求得的只是局部最优解</strong>，这个是由梯度下降的原理决定的，由于初始值不确定，使得很容易陷入局部最优中。一般<strong>凸优化</strong>可以在一定程度上解决这个问题。因为凸函数的局部最优就是全局最优，所以我们可以尝试着将目标函数转换成凸函数，然后再进行优化。</p></li></ol><blockquote><p>本文中只是大概讲解了一个非线性优化的整体概念，并针对求解非线性最小二乘问题列举了几种优化方法，还有一些其他的优化方法也具有不错的效果，后面会慢慢补充。。。</p></blockquote><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ol><li><p><a href="https://github.com/xhy3054/myslam/tree/master/03-optimization/ceres_curve_fitting">使用ceres进行函数拟合</a></p></li><li><p><a href="https://github.com/xhy3054/myslam/tree/master/03-optimization/g20_curve_fitting">使用g2o进行函数拟合</a></p></li><li><p><a href="https://github.com/xhy3054/vio/tree/master/ch03/CurveFitting_LM">只基于Eigen的手写优化算法</a></p></li></ol><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1] 视觉slam十四讲</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态估计之非线性最小二乘</title>
    <link href="/2019/04/29/2019-04-29-state-estimation-nonlinear-least-square/"/>
    <url>/2019/04/29/2019-04-29-state-estimation-nonlinear-least-square/</url>
    
    <content type="html"><![CDATA[<p>本文主要介绍一下视觉slam中的状态估计问题，并介绍如何将非线性最小二乘与其联系起来。</p><h1 id="状态估计问题"><a href="#状态估计问题" class="headerlink" title="状态估计问题"></a>状态估计问题</h1><p>首先介绍一下slam中的状态估计问题，这个问题由一个运动方程与一个观测方程构成。</p><p>$$ \begin{equation} \begin{cases} x_{k} &#x3D; f(x_{k-1}, u_{k}) + w_k  \ z_{k,j} &#x3D; h(y_j, x_{k}) + {\upsilon}_{k,j} \end{cases} \end{equation} $$</p><p>这个方程中，第一个方程是<strong>运动方程</strong>，第二个方程是<strong>观测方程</strong>。其中</p><ul><li>$x_{k}$   是相机在k时刻的位姿，我们一般可以使用变换矩阵或者其李代数表示它。</li><li>$u_{k}$   是k时刻系统的输入（在slam中通常是运动传感器的读数）</li><li>$w_{k}$   是运动过程中的噪声</li><li>$y_j$     是第j个路标点</li><li>$z_{k,j}$ 是指在$x_k$处对路标$y_{j}$进行了一次观测得到的观测值（vslam中是对应到图像上的像素位置）</li><li>${\upsilon}_{k,j}$ 是观测过程中的噪声</li></ul><p>在vslam中，我们可以将观测方程这样表示：</p><p>$$ s z_{k,j} &#x3D; K exp({\xi}^{\wedge}y_{j}) $$</p><p>其中，$K$为相机内参，s为像素点的距离。同时，上述应该使用齐次坐标来表示$z$与$y$</p><hr><p>一般情况下，在运动与观测方程中的两个噪声项$w_{k}$与${\upsilon}_{k,j}$满足零均值的高斯分布。</p><p>$$ w_{k} \sim N(0, R_{k}) , {\upsilon}<em>{k,j} \sim N(0, Q</em>{k,j}) $$</p><blockquote><p>在这个问题中，我们的目的是通过带噪声的观测数据$z$与输入$u$来推断位姿$x$和地图$y$。这就是<strong>状态估计问题</strong>。</p></blockquote><h2 id="贝叶斯与最大似然"><a href="#贝叶斯与最大似然" class="headerlink" title="贝叶斯与最大似然"></a>贝叶斯与最大似然</h2><p>在已知输入数据$u$与观测数据$z$的条件下，我们可以用下式表示状态$x$的条件概率分布</p><p>$$ P(x {\mid} z,u) $$</p><p>此处的x与u是对所有数据的统称，比如可能有的系统没有观测运动的传感器，只有一张张图片。此时只考虑观测方程带来的数据，相当于估计$P(x {\mid} z)$的条件概率分布。一般估计状态变量的条件分布，我们会利用<strong>贝叶斯法则</strong> </p><p>$$ P(x {\mid} z) &#x3D; \dfrac{P(z {\mid} x)P(x)}{P(z)} \propto P(z {\mid} x)P(x) $$</p><p>上述贝叶斯法则左侧通常称为<strong>后验概率</strong>，右侧的$ P(z {\mid} x)$ 称为<strong>似然</strong>，另一部分$P(x)$称为<strong>先验</strong>。直接求后验分布是困难的，<strong>而求一个状态最优估计，使得在该状态下后验概率最大化(Maximize a Posterior, MAP)是比较可行的</strong>。</p><p>$$ {x^{\ast}}_{MAP} &#x3D; arg max P(x {\mid} z) &#x3D; arg max P(z {\mid} x)P(x) $$</p><p>上面忽略了贝叶斯法则的分母部分，这是因为我们求的是在x为什么值时后验概率最大，而这部分与x无关并且为正，去掉这部分对结果不会产生影响。贝叶斯法则告诉我们<strong>求解最大后验概率等价于最大化似然与先验的乘积</strong>。而大部分的情况下，我们并不知道机器人位姿在哪里的概率分布，因此也就没有了<strong>先验</strong>，此时，上述估计就变成了**最大似然估计(Maximize Likelihood Estimation, MLE)**：</p><p>$$ {x^{\ast}}_{MAP} &#x3D; arg max P(z {\mid} x) $$</p><blockquote><p>最大似然估计的直观意义是：<strong>在什么样的状态下，最可能产生现在的观测结果</strong></p></blockquote><h2 id="转化为最小二乘问题"><a href="#转化为最小二乘问题" class="headerlink" title="转化为最小二乘问题"></a>转化为最小二乘问题</h2><p>首先对于vslam来说，一般我们首先考虑观测模型。</p><p>$$ z_{k,j} &#x3D; h(y_{j}, x_{k}) + {\upsilon}_{k,j} $$</p><p>由于其中函数h是一个确定的映射，噪声项$$ {\upsilon}<em>{k,j} \sim N(0, Q</em>{k,j}) $$,因此观测数据的条件概率为</p><p>$$ P(z_{k,j} {\mid} x_{k}, y_{j})  &#x3D; N(h(y_{j}, x_{k}), Q_{k,j}) $$</p><p>这依然是一个高斯分布。我们想计算使其最大化的$x_{k}$与$y_{j}$，此时我们通常会对其进行负对数形式变换。</p><hr><p>对于一个任意高维度高斯分布$x \sim N(\mu, \Sigma)$，它的概率密度函数展开形式为</p><p>$$ P(x) &#x3D; \dfrac{1}{\sqrt{(2\pi)^{N} det(\Sigma)}}exp(-{\dfrac{1}{2}}(x-{\mu})^{T} {\Sigma}^{-1}(x-{\mu})) $$</p><blockquote><p>上式中$\Sigma$是这个多元高斯分布的协方差矩阵，它的逆是信息矩阵。</p></blockquote><p>对上式取负对数，则变为</p><p>$$ -ln(P(x)) &#x3D; \dfrac{1}{2} ln((2{\pi})^N det(\Sigma)) + \dfrac{1}{2} (x-\mu)^T {\Sigma}^{-1} (x-\mu) $$</p><p><strong>对原分布求最大化相当于对负对数求最小化</strong>。在最小化上式的x时，第一项与x无关，可以省略。于是只要最小化右侧的二次型项，就完成了对状态的最大似然估计。将上述分析带入slam的观测模型，相当于：</p><p>$$ x^{\ast} &#x3D; arg min ((z_{k,j} - h(x_{k}, y_{j}))^T {Q_{k,j}}^{-1} (z_{k,j} - h(x_{k}, y_{j}))) $$</p><p>在上式中，我们已经将<strong>最大似然估计转换成了求解最小二乘问题</strong>。该式等价于最小化噪声项（误差）的平方。因此对于所有的运动和任意的观测，我们可以定义数据与估计值之间的误差。</p><p>$$ e_{\upsilon, k} &#x3D; x_{k} - f(x_{k-1}, u_{k}) $$</p><p>$$ e_{y, j, k} &#x3D; z_{k, j} - h(x_{k}, y_{j})  $$</p><p>同时考虑观测模型与运动模型，最终我们可以得到整个slam系统的误差平方和</p><p>$$ J(x) &#x3D; \sum_{k}e^T_{v, k} R^{-1}<em>{k} e</em>{\upsilon, k} + \sum_{k} \sum_{j}e^T_{y,k,j} Q^{-1}<em>{k,j} e</em>{y,k,j} $$</p><blockquote><p>运动方程的对状态的最大似然估计转化成最小二乘的推导也是上述方式。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>由上我们知道对于误差的最小二乘问题的求解最优值等价与状态的最大似然估计。</p></blockquote><p>误差函数由许多个误差的平方和组成，虽然总体的状态变量维数很高，但每个误差项都是简单的，仅与一脸个状态变量有关。如果使用李代数表示这个优化问题，则该问题是一个无约束的最小二乘问题。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1]. 视觉slam十四讲</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>李代数求导与扰动模型</title>
    <link href="/2019/04/25/2019-04-25-li-group-derivation/"/>
    <url>/2019/04/25/2019-04-25-li-group-derivation/</url>
    
    <content type="html"><![CDATA[<blockquote><p>$SO(3)$李代数上的扰动模型求导是slam中使用最广泛的公式。！！！</p></blockquote><p>在<a href="https://xhy3054.github.io/Li-group/">上一篇</a>博客中我们了解了李群与李代数的定义，那么知道这些有什么用呢？</p><p><strong>我们经常构建与位姿有关的函数，然后讨论该函数关于位姿的导数，以调整当前的估计值</strong>。表示姿态的李群$SO(3)$与表示位姿的李群$SE(3)$上并没有定义加法，而求导数是需要加法的。因此此时如何求导就成了一个需要解决的问题，它们的李代数由向量组成，具有良好的加法运算，因此我们可以利用李代数来解决对位姿的求导问题。</p><p> \begin{equation} \label{eq:so3ode} \mathbf{R}(t) &#x3D; \exp \left( \mathbf{\phi} (t) ^\wedge \right) \mathbf{R}(t_0) \end{equation} </p><blockquote><p>上面看到了，因为SO(3)上没有定义加法，所以我们不能求R的导数。但是我们上一节中可以用$\mathfrak{so}(3)$通过指数映射来得到SO(3)，所以我们可以将求李代数的导数。</p></blockquote><h2 id="BCH公式"><a href="#BCH公式" class="headerlink" title="BCH公式"></a>BCH公式</h2><p>但是此处必须说明的一点是，指数映射时，下式是不满足的。</p><p> \begin{equation} \exp \left( {\phi _1^ \wedge } \right)\exp \left( {\phi _2^ \wedge } \right) &#x3D; \exp \left( {\left( {\phi _1} + {\phi _2} \right)}^ {\wedge } \right) \end{equation} </p><p>如果上述公式中${\phi^ \wedge }$是标量的话，那么肯定是成立的，但是很遗憾，它是一个矩阵。所以，它到底是什么呢？这需要用到BCH(Baker-Campbell-Hausdorff)公式。完整形式比较复杂，我们此处就不贴出了，直接上有用的。</p><p>$ R_1 R_2 &#x3D; \textbf{exp}({\phi_1}^{\wedge})\textbf{exp}({\phi_2}^{\wedge}) \approx \begin{equation} \begin{cases} \textbf{exp}(( J_l(\phi_2)^{-1} \phi_1 + \phi_2    )^{\wedge})  &amp; \textbf{if  } \phi_1 \textbf{ is small}\ \textbf{exp}(( J_r(\phi_1)^{-1} \phi_2+ \phi_1    )^{\wedge})   &amp; \textbf{if  } \phi_2 \textbf{ is small} \end{cases} \end{equation} $</p><p>其中，第一个称为左乘模型，第二个称为右乘模型。</p><p>$J_l$即$\mathfrak{se}(3)$到$SE(3)$转换时求得的J，称为左乘近似雅可比:</p><p>$ J_l &#x3D; J&#x3D;\dfrac{\sin \theta}{\theta} I + (1- \dfrac{\sin \theta}{\theta})aa^T + \dfrac{1-\cos \theta}{\theta}a^{\wedge} $</p><p>它的逆为:</p><p>$ J_l^{-1} &#x3D; \dfrac{\theta}{2} \cot \dfrac{\theta}{2} I + (1- \dfrac{\theta}{2}\cot \dfrac{\theta}{2})aa^T - \dfrac{\theta}{2}a^{\wedge} $</p><p>而右乘雅可比仅需要对自变量取负号即可:</p><p>$ J_r(\phi)&#x3D;J_l(-\phi) $</p><p>此时，如果将上面的结果反过来，在李代数上做加法，则有（<strong>最有用的</strong>）:</p><p>$ \textbf{exp}((\phi+ \Delta\phi)^{\wedge}) &#x3D; \textbf{exp}((J_l \Delta\phi)^{\wedge}) \textbf{exp}({\phi}^{\wedge})&#x3D;\textbf{exp}({\phi}^{\wedge})\textbf{exp}((J_r \Delta\phi)^{\wedge}) $</p><blockquote><p>在$\mathfrak{se}(3)$上的运算与$\mathfrak{so}(3)$类似，只是雅可比矩阵的求法稍有不同。其实我们发现上面的左乘雅克比与右乘雅克比都有些复杂，其实下面我们会发现，如果使用扰动模型进行求导根本用不到它们！因此这里直接跳过它们的内容求解。</p></blockquote><h1 id="基于李代数对姿态求导"><a href="#基于李代数对姿态求导" class="headerlink" title="基于李代数对姿态求导"></a>基于李代数对姿态求导</h1><p>本来我们想求得是</p><p>$ \frac{d\left( {RP} \right)}{dR} &#x3D; \mathop {\lim }\limits_{\Delta R \to 0} \frac{\left( {R + \Delta R} \right)P - RP}{\Delta R} $</p><p>但是，$R+\Delta R$不再是旋转矩阵。因此我们需要另想办法。有了上面的工作，下面我们就可以完成基于李代数的求导操作了，此处介绍两种模型，因为扰动模型的形式会简单一些，因此大家一般都是使用扰动模型，微分模型也了解一下</p><h2 id="利用BCH公式的微分模型求导"><a href="#利用BCH公式的微分模型求导" class="headerlink" title="利用BCH公式的微分模型求导"></a>利用BCH公式的微分模型求导</h2><h3 id="SO-3-李代数上的微分模型"><a href="#SO-3-李代数上的微分模型" class="headerlink" title="$SO(3)$李代数上的微分模型"></a>$SO(3)$李代数上的微分模型</h3><blockquote><p>用李代数表示姿态，然后根据李代数加法来对李代数求导。即<strong>传统求导的思路，把增量直接定义在李代数上</strong>。</p></blockquote><p>$<br>\begin{aligned} \frac{\partial\left(\exp \left(\phi^{\wedge}\right) \boldsymbol{p}\right)}{\partial \phi} &amp;&#x3D;\lim <em>{\delta \phi \rightarrow 0} \frac{\exp \left((\phi+\delta \phi)^{\wedge}\right) \boldsymbol{p}-\exp \left(\phi^{\wedge}\right) \boldsymbol{p}}{\delta \phi} \ &amp;&#x3D;\lim <em>{\delta \phi \rightarrow 0} \frac{\exp \left(\left(\boldsymbol{J}</em>{l} \delta \phi\right)^{\wedge}\right) \exp \left(\boldsymbol{\phi}^{\wedge}\right) \boldsymbol{p}-\exp \left(\phi^{\wedge}\right) \boldsymbol{p}}{\delta \phi} \ &amp;&#x3D;\lim <em>{\delta \phi \rightarrow 0} \frac{\left(\boldsymbol{I}+\left(\boldsymbol{J}</em>{l} \delta \boldsymbol{\phi}\right)^{\wedge}\right) \exp \left(\phi^{\wedge}\right) \boldsymbol{p}-\exp \left(\phi^{\wedge}\right) \boldsymbol{p}}{\delta \phi} \ &amp;&#x3D;\lim <em>{\delta \phi \rightarrow 0} \frac{\left(\boldsymbol{J}</em>{l} \delta \boldsymbol{\phi}\right)^{\wedge} \exp \left(\phi^{\wedge}\right) \boldsymbol{p}}{\delta \phi}&#x3D;-(\boldsymbol{R} \boldsymbol{p})^{\wedge} \boldsymbol{J}</em>{l} \ &amp;&#x3D;\lim <em>{\delta \phi \rightarrow 0} \frac{-\left(\exp \left(\phi^{\wedge}\right) \boldsymbol{p}\right)^{\wedge} \boldsymbol{J}</em>{l} \delta \phi}{\delta \phi}&#x3D;-(\boldsymbol{R} \boldsymbol{p})^{\wedge} \boldsymbol{J}_{l} \end{aligned}<br>$</p><blockquote><p>上面第四行到第五行将反对称符号看做叉乘，变换之后变号，并且微分模型的结果最后需要计算一个雅可比矩阵，要麻烦一些，所以实际工程中很少使用这种方式。<strong>下面的扰动模型其实才是工程中广泛使用的方法。</strong></p></blockquote><h2 id="扰动模型求导"><a href="#扰动模型求导" class="headerlink" title="扰动模型求导"></a>扰动模型求导</h2><blockquote><p>对李群<strong>左乘</strong>或者<strong>右乘</strong>微小扰动，然后对该扰动求导，称为左扰动和右扰动模型。即<strong>把增量扰动直接添加在李群上，然后使用李代数表示此扰动</strong></p></blockquote><h3 id="SO-3-李代数上的扰动模型-左扰动-这是slam中应用最多的公式"><a href="#SO-3-李代数上的扰动模型-左扰动-这是slam中应用最多的公式" class="headerlink" title="$SO(3)$李代数上的扰动模型(左扰动) !!! 这是slam中应用最多的公式"></a>$SO(3)$李代数上的扰动模型(左扰动) !!! 这是slam中应用最多的公式</h3><p>$<br>\begin{aligned} \frac{\partial(\boldsymbol{R} \boldsymbol{p})}{\partial \boldsymbol{\varphi}} &amp;&#x3D;\lim _{\varphi \rightarrow 0} \frac{\exp \left(\boldsymbol{\varphi}^{\wedge}\right) \exp \left(\phi^{\wedge}\right) \boldsymbol{p}-\exp \left(\phi^{\wedge}\right) \boldsymbol{p}}{\varphi} \ &amp;&#x3D;\lim _{\varphi \rightarrow 0} \frac{\left(\boldsymbol{I}+\boldsymbol{\varphi}^{\wedge}\right) \exp \left(\boldsymbol{\phi}^{\wedge}\right) \boldsymbol{p}-\exp \left(\boldsymbol{\phi}^{\wedge}\right) \boldsymbol{p}}{\varphi} \ &amp;&#x3D;\lim _{\boldsymbol{\varphi} \rightarrow 0} \frac{\boldsymbol{\varphi}^{\wedge} \boldsymbol{R} \boldsymbol{p}}{\varphi}&#x3D;\lim _{\boldsymbol{\varphi} \rightarrow 0} \frac{-(\boldsymbol{R} \boldsymbol{p})^{\wedge} \boldsymbol{\varphi}}{\varphi}&#x3D;-(\boldsymbol{R} \boldsymbol{p})^{\wedge} \end{aligned}<br>$</p><blockquote><p>这一种方法直接将小量乘在李群上，而不是李代数上。并且需要注意的是这种模型需要区别是左乘还是右乘。左扰动模型比微分模型要少一个雅可比矩阵。</p></blockquote><h3 id="SE-3-上的扰动模型"><a href="#SE-3-上的扰动模型" class="headerlink" title="$SE(3)$上的扰动模型"></a>$SE(3)$上的扰动模型</h3><p>含义是：考虑一个空间点P（需要是齐次坐标，否则维数不对），受到刚体变换T，得到$TP$。下面要求解$TP$是如何随着T变化的。</p><p>$ \begin{equation} \begin{aligned} \dfrac{\partial(\textbf {TP})}{\partial T} &amp;&#x3D;  \lim_{\delta \xi \rightarrow 0} \dfrac{\textbf{exp}((\delta \xi)^{\wedge})  \textbf TP-\textbf TP}{\delta \xi} \ &amp;&#x3D; (TP)^{\odot} \end{aligned} \end{equation} $</p><p>其中，$^ \odot$将一个<code>4×4</code>的矩阵变换成一个<code>4×6</code>的矩阵</p><p>假设如下求导中左乘的扰动项的李代数为$\delta \boldsymbol{\xi}&#x3D;[\delta \boldsymbol{\rho}, \delta \phi]^{\mathrm{T}}$，那么：</p><div style="text-align: center"><img src="/assets/img/math/raodong.PNG"/></div><blockquote><p>上面最后一行矩阵除法，与矩阵乘法规则类似，只是乘号变成了除号。其使用一个$4×1$矩阵除以一个$1×6$矩阵得到一个$4×6$矩阵</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们讲解了如何对位姿进行求导，这是后面对位姿进行非线性优化的基础。</p><blockquote><p>引入李群李代数的意义：第一个是因为在欧式变换矩阵上不好定义导数，引入李群李代数使得导数定义变得自然合理；第二个是本来旋转矩阵与欧式变换矩阵具有本身的约束，使得将它们作为优化变量会引入额外约束，通过李群李代数可以使得问题变成一个无约束的优化问题。</p></blockquote><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1]. <a href="https://zhehangt.github.io/2017/03/16/SLAM/Basic/LieAlgebra-02/">https://zhehangt.github.io/2017/03/16/SLAM/Basic/LieAlgebra-02/</a></li><li>[2]. 视觉SLAM十四讲-从理论到实践</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>李群与李代数</title>
    <link href="/2019/04/22/2019-04-22-Li-group/"/>
    <url>/2019/04/22/2019-04-22-Li-group/</url>
    
    <content type="html"><![CDATA[<p>这部分内容是在slam中经常会用到的数学内容。</p><h1 id="群"><a href="#群" class="headerlink" title="群"></a>群</h1><p>群(group)是一种代数结构，由两部分(一个集合A与一种运算$\cdot$)构成，可以记作$G&#x3D;(A, \cdot)$,并且群满足如下条件:</p><ol><li>封闭性:     $ \quad \forall a_1, a_2, \quad a_1 \cdot a_2 \in A $</li><li>结合律:     $ \quad \forall a_1, a_2, a_3, \quad (a_1 \cdot a_2) \cdot a_3 &#x3D; a_1 \cdot ( a_2 \cdot a_3) $</li><li>幺元:       $ \quad \exists a_0 \in A, \quad s.t. \quad \forall a \in A, \quad a_0 \cdot a &#x3D; a \cdot a_0 &#x3D; a $</li><li>逆:        $ \quad \forall a \in A, \quad \exists a^{-1} \in A, \quad s.t. \quad a \cdot a^{-1} &#x3D; a_0 $</li></ol><p>由上面我们可以知道了群的定义，下面例举几个群：</p><ul><li><p><strong>一般线性群</strong>$GL(n)$: n×n的可逆矩阵与矩阵乘法构成一个群，幺元是E矩阵</p></li><li><p><strong>旋转矩阵群</strong>$SO(n)$: 旋转矩阵与矩阵乘法构成的一个群，满足上面任何一个性质，幺元是旋转角度0的矩阵。<br>$$\begin{equation} SO(n) &#x3D; { \mathbf{R} \in \mathbb{R}^{n \times n} | \mathbf{R R}^T &#x3D; \mathbf{I}, det(\mathbf{R})&#x3D;1 } \end{equation}$$</p></li><li><p><strong>特殊欧式群</strong>$SE(n)$: 欧式变换矩阵(旋转加平移)与矩阵乘法也构成一个群，它的幺元是旋转角度为0，平移也是0的变换矩阵。<br>$$\begin{equation} SE(3) &#x3D; \left{ \mathbf{T} &#x3D; \left[ {\begin{array}{*{20}{c}} \mathbf{R} &amp; \mathbf{t} \ {\mathbf{0}^T} &amp; 1 \end{array}} \right]  \in \mathbb{R}^{4 \times 4} | \mathbf{R} \in SO(3), \mathbf{t} \in \mathbb{R}^3\right} \end{equation} $$</p></li><li><p><strong>相似变换群</strong>$Sim(n)$: 相似变换就是在旋转矩阵上再加上尺度变换，这个群主要会在<strong>单目视觉</strong>中使用，因为单目具有尺度不确定性。如果在单目slam中使用$SE(3)$来表示位姿，那么由于尺度不确定性与尺度漂移，整个slam过程中尺度会发生变化，而这在SE(3)中不能体现出来。所以在单目视觉中，我们一般在相似变换群上来进行位姿的优化。<br>$$ \begin{equation} Sim(3) &#x3D; \left{ \mathbf{S} &#x3D; \left[ {\begin{array}{*{20}{c}} \mathbf{sR} &amp; \mathbf{t} \ {\mathbf{0}^T} &amp; 1 \end{array}} \right]  \in \mathbb{R}^{4 \times 4} | \mathbf{R} \in SO(3), \mathbf{t} \in \mathbb{R}^3\right} \end{equation} $$</p></li></ul><h2 id="李群"><a href="#李群" class="headerlink" title="李群"></a>李群</h2><p>李群是指具有连续性质的群。比如向整数群Z那样的离散的群就没有连续性质，所以不是李群。而$SO(n)$与$SE(n)$是李群</p><h3 id="李代数"><a href="#李代数" class="headerlink" title="李代数"></a>李代数</h3><p>每个李群都有与之对应的李代数。李代数描述了李群的局部性质。</p><p>通常李代数由一个集合V，一个数域F和一个二元运算[]组成。通常如果我们说$(\mathbb{V}, \mathbb{F}, [])$是一个李代数，那么它具有如下性质:</p><ul><li><p>封闭性: $\forall \mathbf{X}, \mathbf{Y} \in \mathbb{V}, [\mathbf{X} \mathbf{Y}] \in \mathbb{V}$</p></li><li><p>双线性: $\forall \mathbf{X,Y,Z} \in \mathbb{V}, a,b \in \mathbb{F},$有<br>$$[a\mathbf{X}+b\mathbf{Y}, \mathbf{Z}] &#x3D; a[\mathbf{X}\mathbf{Z}] + b [ \mathbf{Y} \mathbf{Z} ] \quad [\mathbf{Z}, a \mathbf{X}+b\mathbf{Y}] &#x3D; a [\mathbf{Z} \mathbf{X} ]+ b [\mathbf{ZY}]$$</p></li><li><p>自反性: $\forall \mathbf{X} \in \mathbb{V}, [\mathbf{X} \mathbf{X}] &#x3D; \mathbf{0}$</p></li><li><p>雅可比等价: $\forall \mathbf{X,Y,Z} \in \mathbb{V}, [\mathbf{X}, [\mathbf{YZ}] ] + [\mathbf{Z}, [\mathbf{YX}] ] + [\mathbf{Y}, [\mathbf{ZX}]]$</p></li></ul><blockquote><p>通常我们成李代数中的二元运算为<strong>李括号</strong>。相比于群中较为简单的二元运算，李括号通常的含义是计算集合中两个元素的差异。一般它不要求结合律，但是满足反对称性，以及元素和自己做李括号之后为0的性质。一个典型的例子是$\mathfrak{g} &#x3D; (\mathbb{R}^3, \mathbb{R}, \times)$是一个李代数。</p></blockquote><h2 id="三维旋转群-SO-3-与其对应的李代数-mathfrak-so-3"><a href="#三维旋转群-SO-3-与其对应的李代数-mathfrak-so-3" class="headerlink" title="三维旋转群$SO(3)$与其对应的李代数$\mathfrak{so}(3)$"></a>三维旋转群$SO(3)$与其对应的李代数$\mathfrak{so}(3)$</h2><p>三维旋转群描述三维空间中的旋转，其集合元素为3×3的正交且行列式为1的矩阵R，我们知道$RR^T&#x3D;I$。如果将R看作一个随着时间t变化的函数R(t),则有$\mathbf{R}(t) \mathbf{R}(t) ^T &#x3D; \mathbf{I}$。在等式两边分别对时间求导，可以得到:</p><p>$$ \begin{equation} \mathbf{\dot{R}} (t) \mathbf{R} {(t)^T} + \mathbf{R} (t) \mathbf{\dot{R}} {(t)^T} &#x3D; 0 \end{equation} $$</p><p>对上式进行整理，可以得到:</p><p>$$ \begin{equation} \mathbf{\dot{R}} (t) \mathbf{R} {(t)^T} &#x3D; - \left(  \mathbf{\dot{R}} (t) \mathbf{R} {(t)^T} \right)^T \end{equation}$$</p><p>从上面的公式我们可以看出$\mathbf{\dot{R}} (t) \mathbf{R} {(t)^T}$是一个<strong>反对称矩阵</strong>。</p><h3 id="反对称矩阵与叉乘"><a href="#反对称矩阵与叉乘" class="headerlink" title="反对称矩阵与叉乘"></a>反对称矩阵与叉乘</h3><p>对于三维向量a与b之间的外积，其中$\mathbf{a}&#x3D;[a_1, a_2, a_3]^T$,如下公式:</p><p>$$ a×b &#x3D; a^{\wedge} b $$</p><p>$$\begin{equation}   {\mathbf{a}^ \wedge } &#x3D; \left[ {\begin{array}{*{20}{c}} 0&amp;{ - {a_3}}&amp;{a_2} \ {a_3}&amp;0&amp;{ - {a_1}}\ { - {a_2}}&amp;{a_1}&amp;0 \end{array}} \right] \end{equation} $$</p><hr><p>回到刚才的话题，对于$\mathbf{\dot{R}} (t) \mathbf{R} {(t)^T}$这个反对称矩阵，我们将其记为A。可以将其对应到一个向量$\mathbf{a}&#x3D;[a_1, a_2, a_3]^T$。</p><p>$$\begin{equation}   {\mathbf{a}^ \wedge } &#x3D; \mathbf{A} &#x3D; \left[ {\begin{array}{*{20}{c}} 0&amp;{ - {a_3}}&amp;{a_2}\ {a_3}&amp;0&amp;{ - {a_1}}\ { - {a_2}}&amp;{a_1}&amp;0 \end{array}} \right] \end{equation}$$</p><p>上式也就可以写做</p><p>$$ \begin{equation}   \mathbf{ \dot{R} } (t) \mathbf{R}(t)^T &#x3D; \mathbf{\phi} (t) ^ {\wedge} \end{equation} $$</p><p>将上式左右各右乘$\mathbf{R}(t)$，由于R是正交的，所以有</p><p>$$ \begin{equation}   \mathbf{ \dot{R} } (t)  &#x3D; \mathbf{\phi} (t)^{\wedge} \mathbf{R}(t) &#x3D;   \left[ {\begin{array}{*{20}{c}}    0&amp;{ - {\phi _3}}&amp;{\phi _2}\      {\phi _3}&amp;0&amp;{ - {\phi _1}}\      { - {\phi _2}}&amp;{\phi _1}&amp;0    \end{array}} \right] \mathbf{R} (t) \end{equation}$$</p><p>由上式我们可以发现，每次<strong>对旋转矩阵求导数</strong>，只需要左乘一个$\mathbf{\phi}$矩阵即可。这表明$\mathbf{\phi}$反映了R的导数性质，所以称其在$SO(3)$的正切空间上。同时对上面微分方程进行求解，我们可以得到</p><p>$$\begin{equation} \label{eq:so3ode} \mathbf{R}(t) &#x3D; \exp \left( \mathbf{\phi} (t) ^\wedge \right) \mathbf{R}(t_0) \end{equation}$$</p><hr><p>由上我们可以知道，<strong>三维旋转群$SO(3)$与其对应的李代数$\mathfrak{so}(3)$是$(\mathbb{R}^3, \mathbb{R}, \times)$(三维向量，实数，外积运算)，这个李代数的集合由三维向量组成，每个向量对应到一个反对称矩阵，可以表达旋转矩阵的导数</strong>。它描述了三维旋转群$SO(3)$的局部性质。</p><p>此处我们发现SO(3)对应的李代数是定义在$\mathbb{R}^3$上的向量，我们记作$\mathbf{\phi}$（注意这是个向量，虽然希腊字母的粗体不明显）。而每个$\mathbf{\phi}$都可以生成一个反对称矩阵:</p><p>$$ \begin{equation} \label{eq:phi} \mathbf{\Phi} &#x3D; \mathbf{\phi}^{\wedge} &#x3D; \left[ {\begin{array}{*{20}{c}}     0&amp;{ - {\phi _3}}&amp;{\phi _2}\  {\phi _3}&amp;0&amp;{ - {\phi _1}}\  { - {\phi _2}}&amp;{\phi _1}&amp;0    \end{array}} \right] \in \mathbb{R}^{3 \times 3} \end{equation} $$</p><p>在此定义下，两个向量$\mathbf{\phi}_1, \mathbf{\phi}_2$的李括号运算对应的反对称矩阵运算为:</p><p>$$ \begin{equation} [\mathbf{\phi}_1, \mathbf{\phi}_2]^{\wedge} &#x3D; \mathbf{ \Phi }_1 \mathbf{ \Phi }_2 - \mathbf{ \Phi }_2 \mathbf{ \Phi }_1 \end{equation} $$</p><p><strong>由于向量与其对应的反对称矩阵关系密切，所以我们说旋转矩阵群的李代数的元素是3维向量或者3维反对称矩阵，都是可以的。</strong></p><p>$$ \begin{equation} \mathfrak{so}(3) &#x3D; \left{ \Phi &#x3D; \mathbf{\phi^\wedge} \in \mathbb{R}^{3 \times 3} | \mathbf{\phi} \in \mathbb{R}^3 \right} \end{equation} $$</p><h3 id="SO-3-上的指数映射"><a href="#SO-3-上的指数映射" class="headerlink" title="$SO(3)$上的指数映射"></a>$SO(3)$上的指数映射</h3><p>首先，任意矩阵的指数映射可以写成一个泰勒展开，当然，只有在收敛的情况下才会有结果，其结果仍然是一个矩阵。</p><p>$$\begin{equation} \exp(\mathbf{A}) &#x3D; \sum\limits_{n &#x3D; 0}^\infty  {\frac{1}{n!}{ \mathbf{A}^n}} \end{equation}$$</p><p>同样，对$$\mathfrak{so}(3)$$中任意一个元素$\mathbf{\phi}$，它的指数映射是:</p><p>$$ \begin{equation} \exp(\mathbf{\phi}^\wedge) &#x3D; \sum\limits_{n &#x3D; 0}^\infty  {\frac{1}{n!}{ (\mathbf{\phi}^{\wedge})^n}} \end{equation} $$</p><p>仔细推导这个定义，首先$\mathbf{\phi}$是一个三维向量，我们可以定义它的模长和方法，分别记作$\theta$与$\mathbf{a}$(注意此处的$\mathbf{a}$是一个单位长度的向量)，于是有$\mathbf{\phi} &#x3D; {\theta} {a}$，首先此处说明的是，$a^{\wedge}$具有如下两条性质:</p><p>$$\begin{equation} \mathbf{a} \mathbf{a}^T &#x3D; \mathbf{a}^{\wedge} \mathbf{a}^{\wedge} + \mathbf{I} \end{equation}$$</p><p>$$ \begin{equation} \mathbf{a}^{\wedge} \mathbf{a}^{\wedge} \mathbf{a}^{\wedge} &#x3D; - \mathbf{a}^{\wedge} \end{equation} $$</p><p>上述性质有时间可以尝试证明一下，利用这两个性质，我们可以进行如下推导:</p><p>$$ \begin{align*} \exp \left( {\mathbf{\phi} ^ \wedge } \right) &amp;&#x3D; \exp \left( {\theta {\mathbf{a}^ \wedge }} \right) &#x3D; \sum\limits_{n &#x3D; 0}^\infty  {\frac{1}{n!}{\left( {\theta {\mathbf{a}^ \wedge }} \right)}^n} \ &amp;&#x3D; \mathbf{I} + \theta {\mathbf{a}^ \wedge } + \frac{1}{2!}{\theta ^2}{\mathbf{a}^ \wedge }{\mathbf{a}^ \wedge } + \frac{1}{3!}{\theta ^3}{\mathbf{a}^ \wedge }{\mathbf{a}^ \wedge }{\mathbf{a}^ \wedge } + \frac{1}{4!}{\theta ^4}{\left( {\mathbf{a}^ \wedge } \right)^4} + …\ &amp;&#x3D; \mathbf{a} {\mathbf{a}^T} - {\mathbf{a}^ \wedge }{\mathbf{a}^ \wedge } + \theta {\mathbf{a}^ \wedge } + \frac{1}{2!}\theta {\mathbf{a}^ \wedge }{\mathbf{a}^ \wedge } - \frac{1}{3!}{\theta ^3}{\mathbf{a}^ \wedge } + \frac{1}{4!}{\theta ^4}{\left( {\mathbf{a}^ \wedge } \right)^4} + …\ &amp;&#x3D; \mathbf{a}{\mathbf{a}^T} + \left( {\theta  - \frac{1}{3!}{\theta ^3} + \frac{1}{5!}{\theta ^5} - …} \right){\mathbf{a}^ \wedge } - \left( {1 - \frac{1}{2!}{\theta ^2} + \frac{1}{4!}{\theta ^4} - …} \right){\mathbf{a}^ \wedge }{\mathbf{a}^ \wedge }\ &amp;&#x3D; {\mathbf{a}^ \wedge }{\mathbf{a}^ \wedge } + \mathbf{I} + \sin \theta {\mathbf{a}^ \wedge } - \cos \theta {\mathbf{a}^ \wedge }{\mathbf{a}^ \wedge }\ &amp;&#x3D; (1 - \cos \theta ){\mathbf{a}^ \wedge }{\mathbf{a}^ \wedge } + I + \sin \theta {\mathbf{a}^ \wedge }\ &amp;&#x3D; \cos \theta \mathbf{I} + (1 - \cos \theta )\mathbf{a}{\mathbf{a}^T} + \sin \theta {\mathbf{a}^ \wedge } \ \end{align*} $$</p><p>记住最后的这个公式:</p><p>$$ \begin{equation} \exp( \theta \mathbf{a} ) &#x3D; \cos \theta \mathbf{I} + (1 - \cos \theta )\mathbf{a}{\mathbf{a}^T} + \sin \theta {\mathbf{a}^ \wedge } \end{equation} $$</p><p>这时<strong>罗德里格斯公式</strong>，这个公式本身的作用是将旋转向量变换成旋转矩阵。所以从这里我们知道$$\mathfrak{so}(3)$$实际上是由旋转向量组成的空间。而指数映射就是罗德里格斯公式映射，通过他们我们可以将$$\mathfrak{so}(3)$$中的任意一个旋转向量对应到一个$SO(3)$中的一个旋转矩阵。</p><blockquote><p>这里需要提到的一点是，指数映射不是一个双射，但他是一个满射。这一意味着每一个旋转矩阵都可以找到一个向量与之对应，但是可能存在多个向量对应到同一个矩阵。这个很好理解，因为旋转角度具有周期性，多转360度效果一样。</p></blockquote><blockquote><p>同理，<strong>指数映射</strong>作用是从向量到矩阵的映射，反过来，从矩阵到向量的映射是<strong>对数映射</strong>。</p></blockquote><h2 id="三维欧式群-SE-3-与其对应的李代数-mathfrak-se-3"><a href="#三维欧式群-SE-3-与其对应的李代数-mathfrak-se-3" class="headerlink" title="三维欧式群$SE(3)$与其对应的李代数$\mathfrak{se}(3)$"></a>三维欧式群$SE(3)$与其对应的李代数$\mathfrak{se}(3)$</h2><p>首先，列出三维欧式群$SE(3)$的定义:</p><p>$$\begin{equation} SE(3) &#x3D; \left{ \mathbf{T} &#x3D; \left[ {\begin{array}{*{20}{c}}     \mathbf{R} &amp; \mathbf{t} \  {\mathbf{0}^T} &amp; 1    \end{array}} \right] \in \mathbb{R}^{4 \times 4} | \mathbf{R} \in SO(3), \mathbf{t} \in \mathbb{R}^3\right} \end{equation}$$</p><p>由于每个欧式变换矩阵具有六个自由度，所以其对应的李代数位于$\mathbb{R}^6$中:</p><p>$$\begin{equation} \mathfrak{se}(3) &#x3D; \left{ \mathbf{ \Xi } &#x3D; \mathbf{\xi}^\wedge \in \mathbb{R}^{4 \times 4} | \mathbf{\xi} \in \mathbb{R}^6 \right} \end{equation}$$</p><p>不过需要注意的是，此处我们对$^\wedge$的作用进行拓展，使得其不再是一个反对称关系，而是讲一个六维度向量转换成四维矩阵。如下:</p><p>$$\begin{equation} \mathbf{\xi}^\wedge &#x3D; {\left[ \begin{array}{l}   \mathbf{\rho} \    \mathbf{\phi}   \end{array} \right]^ \wedge } &#x3D; \left[ {\begin{array}{*{20}{c}}     {\mathbf{\phi} ^ \wedge }&amp;\mathbf{\rho} \    {\mathbf{0}^T}&amp;0  \end{array}} \right] &#x3D; \mathbf{\Xi} \end{equation}$$</p><p>其中，前三维是平移分量，后三位为旋转分量，这个分量是$\mathfrak{so}(3)$的元素。在此处，该李代数对应的微分方程是:</p><p>$$\begin{equation} \mathbf{\dot{T}}(t) &#x3D; \mathbf{\xi}^\wedge(t) \mathbf{T}(t) \end{equation}$$</p><blockquote><p>三维欧式群及其李代数的指数与对数映射类似。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div style="text-align: center"><img src="/assets/img/liqun/li-qun.png" width="700" height="600"/></div><blockquote><p>其中，J是雅克比矩阵，这个矩阵是在SE(3)上的指数映射中，平移部分经过指数映射后，发生了一次以J为系数矩阵的线性变换。旋转部分的指数映射还是罗德里格斯公式。</p></blockquote><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1] 视觉SLAM十四讲:从理论到实践</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>特征点法slam中位姿估计方法总结</title>
    <link href="/2019/04/21/2019-04-21-pose-estimation/"/>
    <url>/2019/04/21/2019-04-21-pose-estimation/</url>
    
    <content type="html"><![CDATA[<p>这篇博客主要是对基于特征点匹配的slam中的位姿估计方法进行总结。</p><h2 id="2d-2d的位姿估计"><a href="#2d-2d的位姿估计" class="headerlink" title="2d-2d的位姿估计"></a>2d-2d的位姿估计</h2><p>一般用在单目slam的初始阶段，系统还没有地图，此时只有输入的2d的图片序列。一般会使用如下方法进行位姿估计。而RGBD与双目系统中，无需进行初始化。</p><ol><li><p>首先通过对极约束求解出本质矩阵(比较经典的有八点法)，然后对本质矩阵进行奇异值分解(SVD)，求解出R与t;</p><ul><li>原理公式$ E &#x3D; t^{\land}R $(<a href="https://xhy3054.github.io/epipolar-geometry/">对极约束</a>)</li></ul></li><li><p>通过单应约束求解出单应矩阵，然后通过对单应矩阵进行分解求解出R与t;</p><ul><li>原理公式$ H &#x3D; K(R + t \cdot -\frac{n^{T}}{d}) K^{-1} $ (<a href="https://xhy3054.github.io/Homography-matrix/">单应约束</a>)</li></ul></li></ol><blockquote><p>这两种方法有一个共同的缺点，那就是尺度不确定性。所以，在单目slam中，尺度是不确定的，通常，我们会对初始化时的平移向量t进行归一化，此后，建立的地图与整个之后的位姿都是以初始化时的位移作为单位进行的。<strong>这个特性导致特征点法的单目vo是尺度不确定的</strong>。在初始化之后，单目相机就会使用下面的3d-2d方法进行位姿估计</p></blockquote><blockquote><p>此处再讨论一下为什么对极约束没有单应约束强，还有必须有位移等缺点，还是首先使用对极约束进行初始化。这时因为单应约束有平面场景要求，使得初始化时必须有平面场景。</p></blockquote><h2 id="3d-2d的位姿估计（PnP问题）"><a href="#3d-2d的位姿估计（PnP问题）" class="headerlink" title="3d-2d的位姿估计（PnP问题）"></a>3d-2d的位姿估计（PnP问题）</h2><p>在slam正常运行起来之后，会同时建立起基于离散点的地图。在这个时候，当新读入一张图片时，我们可以直接将地图点与新图中的特征点进行匹配。此时通过3d-2d的位姿估计会比2d-2d的方法稳定，方便很多。通常我们将3d-2d的位姿估计问题叫做<strong>PnP问题</strong>。PnP问题有很多求解方法，比如</p><ol><li><p>直接线性变换(DLT, Direct Linear Transformation): 最少需要6对匹配点</p></li><li><p>P3P(perspective three point): 最少需要3对点即可</p></li><li><p>EPnP(Efficient PnP: an accurate o(n) solution to the pnp problem)</p></li><li><p>UPnP等线性方法</p></li><li><p>Bundle Adjustment(最小化重投影误差)等非线性优化方法</p></li></ol><blockquote><p>这些方法在opencv中基本都有函数接口提供</p></blockquote><h2 id="3d-3d的位姿估计"><a href="#3d-3d的位姿估计" class="headerlink" title="3d-3d的位姿估计"></a>3d-3d的位姿估计</h2><p>3d-3d的位姿估计指的是我们拥有一组配对好的3d点，然后根据其恢复出位姿，这个问题一般不会很强调是视觉的slam了，因为一组配对好的3d点与相机模型基本没有太大的关系了,在激光slam中也有可能会碰到ICP，不过由于激光数据特征不够丰富，因此我们很难知道两个点集之间的匹配关系。</p><p>一般这种问题会使用迭代最近点(Iterative Closest Point, ICP)思想，求解方法主要分为两种方式:</p><ol><li><p>基于线性代数的求解</p><ul><li>SVD</li></ul></li><li><p>基于非线性优化方式的求解</p><ul><li>确定目标函数，并进行非线性优化</li></ul></li></ol><blockquote><p>这种位姿估计的场景其实在视觉slam中一般用来估计与校正回环的累积误差，计算能使回环对齐的相似变换。不过在RGBD与双目相机系统中，也可以使用这种方法来计算位姿。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p><a href="https://github.com/xhy3054/myslam/tree/master/04-VO-feature/pose_estimation_2d2d">2d-2d</a>代码、<a href="https://github.com/xhy3054/myslam/tree/master/04-VO-feature/pose_estimation_3d2d">3d-2d</a>代码、<a href="https://github.com/xhy3054/myslam/tree/master/04-VO-feature/pose_estimation_3d3d">3d-3d</a>代码</p></blockquote><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1] 视觉SLAM十四讲， 高翔，张涛等著</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单目vo中的深度确定方法--三角测量</title>
    <link href="/2019/04/20/2019-04-20-triangulation/"/>
    <url>/2019/04/20/2019-04-20-triangulation/</url>
    
    <content type="html"><![CDATA[<p>三角测量的目的是用来确定图片中某一个点的深度。为什么会有这样的需求呢？我们在前面的博客中提到了<a href="https://xhy3054.github.io/epipolar-geometry/">对极几何</a>与<a href="https://xhy3054.github.io/Homography-matrix/">单应变换</a>。在前面其实已经提到过了，在单目VO中，虽然我们可以通过本质矩阵与单应矩阵恢复出相机变换的位姿，但是这两种方法确定的位姿变换是具有<strong>尺度不确定性</strong>的。<strong>在双目vo中，我们会首先使用三角测量恢复出深度信息，再进行位姿估计</strong>。</p><blockquote><p>因为基础矩阵与单应矩阵本身描述的是从<strong>一个2d平面到另一个2d平面的变换</strong>，无需3d深度信息，这两种变换都是正常进行的，因此自然就具有尺度不确定性。更加具体的讲，将基础矩阵与单应矩阵作用在一个齐次坐标(x,y,1)上时，此时，随意的将基础矩阵与单应矩阵进行一定尺度缩放，由于<strong>齐次坐标的尺度等价性</strong>，对最终的变换结果都不会产生影响。</p></blockquote><h2 id="三角测量"><a href="#三角测量" class="headerlink" title="三角测量"></a>三角测量</h2><p>三角测量本身是由高斯提出，最早应用在天文地理领域，根据<strong>不同季节观察到的星星的角度</strong>，估计星星与我们的距离。</p><p>在相机几何中的应用，推导如下：</p><div style="text-align: center"><img src="/img/triangulation/3_Triangulation.PNG"/></div><blockquote><p>注意，三角测量依据的是<strong>同一个空间点</strong>在不同时刻的投影到相机成像平面上的位置来确定这两个时刻时这个点的深度。</p></blockquote><h2 id="第一种思路"><a href="#第一种思路" class="headerlink" title="第一种思路"></a>第一种思路</h2><p>由<a href="https://xhy3054.github.io/camerca-module/">相机成像的几何描述</a>我们可以理解如下的公式(世界坐标到像素坐标的转换)：</p><p>$$ Z_1p_{uv1} = K_1P_w   $$</p><p>$$ Z_2p_{uv2} = K_2(RP_w + t)   $$</p><p>其中K是相机内参，R与t是第二个相机在第一个相机的相机坐标系下的外参，$P_w$是此空间点在第一个相机的相机坐标系下的坐标。Z是空间点到相机光心的距离(也是相机坐标系下的z轴坐标)。$p_{uv1}$与$p_{uv2}$是空间点$P_w$在两个相机平面上的投影点。</p><ul><li>首先做出如下定义（其中$x_1$与$x_2$是归一化的相机坐标（X/Z,Y/Z,1））：</li></ul><p>$$ x_1 = K_1^{-1}p_{uv1} $$</p><p>$$ x_2 = K_2^{-1}p_{uv2} $$ </p><ul><li>带入如上定义可得：</li></ul><p>$$ Z_2 x_2 = Z_1 Rx_1 + t $$</p><ul><li>由于我们已经通过本质矩阵分解或者单应矩阵分解获得了R与t，此时想求的是两个特征点的深度，即上式中的$Z_1$与$Z_2$，此时，可通过如下操作分别求出，首先求解$Z_1$，上式两边同时左乘<code>x2^</code>，也就是两侧同时与$x_2$做外积：</li></ul><p>$$ Z_2 x_2^{\land} x_2 = 0 = Z_1 x_2^{\land}Rx_1 + x_1^{\land}t $$</p><p>如上，可以直接求出$p_{uv1}$的深度$Z_1$了，然后$Z_1$也可以很轻松地求出。</p><h2 id="代码实现（自己实现）"><a href="#代码实现（自己实现）" class="headerlink" title="代码实现（自己实现）"></a>代码实现（自己实现）</h2><p>首先是上述思路的解法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">depthFromTriangulation</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> SE3&amp; T_search_ref,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> Vector3d&amp; f_ref,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> Vector3d&amp; f_cur,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">double</span>&amp; depth)</span></span><br><span class="hljs-function"></span>&#123;<br>    Matrix&lt;<span class="hljs-type">double</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>&gt; A;<br>    A &lt;&lt; T_search_ref.<span class="hljs-built_in">rotation_matrix</span>()*f_ref, f_cur;<br>    <span class="hljs-type">const</span> Matrix2d AtA = A.<span class="hljs-built_in">transpose</span>()*A;<br>    <span class="hljs-keyword">if</span>(AtA.<span class="hljs-built_in">determinant</span>() &lt; <span class="hljs-number">0.000001</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">const</span> Vector2d depth2 = - AtA.<span class="hljs-built_in">inverse</span>()*A.<span class="hljs-built_in">transpose</span>()*T_search_ref.<span class="hljs-built_in">translation</span>();<br>    depth = <span class="hljs-built_in">fabs</span>(depth2[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="第二种思路"><a href="#第二种思路" class="headerlink" title="第二种思路"></a>第二种思路</h2><p>然后此处使用的求解方法是$Cramer’s$法则。这是另一种求解三角化的方式，推导如下：</p><p>$$ Z_{2} x_{2} - Z_{1} Rx_{1} = t $$</p><p>对公式两侧同时乘以$x_{2}^T$，得到：</p><p>$$ Z_{2} x_{2}^T x_{2} - Z_{1} x_{2}^T R x_{1} = x_{2}^T t $$</p><p>公式两侧同时乘以$(Rx_{1})^T$，得到：</p><p>$$ Z_{2} (Rx_{1})^T x_{2} - Z_{1} (Rx_{1})^T Rx_{1} = (Rx_{1})^Tt $$</p><p>对于上述两个公式组成的方程组，利用克莱默法则求解</p><p>$$<br>\left[ \begin{array}{cc}{\mathrm{x}<em>{2}^{T} x</em>{2}} &amp; {-\mathrm{x}<em>{2}^{T} R x</em>{1}} \ {\left(R x_{1}\right)^{\mathrm{T}} x_{2}} &amp; {-\left(R x_{1}\right)^{\mathrm{T}}\left(R x_{1}\right)}\end{array}\right] \left[ \begin{array}{c}{Z_{2}} \ {Z_{1}}\end{array}\right]=\left[ \begin{array}{c}{\mathrm{x}<em>{2}^{T} t} \ {\left(R x</em>{1}\right)^{\mathrm{T}} t}\end{array}\right]<br>$$</p><p>克莱默法则是，对于$Ax=b$这样的方程，如果$A$的行列式不为0，方程可以通过如下方式求解：</p><p>$$<br>x_{1}=\frac{\operatorname{det} B_{1}}{\operatorname{det} A} \quad x_{2}=\frac{\operatorname{det} B_{2}}{\operatorname{det} A} \quad x_{n}=\frac{\operatorname{det} B_{n}}{\operatorname{det} A}<br>$$</p><p>其中$B_{j}$是$A$的第$j$列被$b$替换后得到的新的矩阵。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 方程</span><br>    <span class="hljs-comment">// d_ref * f_ref = d_cur * ( R_RC * f_cur ) + t_RC</span><br>    <span class="hljs-comment">// =&gt; [ f_ref^T f_ref, -f_ref^T f_cur ] [d_ref] = [f_ref^T t]</span><br>    <span class="hljs-comment">//    [ f_cur^T f_ref, -f_cur^T f_cur ] [d_cur] = [f_cur^T t]</span><br>    <span class="hljs-comment">// 二阶方程用克莱默法则求解并解之</span><br>    Vector3d t = T_R_C.<span class="hljs-built_in">translation</span>();<br>    Vector3d f2 = T_R_C.<span class="hljs-built_in">rotation_matrix</span>() * f_curr; <br>    Vector2d b = <span class="hljs-built_in">Vector2d</span> ( t.<span class="hljs-built_in">dot</span> ( f_ref ), t.<span class="hljs-built_in">dot</span> ( f2 ) );<br>    <span class="hljs-comment">// 此处计算出系数矩阵A</span><br>    <span class="hljs-type">double</span> A[<span class="hljs-number">4</span>];<br>    A[<span class="hljs-number">0</span>] = f_ref.<span class="hljs-built_in">dot</span> ( f_ref );<br>    A[<span class="hljs-number">2</span>] = f_ref.<span class="hljs-built_in">dot</span> ( f2 );<br>    A[<span class="hljs-number">1</span>] = -A[<span class="hljs-number">2</span>];<br>    A[<span class="hljs-number">3</span>] = - f2.<span class="hljs-built_in">dot</span> ( f2 );<br>    <span class="hljs-comment">// 此处计算A的行列式</span><br>    <span class="hljs-type">double</span> d = A[<span class="hljs-number">0</span>]*A[<span class="hljs-number">3</span>]-A[<span class="hljs-number">1</span>]*A[<span class="hljs-number">2</span>];<br>    Vector2d lambdavec = <br>        <span class="hljs-built_in">Vector2d</span> (  A[<span class="hljs-number">3</span>] * <span class="hljs-built_in">b</span> ( <span class="hljs-number">0</span>,<span class="hljs-number">0</span> ) - A[<span class="hljs-number">1</span>] * <span class="hljs-built_in">b</span> ( <span class="hljs-number">1</span>,<span class="hljs-number">0</span> ),<br>                    -A[<span class="hljs-number">2</span>] * <span class="hljs-built_in">b</span> ( <span class="hljs-number">0</span>,<span class="hljs-number">0</span> ) + A[<span class="hljs-number">0</span>] * <span class="hljs-built_in">b</span> ( <span class="hljs-number">1</span>,<span class="hljs-number">0</span> )) /d;<br>    Vector3d xm = <span class="hljs-built_in">lambdavec</span> ( <span class="hljs-number">0</span>,<span class="hljs-number">0</span> ) * f_ref;<br>    Vector3d xn = t + <span class="hljs-built_in">lambdavec</span> ( <span class="hljs-number">1</span>,<span class="hljs-number">0</span> ) * f2;<br>    Vector3d d_esti = ( xm+xn ) / <span class="hljs-number">2.0</span>;  <span class="hljs-comment">// 三角化算得的深度向量</span><br>    <span class="hljs-type">double</span> depth_estimation = d_esti.<span class="hljs-built_in">norm</span>();   <span class="hljs-comment">// 深度值</span><br></code></pre></td></tr></table></figure><hr><h2 id="代码实现（使用opencv提供的接口）"><a href="#代码实现（使用opencv提供的接口）" class="headerlink" title="代码实现（使用opencv提供的接口）"></a>代码实现（使用opencv提供的接口）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">triangulation</span> <span class="hljs-params">( </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> vector&lt; KeyPoint &gt;&amp; keypoint_1, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> vector&lt; KeyPoint &gt;&amp; keypoint_2, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> std::vector&lt; DMatch &gt;&amp; matches,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> Mat&amp; R, <span class="hljs-type">const</span> Mat&amp; t, </span></span><br><span class="hljs-params"><span class="hljs-function">    vector&lt; Point3d &gt;&amp; points )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//相机第一个位置处的位姿</span><br>    Mat T1 = (<span class="hljs-built_in">Mat_</span>&lt;<span class="hljs-type">float</span>&gt; (<span class="hljs-number">3</span>,<span class="hljs-number">4</span>) &lt;&lt;<br>        <span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<br>        <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<br>        <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//相机第二个位置处的位姿</span><br>    Mat T2 = (<span class="hljs-built_in">Mat_</span>&lt;<span class="hljs-type">float</span>&gt; (<span class="hljs-number">3</span>,<span class="hljs-number">4</span>) &lt;&lt;<br>        R.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), R.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>), R.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>), t.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),<br>        R.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>), R.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>), R.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>), t.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>),<br>        R.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>), R.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>), R.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>), t.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)<br>    );<br>    <br>    <span class="hljs-comment">// 相机内参</span><br>    Mat K = ( <span class="hljs-built_in">Mat_</span>&lt;<span class="hljs-type">double</span>&gt; ( <span class="hljs-number">3</span>,<span class="hljs-number">3</span> ) &lt;&lt; <span class="hljs-number">520.9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">325.1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">521.0</span>, <span class="hljs-number">249.7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span> );<br>    vector&lt;Point2f&gt; pts_1, pts_2;<br>    <span class="hljs-keyword">for</span> ( DMatch m:matches )<br>    &#123;<br>        <span class="hljs-comment">// 将像素坐标转换至相机平面坐标，为什么要这一步，上面推导中有讲</span><br>        pts_1.<span class="hljs-built_in">push_back</span> ( <span class="hljs-built_in">pixel2cam</span>( keypoint_1[m.queryIdx].pt, K) );<br>        pts_2.<span class="hljs-built_in">push_back</span> ( <span class="hljs-built_in">pixel2cam</span>( keypoint_2[m.trainIdx].pt, K) );<br>    &#125;<br>    <br>    Mat pts_4d;<br>    <span class="hljs-comment">//opencv提供的三角测量函数</span><br>    cv::<span class="hljs-built_in">triangulatePoints</span>( T1, T2, pts_1, pts_2, pts_4d );<br>    <br>    <span class="hljs-comment">// 转换成非齐次坐标</span><br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;pts_4d.cols; i++ )<br>    &#123;<br>        Mat x = pts_4d.<span class="hljs-built_in">col</span>(i);<br>        x /= x.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-number">3</span>,<span class="hljs-number">0</span>); <span class="hljs-comment">// 归一化</span><br>        <span class="hljs-function">Point3d <span class="hljs-title">p</span> <span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            x.at&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), </span></span><br><span class="hljs-params"><span class="hljs-function">            x.at&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>), </span></span><br><span class="hljs-params"><span class="hljs-function">            x.at&lt;<span class="hljs-type">float</span>&gt;(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>) </span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br>        points.<span class="hljs-built_in">push_back</span>( p );<br>    &#125;<br>&#125;<br><br><span class="hljs-function">Point2f <span class="hljs-title">pixel2cam</span> <span class="hljs-params">( <span class="hljs-type">const</span> Point2d&amp; p, <span class="hljs-type">const</span> Mat&amp; K )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point2f</span><br>    (<br>        ( p.x - K.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) ) / K.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), <br>        ( p.y - K.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) ) / K.<span class="hljs-built_in">at</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <br>    );<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/xhy3054/myslam/tree/master/04-VO-feature/triangulation">代码地址</a></p></blockquote><h2 id="第三种思路（最小二乘法求解深度）"><a href="#第三种思路（最小二乘法求解深度）" class="headerlink" title="第三种思路（最小二乘法求解深度）"></a>第三种思路（最小二乘法求解深度）</h2><ul><li><p>对于某个路标点y,在若干个关键帧$k(0,1,2,…)$中可以观测到</p></li><li><p>首先，对于$\mathbf{y} \in \mathbb{R}^{4}$，是空间点在世界坐标系中的齐次坐标。每次观测为$x_{k} = \left[u_{k}, v_{k}, 1\right]^{T}$，这个是相机成像平面的归一化坐标</p></li><li><p>我们假设投影矩阵为$P_{k}=\left[R_{k}, \mathbf{t}_{k}\right] \in \mathbb{R}^{3 \times 4}$，这个是从world系到camera系的投影</p></li><li><p>所以，投影关系为：</p></li></ul><p>$$\forall k, \lambda_{k} \mathbf{x}<em>{k}=\mathbf{P}</em>{k} \mathbf{y}$$</p><p>其中$\lambda_{k}$为观测点的深度值</p><ul><li>根据上面我们可以知道下式:</li></ul><p>$$\lambda_{k}=\mathbf{P}_{k, 3}^{\top} \mathbf{y}$$</p><p>其中$P_{k, 3}^{\top}$是$P_{k}$的第三行（其中角标T仅仅代表是一个横向量）</p><ul><li>我们再将上式带入投影变换的前两行，就得到：</li></ul><p>$$<br>\begin{aligned} u_{k} \mathbf{P}<em>{k, 3}^{\top} \mathbf{y} &amp;=\mathbf{P}</em>{k, 1}^{\top} \mathbf{y} \ v_{k} \mathbf{P}<em>{k, 3}^{\top} \mathbf{y} &amp;=\mathbf{P}</em>{k, 2}^{\top} \mathbf{y} \end{aligned}<br>$$</p><ul><li>每次观测都可以提供两个这样的方程，将y看做未知量，并将其移到等式一侧，可以得到下式：</li></ul><p>$$<br>\left[\begin{array}{c}{u_{1} \mathbf{P}<em>{1,3}^{\top}-\mathbf{P}</em>{1,1}^{\top}} \ {v_{1} \mathbf{P}<em>{1,3}^{\top}-\mathbf{P}</em>{1,2}^{\top}} \ {\vdots} \ {u_{n} \mathbf{P}<em>{n, 3}^{\top}-\mathbf{P}</em>{n, 1}^{\top}} \ {v_{n} \mathbf{P}<em>{n, 3}^{\top}-\mathbf{P}</em>{n, 2}^{\top}}\end{array}\right] \mathbf{y}=\mathbf{0} \rightarrow \mathbf{D y}=\mathbf{0}<br>$$</p><ul><li>于是，y为D零空间的一个非零元素。</li></ul><h3 id="最小二乘求解"><a href="#最小二乘求解" class="headerlink" title="最小二乘求解"></a>最小二乘求解</h3><p>对于上面问题，由于$\mathbf{D} \in \mathbb{R}^{2 n \times 4}$，在观测时往往是大于等于两次的，很有可能D满秩（4），也就是无零空间。</p><ul><li>此时我们会寻找上式的最小二乘解：</li></ul><p>$$<br>\min <em>{\mathbf{y}}|\mathbf{D} \mathbf{y}|</em>{2}^{2}, \quad \text { s.t. }|\mathbf{y}|=1<br>$$</p><ul><li>求解上述这个最小二乘问题$y^{T}D^{T}Dy$，我们可以通过对$D^{T}D$进行奇异值分解来求解。</li></ul><p>$$<br>\mathbf{D}^{\top} \mathbf{D}=\sum_{i=1}^{4} \sigma_{i}^{2} \mathbf{u}<em>{i} \mathbf{u}</em>{j}^{\top}<br>$$</p><ul><li>其中$\sigma_{i}$为奇异值，并且会由大到小排列（它们对应的特征向量是一组单位正交基），我们找到最小（后面）的那个奇异值，它对应的特征向量，将其转换为齐次坐标，前三维就是y坐标的解了。</li></ul><blockquote><p>通常我们求出来会验证一下该解的有效性，判断条件是$\sigma_{4} \ll \sigma_{3}$。若该条件成立，则认为三角化有效。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// vins中初始化sfm时根据一个三维点在两帧中的投影位置确定三维点位置</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GlobalSFM::triangulatePoint</span><span class="hljs-params">(Eigen::Matrix&lt;<span class="hljs-type">double</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&gt; &amp;Pose0, Eigen::Matrix&lt;<span class="hljs-type">double</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&gt; &amp;Pose1,</span></span><br><span class="hljs-params"><span class="hljs-function">Vector2d &amp;point0, Vector2d &amp;point1, Vector3d &amp;point_3d)</span></span><br><span class="hljs-function"></span>&#123;<br>Matrix4d design_matrix = Matrix4d::<span class="hljs-built_in">Zero</span>();<br>design_matrix.<span class="hljs-built_in">row</span>(<span class="hljs-number">0</span>) = point0[<span class="hljs-number">0</span>] * Pose0.<span class="hljs-built_in">row</span>(<span class="hljs-number">2</span>) - Pose0.<span class="hljs-built_in">row</span>(<span class="hljs-number">0</span>);<br>design_matrix.<span class="hljs-built_in">row</span>(<span class="hljs-number">1</span>) = point0[<span class="hljs-number">1</span>] * Pose0.<span class="hljs-built_in">row</span>(<span class="hljs-number">2</span>) - Pose0.<span class="hljs-built_in">row</span>(<span class="hljs-number">1</span>);<br>design_matrix.<span class="hljs-built_in">row</span>(<span class="hljs-number">2</span>) = point1[<span class="hljs-number">0</span>] * Pose1.<span class="hljs-built_in">row</span>(<span class="hljs-number">2</span>) - Pose1.<span class="hljs-built_in">row</span>(<span class="hljs-number">0</span>);<br>design_matrix.<span class="hljs-built_in">row</span>(<span class="hljs-number">3</span>) = point1[<span class="hljs-number">1</span>] * Pose1.<span class="hljs-built_in">row</span>(<span class="hljs-number">2</span>) - Pose1.<span class="hljs-built_in">row</span>(<span class="hljs-number">1</span>);<br>Vector4d triangulated_point;<br>triangulated_point =<br>      design_matrix.<span class="hljs-built_in">jacobiSvd</span>(Eigen::ComputeFullV).<span class="hljs-built_in">matrixV</span>().<span class="hljs-built_in">rightCols</span>&lt;<span class="hljs-number">1</span>&gt;();<br><span class="hljs-built_in">point_3d</span>(<span class="hljs-number">0</span>) = <span class="hljs-built_in">triangulated_point</span>(<span class="hljs-number">0</span>) / <span class="hljs-built_in">triangulated_point</span>(<span class="hljs-number">3</span>);<br><span class="hljs-built_in">point_3d</span>(<span class="hljs-number">1</span>) = <span class="hljs-built_in">triangulated_point</span>(<span class="hljs-number">1</span>) / <span class="hljs-built_in">triangulated_point</span>(<span class="hljs-number">3</span>);<br><span class="hljs-built_in">point_3d</span>(<span class="hljs-number">2</span>) = <span class="hljs-built_in">triangulated_point</span>(<span class="hljs-number">2</span>) / <span class="hljs-built_in">triangulated_point</span>(<span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="使用概率方法更新矫正深度值"><a href="#使用概率方法更新矫正深度值" class="headerlink" title="使用概率方法更新矫正深度值"></a>使用概率方法更新矫正深度值</h2><p>从上述讲述中，我们已经知道通过两帧图像的匹配点，可以得到一个等式，可以计算出这一点的深度值，所以，如果有n副图像进行匹配，那我们会得到n-1个等式。此时我们就可以计算出这一点的n-1个空间位置的测量值。</p><p>好的测量值是符合正太分布的，噪声符合均匀分布，此时我们可以通过一些概率的方法对多次测量结果进行融合，得到更鲁棒的结果。</p><ul><li><p>在SVO中，使用贝叶斯方法(最大后验概率)进行更新</p></li><li><p>在LSD中，使用卡尔曼滤波进行深度测量值的滤波</p></li></ul><h2 id="其他测距方法"><a href="#其他测距方法" class="headerlink" title="其他测距方法"></a>其他测距方法</h2><ol><li><p>主动方法</p><ul><li>结构光: 光已知空间方向的投影光线的集合称为结构光，结构光激光散斑通过投射具有高度伪随机性的激光散斑，会随着不同距离变换不同的图案，对三维空间直接标记，通过观察物体表面的散斑图案就可以判断其深度。</li><li>ToF: 飞行时间法，通过连续发射光脉冲（一般是不可见光），到被观测物体上，然后接收从物体反射回去的光脉冲，通过探测光脉冲的往返飞行时间来计算被测物体距离。</li><li>LIDAR: 激光雷达</li></ul></li><li><p>使用深度学习构建神经网络对图像深度进行预测</p></li></ol><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1] 《视觉slam十四讲》</li><li>[2] <a href="https://ewenwan.github.io">https://ewenwan.github.io</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于词袋模型的图像匹配</title>
    <link href="/2019/04/19/2019-04-19-bow/"/>
    <url>/2019/04/19/2019-04-19-bow/</url>
    
    <content type="html"><![CDATA[<p>看orb-slam的时候发现它在回环检测的时候使用了基于视觉词袋的图像匹配，现在有了一点心得，虽然还有些东西没有完全吃透，但最近比较忙，可能不会有时间在这里死磕，所以先将目前所得写下来，省的忘了。以后有时间完全吃透了会继续完善这篇文章。</p><h1 id="Bag-of-words模型简介"><a href="#Bag-of-words模型简介" class="headerlink" title="Bag-of-words模型简介"></a>Bag-of-words模型简介</h1><p>词袋模型在信息检索领域使用的比较多，以前上课时就听老师讲过，是很常见的算法。在信息检索中，Bow忽略一个文档中单词出现的顺序、语法、句式等信息，仅仅将文档看成一个集合，集合的元素是单词。如下两个文档：</p><ol><li>Bob likes to play basketball, Jim likes too.</li><li>Bob also likes to play football games.</li></ol><p>基于上面两个文档，我们可以为其创建一个<strong>词典</strong>:</p><pre><code class="hljs">&#123;1:&quot;Bob&quot;, 2:&quot;likes&quot;, 3:&quot;to&quot;, 4:&quot;play&quot;, 5:&quot;basketball&quot;, 6:&quot;also&quot;, 7:&quot;football&quot;, 8:&quot;games&quot;, 9:&quot;Jim&quot;, 10:&quot;too&quot;&#125;</code></pre><p>依据上面这个词典，我们可以将例子中的两个文档表示成如下两个<strong>向量</strong>:</p><ol><li>[1, 2, 1, 1, 1, 0, 0, 0, 1, 1]</li><li>[1, 1, 1, 1, 0, 1, 1, 1, 0, 0]</li></ol><p>向量中每个元素表示词典中相关元素在文档中出现的次数。我们可以通过度量文档向量之间的相似程度来衡量文档之间的相似程度。</p><h1 id="orbslam中的应用"><a href="#orbslam中的应用" class="headerlink" title="orbslam中的应用"></a>orbslam中的应用</h1><p>在局部特征点的视觉词典中，每一个单词是具有某一类特征的特征点。在orbslam中使用了DBoW2这个库，这个库的作者提供的ORB特征的词典是其在很大的图像数据集上离线训练好的，我们可以假设任何一个orb特征点都可以在这个词典里找到自己所属的单词类。</p><blockquote><p>在Vocabulary文件夹下的<code>ORBvoc.txt</code>文件就是词典，大概有150M大小</p></blockquote><h2 id="构造离线词典"><a href="#构造离线词典" class="headerlink" title="构造离线词典"></a>构造离线词典</h2><p>在构造离线词典时，使用了分层K-means树的存储结构，这个结构在快速寻找k近邻里面也会经常用到。大概流程如下（构造必须参数有聚类个数k与深度d）</p><ol><li><p>从训练图像中提取大量特征</p></li><li><p>将抽取的特征描述子使用<code>k-means</code>聚类算法进行聚类(使用汉明距离)，将整个特征空间划分为k类</p></li><li><p>在上一步中划分的每个子空间中，继续利用<code>k-means</code>聚类算法进行聚类</p></li><li><p>重复上述第三步，将描述子空间通过一个k叉树（深度为d）进行划分</p></li></ol><h2 id="单词查找与构造Bag-of-Word"><a href="#单词查找与构造Bag-of-Word" class="headerlink" title="单词查找与构造Bag-of-Word"></a>单词查找与构造Bag-of-Word</h2><ol><li><p>对每一副图片，提取orb特征点</p></li><li><p>对每个orb特征点从词典树的根节点往下遍历，每次进入汉明距离最小的节点，直到抵达叶节点。此时得到这个特征点所属的单词</p></li><li><p>通过上述步骤得到输入图片的向量表示，可以使用这个向量进行图片的搜索、匹配等。</p></li></ol><blockquote><p>从上述构造与查找的过程中，我们发现仍然是在叶子层构建了单词，而树结构中的中间节点仅供快速查找时使用。一支深度为d的kmeans的分层聚类树可以容纳$k^{d}$个单词。在查找某个给定特征对应的单词时，在每一层上只需要与k个聚类中心进行距离度量，一共d层，可以保证对数级别的查找效率。</p></blockquote><h2 id="Bag-of-Word的构造与相似性度量"><a href="#Bag-of-Word的构造与相似性度量" class="headerlink" title="Bag-of-Word的构造与相似性度量"></a>Bag-of-Word的构造与相似性度量</h2><p>我们此处需要讨论一下匹配中的相似度计算的问题。首先考虑的是每个单词的权重应该是不同的，因为我们知道在一个句子中比如“的”、“是”这样的词可能出现的频率非常高，我们无法根据他们判断句子的类型。但是类似“足球”、“壁画”这样的单词对判别句子的作用就更大。所以上面的简单的确定的词袋向量其实是可以改进的。</p><p>在文本检索中，常用的一种做法是<strong>TF-IDF(Term Frequency-Inverse Document Frequency，频率-逆文档频率)</strong>。其中，$TF$部分的思想是<strong>单词在一副图像中出现的频率</strong>越高，他的区分度就越高。$IDF$部分的思想是<strong>单词在字典中出现的频率</strong>越高，那他的区分度就越低。</p><p>这种方法在建立字典时就可以统计出$IDF$的值，比如某个叶子节点$w_{i}$中的特征数量相对于所有特征数量的比例，就是次叶子节点的$IDF$值。假设所有特征数量为$n$，$w_{i}$中的特征数量为$n_{i}$，那么该单词的$IDF$为：</p><p>$$ \operatorname{IDF}<em>{i}=\log \frac{n}{n</em>{i}} $$</p><p>此外，$TF$部分是指某个特征在单个图像中出现的频率。假设图像$A$中，单词$w_{i}$出现了$n_{i}$次，而一共出现的单词次数为$n$，那么$TF$为：</p><p>$$<br>\mathrm{TF}<em>{i}=\frac{n</em>{i}}{n}<br>$$</p><p>最后，对于单词$w_{i}$在这幅图像中的权重等于$TF$与$IDF$的乘积：</p><p>$$<br>\eta_{i}=\mathrm{TF}<em>{i} \times \operatorname{IDF}</em>{i}<br>$$</p><p>在考虑权重之后，对于某个图像$A$，它的特征点可对应到许多个单词，组成它的$Bag-of-Words$：</p><p>$$<br>A=\left\{\left(w_{1}, \eta_{1}\right),\left(w_{2}, \eta_{2}\right), \ldots,\left(w_{N}, \eta_{N}\right)\right\} \triangleq v_{A}<br>$$</p><blockquote><p>由于一般字典会比较大，一副图像中包含的单词种类有限，因此$v_{A}$中会存在大量的零。不过通过词袋向量我们还是可以描述一个图像，只不过这个词袋向量是稀疏的。</p></blockquote><h3 id="相似性对量"><a href="#相似性对量" class="headerlink" title="相似性对量"></a>相似性对量</h3><p>接下来便是如何表示两个词袋向量之间的差异，这个问题其实可以使用很多种方法，在$DBoW$库中如果不指定会默认是$L_{1}$范数形式：</p><p>$$<br>s\left(\boldsymbol{v}<em>{A}-\boldsymbol{v}</em>{B}\right)=2 \sum_{i=1}^{N}\left|\boldsymbol{v}<em>{A i}\right|+\left|\boldsymbol{v}</em>{B i}\right|-\left|\boldsymbol{v}<em>{A i}-\boldsymbol{v}</em>{B i}\right|<br>$$</p><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>下面代码都是基于$DBoW3$库，这时一个$cmake$工程，直接默认方式编译安装即可，使用$cmake$使用它时与其他库一样。，$github$地址是<code>https://github.com/rmsalinas/DBow3</code></p><ol><li><p><a href="">训练字典</a></p></li><li><p><a href="">生成词袋向量并计算相似度</a></p></li></ol><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1] <a href="https://www.cnblogs.com/zjiaxing/p/5548265.html">https://www.cnblogs.com/zjiaxing/p/5548265.html</a></li><li>[2] <a href="https://blog.csdn.net/hzwwpgmwy/article/details/83477990">https://blog.csdn.net/hzwwpgmwy/article/details/83477990</a></li><li>[3] Mur-Artal R, Montiel J M M, Tardos J D. ORB-SLAM: a versatile and accurate monocular SLAM system[J]. IEEE transactions on robotics, 2015, 31(5): 1147-1163.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法总结</title>
    <link href="/2019/04/15/2019-04-15-sort/"/>
    <url>/2019/04/15/2019-04-15-sort/</url>
    
    <content type="html"><![CDATA[<p>排序问题是一个基础问题，这篇博客主要总结一下各种经典常用的有特色的排序算法。</p><h2 id="冒泡排序-bubble-sort"><a href="#冒泡排序-bubble-sort" class="headerlink" title="冒泡排序(bubble sort)"></a>冒泡排序(bubble sort)</h2><blockquote><p>原理：每次从左向右两两进行比较，将较大/小的交换到后面。每一个循环可以确定排好一个数，循环n-1次，完全排序完毕。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp; nums)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; ++i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>-i; ++j)&#123;<br>            <span class="hljs-keyword">if</span>(nums[j]&gt;nums[j+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-type">int</span> temp = nums[j];<br>                nums[j] = nums[j+<span class="hljs-number">1</span>];<br>                nums[j+<span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><blockquote><p>复杂度分析：重复<code>n-1</code>次循环，每次循环比较平均<code>n/2</code>步，因此时间复杂度是<code>o(n^2)</code>，空间复杂度是<code>o(n)</code></p></blockquote><h2 id="插入排序-Insertion-sort"><a href="#插入排序-Insertion-sort" class="headerlink" title="插入排序(Insertion sort)"></a>插入排序(Insertion sort)</h2><blockquote><p>原理：循环n-1次，每次将当前的(从1开始)数插入到前面已经排序完毕序列中合适的位置。</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">void <span class="hljs-keyword">insert_sort(vector&lt;int&gt; </span>&amp;nums)&#123;<br>    for(int i=<span class="hljs-number">1</span><span class="hljs-comment">; i&lt;nums.size(); ++i)&#123;</span><br>        for(int <span class="hljs-keyword">j=i; </span><span class="hljs-keyword">j&gt;0 </span>&amp;&amp; nums[<span class="hljs-keyword">j]&lt;nums[j-1]; </span>--<span class="hljs-keyword">j)&#123;</span><br><span class="hljs-keyword"></span>            int temp = nums[<span class="hljs-keyword">j];</span><br><span class="hljs-keyword"></span>            nums[<span class="hljs-keyword">j] </span>= nums[<span class="hljs-keyword">j-1];</span><br><span class="hljs-keyword"></span>            nums[<span class="hljs-keyword">j-1]= </span>temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><blockquote><p>复杂度分析: 重复<code>n-1</code>次循环，每次循环平均<code>n/4</code>步，因此时间复杂度是<code>o(n^2)</code>,空间复杂度是<code>o(n)</code></p></blockquote><h2 id="选择排序-selection-sort"><a href="#选择排序-selection-sort" class="headerlink" title="选择排序(selection sort)"></a>选择排序(selection sort)</h2><blockquote><p>原理: 每次从乱序数组中找处最大(小)的那个值，将其放在当前乱序数组的头部，最终使得数组有序</p></blockquote><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-type">void</span> selection_sort(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt; &amp;nums)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>()-<span class="hljs-number">1</span>; ++i)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-built_in">min</span>=i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>; j&lt;nums.<span class="hljs-built_in">size</span>(); ++j)&#123;<br>            <span class="hljs-keyword">if</span>(nums[j]&lt;nums[<span class="hljs-built_in">min</span>])   <span class="hljs-built_in">min</span>=j;<br>        &#125;<br>        <span class="hljs-type">int</span> temp = nums[i];<br>        nums[i] = nums[<span class="hljs-built_in">min</span>];<br>        nums[<span class="hljs-built_in">min</span>] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><blockquote><p>复杂度分析: 重复<code>n-1</code>次循环，每次循环平均<code>n/2</code>步，因此时间复杂度是<code>o(n^2)</code>，空间复杂度是<code>o(n)</code></p></blockquote><h2 id="希尔排序-shell-sort"><a href="#希尔排序-shell-sort" class="headerlink" title="希尔排序(shell sort)"></a>希尔排序(shell sort)</h2><p>插入排序的改进版，是一种非稳定排序算法。插入排序的特点:</p><ol><li>插入排序在对几乎已经排好序的数据操作时，效率高，可以达到线性排序的效率</li><li>但一般情况下，插入排序是低效的，因此每次只将数据移动一位</li></ol><p>希尔排序通过多次插入排序，提升插入排序的性能，实例如下:</p><ul><li><p>对于一组数<code>13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10</code></p></li><li><p>首先设置步长为5，则这组数可以如下表示，一共将数据分成了5组</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">13 </span><span class="hljs-number">14</span> <span class="hljs-number">94</span> <span class="hljs-number">33</span> <span class="hljs-number">82</span><br><span class="hljs-symbol">25 </span><span class="hljs-number">59</span> <span class="hljs-number">94</span> <span class="hljs-number">65</span> <span class="hljs-number">23</span><br><span class="hljs-symbol">45 </span><span class="hljs-number">27</span> <span class="hljs-number">73</span> <span class="hljs-number">25</span> <span class="hljs-number">39</span><br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure></li><li><p>然后对于每组(列)进行插入排序，得到</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">13 </span><span class="hljs-number">14</span> <span class="hljs-number">94</span> <span class="hljs-number">33</span> <span class="hljs-number">82</span><br><span class="hljs-symbol">25 </span><span class="hljs-number">59</span> <span class="hljs-number">94</span> <span class="hljs-number">65</span> <span class="hljs-number">23</span><br><span class="hljs-symbol">45 </span><span class="hljs-number">27</span> <span class="hljs-number">73</span> <span class="hljs-number">25</span> <span class="hljs-number">39</span><br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure></li><li><p>上述数组现在变为<code>10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45</code></p></li><li><p>此时设置步长为3,将数据分成了3组</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">14</span> <span class="hljs-number">73</span><br><span class="hljs-symbol">25 </span><span class="hljs-number">23</span> <span class="hljs-number">13</span><br><span class="hljs-symbol">27 </span><span class="hljs-number">94</span> <span class="hljs-number">33</span><br><span class="hljs-symbol">39 </span><span class="hljs-number">25</span> <span class="hljs-number">59</span><br><span class="hljs-symbol">94 </span><span class="hljs-number">65</span> <span class="hljs-number">82</span><br><span class="hljs-number">45</span><br></code></pre></td></tr></table></figure></li><li><p>对上述每组(列)进行插入排序，得到</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">14</span> <span class="hljs-number">13</span><br><span class="hljs-symbol">25 </span><span class="hljs-number">23</span> <span class="hljs-number">33</span><br><span class="hljs-symbol">27 </span><span class="hljs-number">25</span> <span class="hljs-number">59</span><br><span class="hljs-symbol">39 </span><span class="hljs-number">65</span> <span class="hljs-number">73</span><br><span class="hljs-symbol">45 </span><span class="hljs-number">94</span> <span class="hljs-number">82</span><br><span class="hljs-number">94</span><br></code></pre></td></tr></table></figure></li><li><p>最后再以1为步长进行插入排序，就可以得到正确结果了。</p></li></ul><blockquote><p>希尔排序无论初始步长是多少，也无论中间步长是多少，只要最后一遍步长为1，最后的结果就肯定是正确的。前面那么多次的排序只是为了减少最后一次排序的时间。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//此处步长设置为每次2倍递减</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shell_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> gap = nums.<span class="hljs-built_in">size</span>() &gt;&gt; <span class="hljs-number">1</span>; gap &gt; <span class="hljs-number">0</span>; gap &gt;&gt;= <span class="hljs-number">1</span>) &#123; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = gap; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123; <br>            <span class="hljs-type">int</span> temp = nums[i];<br><br>            <span class="hljs-type">int</span> j = i - gap;<br>            <span class="hljs-keyword">for</span> (; j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[j] &gt; temp; j -= gap) &#123;<br>                nums[j + gap] = nums[j];<br>            &#125;<br><br>            nums[j + gap] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><blockquote><p>复杂度分析：希尔排序的复杂度与步长选择有很大关系，最坏情况为<code>o(n^2)</code>，最好复杂度为<code>o(n(logn)^2)</code>，目前已知最好步长序列是(1,5,19,41,109,…)</p></blockquote><h2 id="归并排序-merge-sort"><a href="#归并排序-merge-sort" class="headerlink" title="归并排序(merge sort)"></a>归并排序(merge sort)</h2><blockquote><p>原理：采用分冶思想，首先将数组不断二等分成小数组，然后合并小数组进行排序。具体过程可以参考下图</p></blockquote><div style="text-align: center"><img src="/img/sort/merge.png"  width="800" height="600"/></div>从上图中，我们发现归并排序主要分两个阶段，分与冶。其中冶就是合并序列，合并细节如下:<div style="text-align: center"><img src="/img/sort/merge1.png"  width="800" height="800"/></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span>&#123;<br>    <span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(size)</span></span>;<br>    <span class="hljs-built_in">merge_sort</span>(nums, <span class="hljs-number">0</span>, size<span class="hljs-number">-1</span>, temp);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> e, vector&lt;<span class="hljs-type">int</span>&gt; &amp;temp)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(b&lt;e)&#123;<br>        <span class="hljs-type">int</span> m = (b+e)/<span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">merge_sort</span>(nums, b, m, temp);<br>        <span class="hljs-built_in">merge_sort</span>(nums, m+<span class="hljs-number">1</span>, e, temp);<br>        <span class="hljs-built_in">merge</span>(nums, b, m, e, temp);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> e, vector&lt;<span class="hljs-type">int</span>&gt; &amp;temp)</span></span>&#123;<br>    <span class="hljs-type">int</span> i=b;<br>    <span class="hljs-type">int</span> j=m+<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=m &amp;&amp; j&lt;=e)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i]&lt;=nums[j])&#123;<br>            temp[t++]=nums[i++];<br>        &#125;<br>        <span class="hljs-keyword">else</span> temp[t++]=nums[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=m)&#123;<br>        temp[t++]=nums[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(j&lt;=e)&#123;<br>        temp[t++]=nums[j++];<br>    &#125;<br>    t=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//将排序好的数拷贝到原数组</span><br>    <span class="hljs-keyword">while</span>(b&lt;=e)&#123;<br>        nums[b++]=temp[t++];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><blockquote><p>评价：归并排序是稳定排序，它也是一种十分高效的排序。每次合并操作的平均时间复杂度是<code>o(n)</code>，而完全二叉树的深度是<code>log_2(n)</code>，所以总的时间复杂度是<code>o(nlogn)</code>。归并排序的最好、最坏、平均时间复杂度都是<code>o(nlogn)</code></p></blockquote><h2 id="快速排序-quick-sort"><a href="#快速排序-quick-sort" class="headerlink" title="快速排序(quick sort)"></a>快速排序(quick sort)</h2><blockquote><p>原理：快速排序也利用了<strong>分冶</strong>思想。它的做法是：每次选择一个基准数，将比基准数小的挪到左边，大的挪到右边。然后对左右两部分执行相同操作，直到有序。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span>&#123;<br>    <span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">quick_sort</span>(nums, <span class="hljs-number">0</span>, size<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> e)</span></span>&#123;<br>    <span class="hljs-comment">//每次以第一个元素作为基准数</span><br>    <span class="hljs-keyword">if</span>(b&lt;e)&#123;<br>        <span class="hljs-type">int</span> l=b, r=e;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-keyword">while</span>(nums[r]&gt;=nums[b] &amp;&amp; r&gt;l)  r--;<br>            <span class="hljs-keyword">while</span>(nums[l]&lt;=nums[b] &amp;&amp; l&lt;r)  l++;<br>            <span class="hljs-built_in">swap</span>(nums[r], nums[l]);<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(nums[b], nums[l]);<br>        <span class="hljs-built_in">quick_sort</span>(nums, b, l);<br>        <span class="hljs-built_in">quick_sort</span>(nums, l+<span class="hljs-number">1</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><blockquote><p>评价：快速排序是不稳定排序，平均时间复杂度是<code>o(nlogn)</code>，上面这种解法不需要辅助空间。</p></blockquote><h2 id="堆排序-heap-sort"><a href="#堆排序-heap-sort" class="headerlink" title="堆排序(heap sort)"></a>堆排序(heap sort)</h2><p>堆是一种<strong>完全二叉树</strong>，<strong>大顶堆</strong>：每个节点的值都大于或等于其左右孩子节点的值。<strong>小顶堆</strong>：每个节点的值都小于或等于其左右孩子节点的值。如下:</p><div style="text-align: center"><img src="/img/sort/heap.png"  width="800" height="400"/></div>上述性质的完全二叉树可以直接存储在一个数组中，只要数组中元素满足如下两个条件：1. **大顶堆** : `arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]`2. **小顶堆** : `arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]`<div style="text-align: center"><img src="/img/sort/heap1.png"  width="600" height="120"/></div><blockquote><p>原理：利用<strong>堆</strong>这种数据结构进行排序，将待排序序列构造成一个<strong>大顶堆</strong>，此时整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个大顶堆，得到n-1个元素中的最大值…如此反复，就能得到一个有序序列了。</p></blockquote><p>在一个数组上构造大顶堆时，只需要调整父节点就可以了（如果子节点中有比自己大的，选择最大的子节点与自己交换值）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span>&#123;<br>    <span class="hljs-comment">//构建大顶堆</span><br>    <span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=size/<span class="hljs-number">2</span><span class="hljs-number">-1</span>; i&gt;<span class="hljs-number">0</span>; --i)&#123;<br>        <span class="hljs-comment">//从最后一个非叶子节点开始调整</span><br>        <span class="hljs-built_in">heap_adjust</span>(nums, i, size<span class="hljs-number">-1</span>)<br>    &#125;<br><br>    <span class="hljs-comment">//交换堆顶与末尾元素并重新调整堆结构</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>; i&gt;<span class="hljs-number">0</span>; ++i)&#123;<br>        <span class="hljs-built_in">swap</span>(nums[<span class="hljs-number">0</span>], nums[i]);<br>        <span class="hljs-built_in">heap_adjust</span>(nums, <span class="hljs-number">0</span>, i<span class="hljs-number">-1</span>);<br>    &#125;<br>    <br>&#125;<br><span class="hljs-comment">//这个函数是调整堆，只是为了服务上面函数，所以并不是一个完整的构造堆的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_adjust</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> e)</span></span>&#123;<br>    <span class="hljs-type">int</span> father = i;<br>    <span class="hljs-type">int</span> son = <span class="hljs-number">2</span>*father+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(son&lt;=e)&#123;<br>        <span class="hljs-keyword">if</span>(son+<span class="hljs-number">1</span>&lt;=e &amp;&amp; nums[son]&lt;nums[son+<span class="hljs-number">1</span>])   son++;<br>        <span class="hljs-keyword">if</span>(nums[father]&lt;nums[son])&#123;<br>            <span class="hljs-built_in">swap</span>(nums[father], nums[son]);<br>            father=son;<br>            son=<span class="hljs-number">2</span>*father+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>    <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//此处break是因为下面的本来是调整过的都，如果这一步已经满足了，下面就没有继续的必要了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><blockquote><p>评价：堆排序是不稳定排序，堆执行一次调整需要<code>o(logn)</code>时间，在排序过程中需要遍历所有元素执行堆调整，所以最终时间复杂度是<code>o(nlogn)</code>。</p></blockquote><h1 id="稳定排序与不稳定排序"><a href="#稳定排序与不稳定排序" class="headerlink" title="稳定排序与不稳定排序"></a>稳定排序与不稳定排序</h1><p>相信大家都看到了，上面有一些排序是稳定排序，有一些是不稳定排序。那么它们有什么区别呢？</p><ol><li><p>稳定排序与不稳定排序主要的区别在于对原序列中权值相等的元素的排序结果上。</p></li><li><p>对于权值相等的元素，稳定排序的结果依然会保证这些元素按照原序列中的排序不变。</p></li><li><p>对于权值相等的元素，在经过不稳定排序后，算法不保证这些元素仍按原序列中的顺序。</p></li></ol><blockquote><p>所以稳定排序主要的好处是：对于多个关键字的排序，我们可以使用稳定排序在上一次排序的基础上排序，使得第二次排序结果中关键字权重相等的那些项按照第一个关键字进行排序。</p></blockquote><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1] <a href="http://yansu.org/2015/09/07/sort-algorithms.html">http://yansu.org/2015/09/07/sort-algorithms.html</a></li><li>[2] <a href="https://www.cnblogs.com/chengxiao">https://www.cnblogs.com/chengxiao</a></li><li>[3] 维基百科</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>算法与数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vnc与rdp的对比</title>
    <link href="/2019/04/15/2019-04-15-vnc-rdp/"/>
    <url>/2019/04/15/2019-04-15-vnc-rdp/</url>
    
    <content type="html"><![CDATA[<p>由于个人电脑性能有限，很多时候我们都需要远程登录服务器利用其资源。常见的远程界面连接到计算机有两种方法，一种是VNC(Virtual Network Computing)，另一种是RDP(Remote Desktop Protocol).</p><h2 id="VNC"><a href="#VNC" class="headerlink" title="VNC"></a>VNC</h2><p>VNC(Virtual Network Computing，是一个软件)是基于RFB(Remote Frame Buffer)协议进行通信的，这种协议是一个平台无关的简单显示协议，因为其工作在帧缓存级别上，所以可以应用于所有的窗口系统。</p><p>RFB协议的特点</p><ol><li>基于tcp的应用层协议</li><li>平台无关</li><li>瘦客户机，减少了对客户端的硬件需求</li><li>传图像，服务器端在显存中画好之后将图像传给客户端，客户端仅仅进行图像解码显示，并传送键盘等操作信息给服务器</li><li>对网络要求较高，因为需要传图像</li></ol><h2 id="RDP"><a href="#RDP" class="headerlink" title="RDP"></a>RDP</h2><p>RDP(Remote Desktop Protocol)，远程桌面协议。一般主流系统都会有相应的客户端软件。</p><p>RDP协议的特点：</p><ol><li>基于tcp</li><li>所有计算在服务器端进行，客户端只负责处理网络连接，接受数据，界面显示，设备数据输出</li><li>由于主要传输的是命令，对客户端硬件要求较高<ul><li>比如显示的图像是在客户端生成的，服务器只计算并将数据传回</li></ul></li></ol><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>[1] yansu.org&#x2F;2013&#x2F;03&#x2F;21&#x2F;vnc-vs-rdp.html</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>带环链表问题</title>
    <link href="/2019/04/02/2019-04-12-linked-list-cycle/"/>
    <url>/2019/04/02/2019-04-12-linked-list-cycle/</url>
    
    <content type="html"><![CDATA[<p>昨天去面试，面试官问了我一道带环的链表问题。因为以前一个师姐问过我这个问题，我在网上看到过正确解法，因此很轻松的就写出了解法。但是当面试官让我将这个问题用公式推导出来时，，很尴尬，我忽然脑子僵了，多亏面试官提醒了一下，我才推导出来。</p><blockquote><p>事后回想，总结如下: <strong>任何问题不能只记住解法，而要真正将这个问题弄清楚。</strong></p></blockquote><h1 id="链表结构描述"><a href="#链表结构描述" class="headerlink" title="链表结构描述"></a>链表结构描述</h1><p>其实就是一个6字型的链表问题，一般我们解这样的题，都是设置两个前进节点，一个叫fast，每次走两步，一个叫slow，每次走一步:</p><ol><li><p>假设链表入口到环的入口长度为l1;</p></li><li><p>假设环的入口到第一次相遇点处长度为l2;</p></li><li><p>假设环的长度为s;</p></li></ol><h2 id="问题一-判断链表有没有环"><a href="#问题一-判断链表有没有环" class="headerlink" title="问题一: 判断链表有没有环"></a>问题一: 判断链表有没有环</h2><p>首先明确一点事实：<strong>只有有环，fast与slow总会相遇</strong>。</p><ul><li>当相遇时，slow走了<code>l1+l2</code>，fast走了<code>2(l1+l2)</code>，并且fast比slow多走了n个环的长度；<ul><li>即<code>l1+l2 = ns</code></li></ul></li></ul><blockquote><p>由上面推导可知，l2从0开始，每次加1，直到<code>l1+l2</code>是s的整数倍数时，slow与fast第一次相遇。</p></blockquote><h2 id="问题二-判断链表有没有环，如果有，返回环的长度"><a href="#问题二-判断链表有没有环，如果有，返回环的长度" class="headerlink" title="问题二: 判断链表有没有环，如果有，返回环的长度"></a>问题二: 判断链表有没有环，如果有，返回环的长度</h2><p>在问题一中已经将判断链表有没有环的问题搞清楚了，下面怎么得到环的长度呢？</p><ul><li>在fast与slow第一次相遇后，让二者继续前进，当再次相遇时，slow在这段间隔中走的步数就是环的长度。</li></ul><h2 id="问题三-判断链表有没有环，如果有，返回环入口节点"><a href="#问题三-判断链表有没有环，如果有，返回环入口节点" class="headerlink" title="问题三: 判断链表有没有环，如果有，返回环入口节点"></a>问题三: 判断链表有没有环，如果有，返回环入口节点</h2><p>在问题一中已经将判断链表有没有环的问题搞清楚了，下面怎么得到环的入口节点呢？</p><ul><li>在fast与slow第一次相遇时，从新定义一个前进节点slow2从头出发，slow从当前位置出发，则slow与slow2相遇的节点就是环的入口节点。<ul><li><code>l1+l2+l1 = ns + l1</code></li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是对有环链表的三个思考了，写下来希望自己忘记了可以随时翻看。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法与数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux常用--数据流重定向、管道、组合键、权限、查找等</title>
    <link href="/2019/03/30/2019-03-30-linux-issue/"/>
    <url>/2019/03/30/2019-03-30-linux-issue/</url>
    
    <content type="html"><![CDATA[<p>在学习linux的内容中，存在很多重要有趣有用的小知识，但是这些小知识很繁琐，每一个都写一片博客是不可能的，篇幅太短，所以这篇博客就来将这些小知识来一个大杂烩。</p><ol><li><a href="#数据流重定向">数据流重定向</a></li><li><a href="#管道命令-pipe">管道命令-pipe</a></li><li><a href="#回车与换行的区别">回车与换行的区别</a></li><li><a href="#常用组合键">常用组合键</a></li><li><a href="#bash环境中的特殊字符">bash环境中的特殊字符</a></li><li><a href="#通配符">通配符</a></li><li><a href="#修改文件权限">修改文件权限</a></li><li><a href="#搜索字符串">在linux文件系统中搜索字符串</a></li><li><a href="#搜索文件">在Linux文件系统中搜索</a></li><li><a href="#linux中备份操作tar">linux中备份操作tar</a></li></ol><h2 id="数据流重定向"><a href="#数据流重定向" class="headerlink" title="数据流重定向"></a>数据流重定向</h2><p>要想了解数据流重定向，首先我们得知道数据的输入与输出总共有几种。</p><div style="text-align: center"><img src="/img/linux/redirection.jpg"/></div>如上，命令的输入只有一种，那就是**标准输入(STDIN)**；而输出有两种，一种是**标准输出(STDOUT)**，一种是**标准错误输出(STDERR)**。标准输出(STDOUT)的内容是一个命令正确执行后返回的内容，标准错误输出(STDERR)的内容是一个命令执行过程中出现错误返回的错误信息。<blockquote><p>上述的三种输入输出可以理解为三个不同的<strong>缓冲区</strong>，输入缓冲区只有一个，输出缓冲区有两个。</p></blockquote><p>默认情况下，在终端执行命令时，<strong>STDOUT与STDERR都是默认绑定到了屏幕上</strong>，因此执行一个命令，无论正确执行与否，最终输出都会出现在屏幕上。<strong>STDIN默认绑定在了键盘上</strong>，所以我们可以通过手动输入确定输入内容。</p><p><strong>数据流重定向</strong>要做的就是重新定向这三个缓冲区绑定的字符流设备。重定向方法形式如下</p><ol><li><p>标准输入(stdin): 代码为0，使用<code>&lt;</code>或<code>&lt;&lt;</code>;</p></li><li><p>标准输出(stdout): 代码为1，使用<code>&gt;</code>或<code>&gt;&gt;</code>;</p></li><li><p>标准错误输出(stderr): 代码为2，使用<code>2&gt;</code>或<code>2&gt;&gt;</code>;</p></li><li><p><code>&gt;</code>与<code>&gt;&gt;</code>的区别是：前者是覆盖输入，后者是累加输入；</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">xhy@xhy-SVF14316SCB:~/Music$ <span class="hljs-built_in">ls</span><br>CloudMusic<br>xhy@xhy-SVF14316SCB:~/Music$ <span class="hljs-built_in">ls</span> &gt;&gt; ls_result<br>xhy@xhy-SVF14316SCB:~/Music$ <span class="hljs-built_in">cat</span> ls_result <br>CloudMusic<br>ls_result<br></code></pre></td></tr></table></figure><h2 id="命令执行的连接符号-amp-amp"><a href="#命令执行的连接符号-amp-amp" class="headerlink" title="命令执行的连接符号; &amp;&amp; ||"></a>命令执行的连接符号<code>; &amp;&amp; ||</code></h2><ul><li><p><code>cmd1; cmd2</code>: 顺序执行cmd1与cmd2</p></li><li><p><code>cmd1 &amp;&amp; cmd2</code>: </p><ul><li>若cmd1执行完毕且正确执行(<code>$?=0</code>指令回传值为0)，则开始执行cmd2；</li><li>若cmd1执行完毕且错误执行(指令回传值不为0)，则cmd2不执行；</li></ul></li><li><p><code>cmd1 || cmd2</code>:</p><ul><li>若cmd1执行完毕且正确执行(<code>$?=0</code>指令回传值为0)，则cmd2不执行；</li><li>若cmd1执行完毕且错误执行(指令回传值不为0)，则开始执行cmd2；</li></ul></li></ul><h2 id="管道命令-pipe"><a href="#管道命令-pipe" class="headerlink" title="管道命令-pipe"></a>管道命令-pipe</h2><p>首先说明一下，管道命令要实现的功能如下图，其实就是对于输入进行一系列的连续处理。</p><div style="text-align: center"><img src="/img/linux/redirection.jpg"/></div>关于管道命令，可以总结如下几点：1. 管道命令用`|`来连接命令，实现将前一个命令的stdout变成后一个命令的stdin；<ol start="2"><li><p>管道命令默认是对stdout起作用，对于stderr不起作用</p></li><li><p>如果一个命令不能接受stdin，则这个命令不能作为管道中的后置命令</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">xhy@xhy-SVF14316SCB:~/book$ ll<br>total 16<br>drwxrwxr-x  4 xhy xhy 4096 3月  20 15:34 ./<br>drwxr-xr-x 41 xhy xhy 4096 3月  30 20:11 ../<br>drwxrwxr-x 10 xhy xhy 4096 3月  20 15:33 book_note/<br>drwxr-xr-x  2 xhy xhy 4096 3月  20 23:31 工具书/<br>xhy@xhy-SVF14316SCB:~/book$ ll | grep book_note<br>drwxrwxr-x 10 xhy xhy 4096 3月  20 15:33 book_note/<br></code></pre></td></tr></table></figure><blockquote><p>其实管道命令涉及到了数据流重定向的功能。如果想让stderr可以被管道命令使用，需要使用数据流重定向，将<code>2&gt;</code>变成<code>1&gt;</code></p></blockquote><h2 id="回车与换行的区别"><a href="#回车与换行的区别" class="headerlink" title="回车与换行的区别"></a>回车与换行的区别</h2><ol><li><p><code>\r</code>:   回车，打印效果是将输出重定位到<strong>本行</strong>的开头</p></li><li><p><code>\n</code>:   换行，打印效果是将输出重定位到<strong>下一行</strong>的开头</p></li></ol><h2 id="常用组合键"><a href="#常用组合键" class="headerlink" title="常用组合键"></a>常用组合键</h2><div style="text-align: center"><img src="/img/linux/combine_input.png"/></div><h2 id="bash环境中的特殊字符"><a href="#bash环境中的特殊字符" class="headerlink" title="bash环境中的特殊字符"></a>bash环境中的特殊字符</h2><div style="text-align: center"><img src="/img/linux/special_character.png"/></div><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><div style="text-align: center"><img src="/img/linux/common_character.png"/></div><h2 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h2><p>语法：</p><pre><code class="hljs">chmod [-cfvR] [--help] [--version] mode file</code></pre><p>参数说明：</p><ul><li><p>$-c$: 若该文件权限确实已经更改，才显示其更改动作</p></li><li><p>$-f$: 若该文件权限无法被更改也不要显示错误信息</p></li><li><p>$-v$: 显示权限变更的详细资料</p></li><li><p>$-R$: 对当前目录下的所有文件与子目录进行相同的权限变更</p></li><li><p>$–help$: 显示辅助说明</p></li><li><p>$–version$: 显示版本</p></li></ul><p>$mode$是设置权限，用字符串来表示，格式如下：</p><pre><code class="hljs">[ugoa...][[+-=][rwxX]...][,...]</code></pre><p>其中：</p><ul><li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</li><li>$+$ 表示增加权限、$-$ 表示取消权限、$=$ 表示唯一设定权限。</li><li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul><li>将文件$file1.txt$设为所有人皆可读取 :<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> ugo+r file1.txt<br><span class="hljs-built_in">chmod</span> a+r file1.txt<br></code></pre></td></tr></table></figure></li><li>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> ug+w,o-w file1.txt file2.txt<br></code></pre></td></tr></table></figure></li><li>将目前目录下的所有文件与子目录皆设为任何人可读取 :<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> -R a+r *<br></code></pre></td></tr></table></figure></li><li>也可以使用数字来表示权限（r=4，w=2，x=1），下面两组作用相同<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">chmod <span class="hljs-number">777</span> <span class="hljs-built_in">file</span><br>chmod <span class="hljs-keyword">a</span>=rwx <span class="hljs-built_in">file</span><br><br>chmod ug=rwx,o=x <span class="hljs-built_in">file</span><br>chmod <span class="hljs-number">771</span> <span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="搜索字符串"><a href="#搜索字符串" class="headerlink" title="搜索字符串"></a>搜索字符串</h2><p>在linux的文件系统中搜索字符串一般使用<code>grep</code>命令，下面这个命令是在当前目录下的所有文件中递归搜索字符串<code>string</code>:</p><pre><code class="hljs">grep -r string ./</code></pre><h2 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h2><p>在linux的文件系统中搜索文件一般使用<code>find</code>命令，下面这个命令是在当前目录下搜索<code>2019-03-30-linux-issue.markdown</code>这个文件</p><pre><code class="hljs">find ./ -name 2019-03-30-linux-issue.markdown</code></pre><h2 id="linux中备份操作tar"><a href="#linux中备份操作tar" class="headerlink" title="linux中备份操作tar"></a>linux中备份操作tar</h2><blockquote><p>Linux的tar命令用于建立和还原备份文件。这个命令其实是很复杂的，，，所以此处仅仅列出常用的。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">###### tar格式（该格式仅仅打包，不压缩）######</span><br><span class="hljs-comment"># 打包</span><br>tar -cvf [目标文件名].tar [原文件名/目录名]<br><span class="hljs-comment"># 解包</span><br>tar -xvf [原文件名].tar<br><span class="hljs-comment"># c参数代表create（创建），x参数代表extract（解包），v参数代表verbose（详细信息），f参数代表filename（文件名），所以f后必须接文件名。</span><br><br><span class="hljs-comment">###### tar.gz格式（打包加压缩） ######</span><br><span class="hljs-comment"># 打包并压缩</span><br>tar -zcvf [目标文件名].tar.gz [原文件名/目录名]<br><span class="hljs-comment"># 解压并解包</span><br>tar -zxvf [原文件名].tar.gz<br><span class="hljs-comment"># z代表用gzip算法来压缩/解压。</span><br><br><span class="hljs-comment">###### tar.bz2格式（打包并压缩） ######</span><br><span class="hljs-comment"># 打包并压缩</span><br>tar -jcvf [目标文件名].tar.bz2 [原文件名/目录名]<br><span class="hljs-comment"># 解压并解包</span><br>tar -jxvf [原文件名].tar.bz2<br><span class="hljs-comment"># 小写j代表使用bzip2算法来压缩、解压。</span><br><br><span class="hljs-comment">###### tar.xz格式（打包并压缩） ######</span><br><span class="hljs-comment"># 打包并压缩</span><br>tar -Jcvf [目标文件名].tar.xz [原文件名/目录名]<br><span class="hljs-comment"># 打包并解压</span><br>tar -Jxvf [原文件名].tar.xz<br><span class="hljs-comment"># 大写J代表用xz算法来压缩/解压。</span><br><br><span class="hljs-comment">###### 其他tar.z jar 7z等格式使用了再找吧。</span><br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] 《鸟哥的linux私房菜》；</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备忘vim编辑器</title>
    <link href="/2019/03/30/2019-03-30-vim/"/>
    <url>/2019/03/30/2019-03-30-vim/</url>
    
    <content type="html"><![CDATA[<p>经常需要在linux环境下进行开发，不可避免的要使用vim。为了方便每次查阅与温习，在这篇博客里记录一些常用功能操作与我熟悉的一些基本配置。</p><h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p>vim本身就是一个编辑器，就像是windows的text一样，但是这个编辑器有很多的命令与快捷操作方式可以大大的节省我们开发编辑的时间。</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul><li><p>一般命令模式下的普通命令</p><ul><li>dd : 剪切光标所在的那一整行到剪切板，会覆盖原先剪切板内容</li><li>yy : 复制光标所在的那一整行到剪切板，会覆盖原先剪切板内容</li><li>p  : 将剪切板的内容粘贴到光标下一行，并将光标移到下一行</li><li>P  : 将剪切板的内容粘贴到光标上一行，并将光标移到被粘贴的那一行</li><li>u  : 撤销上一次操作（可以是上一次编辑模式下的改变，也可以是上一次命令操作的改变）</li><li>[Ctrl]+r : 重复做一遍上一个动作</li><li>G  : 光标跳转到最后一行</li><li>gg : 光标跳转到第一行</li><li>i  : 进入编辑模式，光标位置不变</li><li>o  : 进入编辑模式，并且在下一行插入一个空白行，再将光标移到下一行 </li></ul></li><li><p>一般命令模式下的命令行操作</p><ul><li>:w    : 保存现在对文件的修改</li><li>:w filename : 将现在的文件另存为filename</li><li>:q    : 退出vim</li><li>:!    : 强制操作，一般感叹号放在操作后面</li><li>:10   : 光标跳转到第10行</li><li>/word : 从光标处往下寻找word这个字符串</li><li>?word : 从光标处往上寻找word这个字符串</li><li>:100,200s/word1/word2/g : 在100行与200行之间寻找word1这个字符串，并将字符串取代为word2</li><li>:100,200s/word1/word2/gc : 在100行与200行之间寻找word1这个字符串，并将字符串取代为word2，并且在取代前显示提示字符给使用者确认是否要执行操作</li></ul></li><li><p>编辑模式：</p><ul><li>[Ctrl]+p : 按照上文中出现的字符串进行补全</li><li>esc： 退出编辑模式，进入一般命令模式</li></ul></li></ul><div style="text-align: center"><img src="/img/vim/regular_vim.jpg"/></div><h2 id="区块选择"><a href="#区块选择" class="headerlink" title="区块选择"></a>区块选择</h2><p>一共有三种区块选择方式，都是在一般命令模式下进行操作</p><div style="text-align: center"><img src="/img/vim/Block.PNG"/></div><h2 id="多文件编辑1"><a href="#多文件编辑1" class="headerlink" title="多文件编辑1"></a>多文件编辑1</h2><p>通过<code>vim file1 file2</code>打开两个文件，并且在其中一个文件拷贝到粘贴板上的文本可以在另一个文件中使用。</p><div style="text-align: center"><img src="/img/vim/multifiles.PNG"/></div><h2 id="多文件编辑2"><a href="#多文件编辑2" class="headerlink" title="多文件编辑2"></a>多文件编辑2</h2><blockquote><p>上面那种方式我用起来感觉不是很舒服，也不是很会用，这第二种方法用起来感觉比较好</p></blockquote><ul><li><p>通过<code>tabedit file2</code>打开第二个文件</p></li><li><p>通过<code>tabn</code>切换到下一个文件</p></li><li><p>通过<code>tabp</code>切换到上一个文件 </p></li><li><p>这种模式下多文件间剪切板是共用的</p></li></ul><h2 id="多窗口编辑"><a href="#多窗口编辑" class="headerlink" title="多窗口编辑"></a>多窗口编辑</h2><p>这种模式下会将一个窗口划分为多个窗口，在文件比较长需要前后对应时可以使用。使用方式下面讲的很详细。</p><div style="text-align: center"><img src="/img/vim/multiwindows.PNG"/></div><h2 id="我的vim常用设置"><a href="#我的vim常用设置" class="headerlink" title="我的vim常用设置"></a>我的vim常用设置</h2><p>在<code>/etc/vim/vimrc</code>（个人账户的设置是<code>~/.vimrc</code>配置文件，默认不存在，需要自己手动创建）中，我们可以对vim这个编辑器进行一些常用的设置。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">set</span> showmatch       <span class="hljs-comment">&quot; Show matching brackets.</span><br><span class="hljs-keyword">set</span> hlsearch        <span class="hljs-comment">&quot; heighlight the search result</span><br><span class="hljs-keyword">set</span> incsearch       <span class="hljs-comment">&quot; auto jump to search result</span><br><span class="hljs-keyword">set</span> autoread        <span class="hljs-comment">&quot; auto check the file whether be changed by other editor</span><br><span class="hljs-keyword">set</span> cursorline      <span class="hljs-comment">&quot; heighlight the cursorline</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">number</span> <br><span class="hljs-keyword">set</span> <span class="hljs-keyword">ts</span>=<span class="hljs-number">4</span>            <span class="hljs-comment">&quot; set one tab = 4 blank length</span><br><span class="hljs-keyword">set</span> expandtab       <span class="hljs-comment">&quot; if new editor&#x27;s tab&#x27;s length is not equal,convert the tab to blank</span><br></code></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul><li><p>有时我们在编辑文件后没有保存就因为各种原因强制退出了，这时会在当前目录下生成一个缓存文件，这个缓存文件不手动删除会一直存在</p></li><li><p>编码问题</p><ul><li>linux系统默认支持的语系数据：这与<code>/etc/locale.conf</code>有关</li><li>终端接口(bash)的语系：与<code>LANG</code>、<code>LC_ALL</code>几个环境变量有关</li><li>文件的编码方式</li><li>打开文件的软件的接口的编码方式</li></ul></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] 《鸟哥的linux私房菜》；</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>透镜畸变与相机标定</title>
    <link href="/2019/02/19/2019-02-19-camera-calibration-undistort/"/>
    <url>/2019/02/19/2019-02-19-camera-calibration-undistort/</url>
    
    <content type="html"><![CDATA[<p>在<a href="https://xhy3054.github.io/camerca-module/">相机成像的几何描述</a>这篇文章中我们讨论了如何将一个点从世界坐标映射到像素坐标，不过那是比较理想的成像情况。现实世界中的相机在成像时还会受到透镜畸变的影响。</p><blockquote><p>需要说明的是，下面的畸变模型都是基于<strong>针孔模型</strong>(一般的相机)得到的结果。而如果遇到一些特殊的相机，比如说鱼眼相机，它的投影模型会与针孔模型有些不同，它是投影在球面而不是平面上的。这样下面的畸变模型就不管用了。因此对于不同的相机，我们要使用不同的投影模型来建立畸变模型。</p></blockquote><h1 id="透镜畸变"><a href="#透镜畸变" class="headerlink" title="透镜畸变"></a>透镜畸变</h1><p>现代相机为了获得更好的成像效果，相机里一般都加入了透镜。而透镜的加入对成像过程中光线的传播会产生新的影响，进而出现畸变，一般有两种主要的畸变（其实也还有其他的种类的畸变，但是不如这两种明显）：</p><div style="text-align: center"><img src="/img/distort_calibration/distort0.jpg"/></div><h2 id="径向畸变"><a href="#径向畸变" class="headerlink" title="径向畸变"></a>径向畸变</h2><ul><li><strong>径向畸变</strong>：透镜自身的形状对光线传播会有影响；<ul><li>桶形畸变：图像放大率随着与光轴之间的距离增加而减小</li><li>枕形畸变：图像放大率随着与光轴之间的距离增大而增大</li></ul></li></ul><div style="text-align: center"><img src="/img/distort_calibration/distort.png"  width="800" height="300" /></div><ul><li>一般径向畸变对于二维平面上一个坐标(x,y)（如上图畸变最小的点为坐标原点，一般在图像中心，r是点到原点的距离）的影响可以使用如下公式表述：</li></ul><p>$$ x_{distorted} = x( 1 + k_1 r^2 + k_2 r^4 + k_3 r^6)　 \\ y_{distorted} = y( 1 + k_1 r^2 + k_2 r^4 + k_3 r^6) $$</p><blockquote><p>无论是桶形畸变还是枕形畸变，由于他们都是随着与中心之间的距离增加而增加，因此可以使用一个<strong>多项式函数</strong>来描述畸变前后的像素坐标变化。这个公式中，对于畸变较小的图像中心区域，畸变主要是$k_1$在起作用；而对于畸变较大的边缘区域，主要是$k_2$在起作用。一般的普通摄像头用这两个系数就已经可以很好地纠正径向畸变了。但是对于一部分畸变很大的摄像头，比如说鱼眼镜头等，还需要加入$k_3$畸变项才能比较好的表述畸变情况。</p></blockquote><h2 id="切向畸变"><a href="#切向畸变" class="headerlink" title="切向畸变"></a>切向畸变</h2><ul><li><strong>切向畸变</strong>：在机械组装过程中，透镜和成像平面不可能完全平行，这也会使得光线穿过透镜投影到成像面时的位置出现变化；</li></ul><div style="text-align: center"><img src="/img/distort_calibration/distort1.png"/></div><ul><li>一般切向畸变对于二维平面上的坐标(x,y)的影响可以使用如下公式进行表述：</li></ul><p>$$ x_{distorted} = x + [ 2p_1xy + p_2(r^2+2x^2)]  \\ y_{distorted} = y + [ p_1(r^2+ 2y^2)+ 2p_2xy]  $$</p><h2 id="加入畸变的成像-理想情况下"><a href="#加入畸变的成像-理想情况下" class="headerlink" title="加入畸变的成像(理想情况下)"></a>加入畸变的成像(理想情况下)</h2><ul><li><p>首先，世界坐标系下有一个固定的点P，<strong>世界坐标</strong>是 $P_w$</p></li><li><p>获得点P的<strong>相机坐标系坐标</strong>，可以利用相机外参R与t得到 $ P_c = RP_w + t $</p></li><li><p>在2中获得的 $P_c$ 仍然是三维的 (X,Y,Z) ，将其投影到归一化平面 $Z=1$ 上，得到<strong>归一化相机坐标</strong>：$ P_C = [X/Z, Y/Z, 1]^T $</p></li><li><p>此处加入<strong>畸变</strong>因素，畸变公式如下(其中，$x=X/Z, y=Y/Z$)：</p></li></ul><p>$$ x_{distorted} = x( 1 + k_1 r^2 + k_2 r^4 + k_3 r^6) + [ 2p_1xy + p_2(r^2+2x^2)]  \\ y_{distorted} = y( 1 + k_1 r^2 + k_2 r^4 + k_3 r^6) + [ p_1(r^2+ 2y^2)+ 2p_2xy]   $$</p><ul><li>最后一步，利用内参K，将归一化相机坐标转换成<strong>像素坐标</strong>： $ P_{uv} = KP_{distorted} $</li></ul><p>$$ u = f_x x_{distorted} + c_x \\ v = f_y y_{distorted} + c_y  $$</p><blockquote><p>此处之所以将畸变放在内参前面作用，是因为上面已经说过了这个畸变模型假设的原点是图像中心，也就是未经过内参作用时符合。</p></blockquote><h1 id="相机标定"><a href="#相机标定" class="headerlink" title="相机标定"></a>相机标定</h1><p>现在，我们知道，将一个三维世界坐标点通过相机映射到像素平面上一般需要三个矩阵参数，分别是相机外参、相机内参、畸变参数。而获得上述这些参数的过程便叫做<strong>相机标定</strong>。其中相机外参可以由相机的位姿固定获得，一般我们仅仅通过标定获得相机内参与畸变参数。而在某些时候，比如vio或rgbd-slam中，因为除了彩色相机外，也会有第二种传感器–imu或深度相机，此时为了后续的工作，我们也需要对两种传感器之间的外参进行精确标定。</p><blockquote><p>需要说明的是相机标定只是对相机物理特性的<strong>近似</strong>获取。</p></blockquote><p>对于相机的标定工作，已经有了很多的研究，主要可以分为两类：第一类是基于特定的实验条件，如形状、尺寸已知的标定物，利用一系列的数学变换与计算方法进行标定；第二类叫做自标定，不依赖于标定的参照物，仅仅利用摄像机在运动过程中周围环境的图像与图像之间的对应关系进行摄像机进行标定。</p><h2 id="利用棋盘格的参数标定"><a href="#利用棋盘格的参数标定" class="headerlink" title="利用棋盘格的参数标定"></a>利用棋盘格的参数标定</h2><ol><li>棋盘格可以提供很多三维世界中的路标点；</li><li>相机采集后首先检测棋盘的角点；</li><li>通过三维点与二维点的投影方程可以建立很多方程约束；</li><li>通过非线性优化即可求出外参、内参、畸变参数；</li></ol><p>对于一个具有N个格点的棋盘，假设我们拍摄K的角度的照片，则可以得到$2NK$个方程，如果我们想要求解出相机参数，则需要满足方程数量大于参数数量：（下面中K个角度有K组外参）</p><p>$$2NK &gt;= 4 + 6K + 5 $$</p><blockquote><p>此处需要说明的是，按照上述理解，只要一个棋盘上点足够多那不就一个视角就够了吗？这么做其实是不好的，因为在某个视角下，如果我们知道了其中一个格子的四个端点，那我们只需要继续延伸就可以得到其他的格点，那些多余的格点其实是不可以提供额外信息的，因次一个角度最好只利用四个点。这样上面的方程就可以变为</p></blockquote><p>$$ 8K &gt;= 4+6K+5 $$</p><p>即</p><p>$$ 2K &gt;= 9 $$</p><blockquote><p>理论上是这样，但是实际上当然是角度越多，可利用的路标点越多越好。</p></blockquote><h3 id="使用棋盘格标定彩色相机与深度相机的外参"><a href="#使用棋盘格标定彩色相机与深度相机的外参" class="headerlink" title="使用棋盘格标定彩色相机与深度相机的外参"></a>使用棋盘格标定彩色相机与深度相机的外参</h3><ol><li>首先检测棋盘角点；</li><li>明确一点：两个相机拍摄到的这些点在现实世界中是同一个点；</li><li>利用深度相机的深度可以得到这些点在深度相机坐标系的三维坐标；</li><li>假设一个外参R和T，便可以将这些点投影到彩色相机成像平面上；</li><li>最小化重投影误差即可得到最合适的外参；</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] 《视觉SLAM十四讲》，高翔著；</li><li>[2] <a href="https://docs.opencv.org">https://docs.opencv.org</a></li><li>[3] 《学习OpenCV3》,O’REILLY著；</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>射影几何中的单应变换</title>
    <link href="/2019/01/27/2019-01-27-Homography-matrix/"/>
    <url>/2019/01/27/2019-01-27-Homography-matrix/</url>
    
    <content type="html"><![CDATA[<h1 id="各种经典变换总结-2维平面上，三维空间中思想一致，但是自由度不同"><a href="#各种经典变换总结-2维平面上，三维空间中思想一致，但是自由度不同" class="headerlink" title="各种经典变换总结(2维平面上，三维空间中思想一致，但是自由度不同)"></a>各种经典变换总结(2维平面上，三维空间中思想一致，但是自由度不同)</h1><ol><li><p><strong>刚体(欧式)变换</strong>：可以保证两个点在<strong>变换前后欧式距离不变</strong>，具有3个自由度（旋转一个，平移两个）；</p><ul><li>通常是旋转加上平移；</li></ul></li><li><p><strong>相似变换</strong>：通常指相似刚体变换，指增加了缩放的刚体变换，具有4个自由度（刚体的3个再加上缩放尺度），相似变换具有<strong>保角性与保持距离比</strong>的性质；</p><ul><li>通常可以描述为先旋转一次，再缩放一次，最后平移一次；</li></ul></li><li><p><strong>仿射变换</strong>：具有两个旋转因子与两个缩放因子，外加两个平移因子，因此具有6个自由度（其实就是2*3矩阵每个元素都互不相关，都代表一个自由度），以前在<a href="https://xhy3054.github.io/homogeneous-coordinates/">理解齐次坐标</a>中讲的仿射变换严格上来说是仿射变换的子集，甚至可以简单的使用相似变换达到。仿射变换不具有保角性与保持距离比的性质，但是原本的平行线，变换后仍然是平行线；</p><ul><li>通常可以描述为<strong>先</strong>旋转一个角度j1，<strong>然后</strong>在x方向缩放s1，y方向缩放s2，<strong>然后再</strong>反向旋转角度j，<strong>最后</strong>，再旋转一个角度j2，并平移一次；</li></ul></li><li><p><strong>单应变换（也叫投影变换）</strong>：具有8个自由度，它的作用是描述<strong>两个平面上的点的映射关系</strong>。仿射变换的不变性对于投影变换不适用，但是原本共线的三个点在单应变换后仍旧共线。</p></li></ol><h2 id="三维空间中的变换"><a href="#三维空间中的变换" class="headerlink" title="三维空间中的变换"></a>三维空间中的变换</h2><ul><li><p>欧式变换: 6个自由度，长度、夹角、体积不变<br>$$ \left[ {\begin{array}{*{20}{c}} \mathbf{R} &amp; \mathbf{t} \\ {\mathbf{0}^T} &amp; 1 \end{array}} \right] $$</p></li><li><p>相似变换: 7个自由度， 体积比不变<br>$$ \left[ {\begin{array}{*{20}{c}} \mathbf{sR} &amp; \mathbf{t} \\ {\mathbf{0}^T} &amp; 1 \end{array}} \right] $$</p></li><li><p>仿射变换: 12个自由度，平行性、体积比不变<br>$$ \left[ {\begin{array}{*{20}{c}} \mathbf{A} &amp; \mathbf{t} \\ {\mathbf{0}^T} &amp; 1 \end{array}} \right] $$</p></li><li><p>射影变换: 15个自由度，接触平面的相交与相切不变<br>$$ \left[ {\begin{array}{*{20}{c}} \mathbf{A} &amp; \mathbf{t} \\ {\mathbf{a}^T} &amp; \mathbf{v} \end{array}} \right] $$</p></li></ul><h1 id="单应变换"><a href="#单应变换" class="headerlink" title="单应变换"></a>单应变换</h1><p>如下面公式，实际上单应变换实现的是两个平面之间的映射关系。(意思是<strong>只要是从一个平面到另一个平面的映射都可以用单应矩阵表示</strong>)</p><p>$$ s \begin{bmatrix} x^{‘} \\ y^{‘} \\ 1 \end{bmatrix} = H \begin{bmatrix} x \\ y \\ 1 \end{bmatrix} = \begin{bmatrix} h_{11} &amp; h_{12} &amp; h_{13} \\ h_{21} &amp; h_{22} &amp; h_{23} \\ h_{31} &amp; h_{32} &amp; h_{33} \end{bmatrix} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix} $$</p><p>单应矩阵的维度是<code>3*3</code>，却只有8个自由度，这是因为齐次坐标的<strong>尺度等价性</strong>。一般求出的单应矩阵会进行归一化，要求为$h_{33} = 1$或$h_{11}^2 + h_{12}^2 + h_{13}^2 + h_{21}^2 + h_{22}^2 + h_{23}^2 + h_{31}^2 + h_{32}^2 + h_{33}^2 = 1$</p><blockquote><p>同理，在<a href="https://xhy3054.github.io/epipolar-geometry/">理解对极几何与基本矩阵</a>中我们有得出结论，本质矩阵$E = t^{\land} R$，由于平移与旋转共有6个自由度。但是由于其次坐标的的尺度等价性，<strong>本质矩阵实际上有5个自由度</strong>。</p></blockquote><h1 id="单应变换的作用"><a href="#单应变换的作用" class="headerlink" title="单应变换的作用"></a>单应变换的作用</h1><ol><li>相机位姿的估计</li><li>图像的矫正</li><li>全景拼接</li></ol><h2 id="使用单应变换进行相机位姿估计"><a href="#使用单应变换进行相机位姿估计" class="headerlink" title="使用单应变换进行相机位姿估计"></a>使用单应变换进行相机位姿估计</h2><p><img src="/img/epipolar_geometry/jihe.png" alt="jihe"></p><p>这个功能与使用基础矩阵对相机的位姿进行估计是类似的。首先：</p><p>$$ Z_1p_{uv1} = KP_w \\ Z_2p_{uv2} = K(RP_w + t) 　\tag{1}$$</p><p>其中K是相机内参，R与t是相机的位姿变换，$P_w$是一个空间点在第一个相机坐标系下的坐标。Z是空间点到相机光心的距离，$p_{uv}$是空间点在两个位置的相机的像素平面上的像素坐标。</p><p>我们假设有一个参照物平面，平面方程如下：</p><p>$$ n^{T} P_w　+ d = 0 　\tag{2}$$</p><p>稍加整理可得：</p><p>$$ -\frac{n^{T}P_w}{d} = 1 \tag{3} $$</p><p>所以，由公式1我们可以得到：<br>$$<br>\begin{equation}<br>\begin{split}<br>p_{uv2} &amp;= K(RP_w + t)/Z_2 \<br>&amp;= K(RP_w + t \cdot -\frac{n^{T}P_w}{d})/Z_2 \<br>&amp;= K(R + t \cdot -\frac{n^{T}}{d})P_w/Z_2 \<br>&amp;= K(R + t \cdot -\frac{n^{T}}{d}) K^{-1}p_{uv1}<br>\end{split}<br>\end{equation}<br>$$</p><p>如上，上述得到了第一个相机平面上的点到第二个相机平面上的点的映射变换，这部分可以使用下式表示(s是一个齐次坐标的归一系数，为了数学等式的成立)：</p><p>$$ sp_{uv2} = Hp_{uv1} \\ H = K(R + t \cdot -\frac{n^{T}}{d}) K^{-1} $$</p><blockquote><p>我们发现这个单应矩阵H的定义与旋转、平移、还有平面的参数有关。</p></blockquote><h3 id="单应约束与対极约束的区别"><a href="#单应约束与対极约束的区别" class="headerlink" title="单应约束与対极约束的区别"></a>单应约束与対极约束的区别</h3><ul><li><p><strong>対极约束</strong>：基础矩阵描述的本质是一种点到直线的映射关系，所以対极约束不能给出两幅图像上的点的一一对应关系，只能给出点对应的必要条件。但是，対极约束与场景的结构无关，只与相机的参数有关。</p></li><li><p><strong>单应约束</strong>：单应矩阵描述的本质是点到点的映射关系，所以单应约束给出了两幅图像上的点的一一对应关系，这是一种充要的条件。但是，单应约束需要做这些投影的空间点本身在一个平面上（即深度本身满足一定要求）,否则使用单应矩阵进行的映射结果会出现错误。如下图p’点不在平面P上，所以使用对应的单应矩阵做投影会得到错误的投影点$x_2$，正确的应该是${x_2}^{‘}$。</p></li></ul><p><img src="/img/epipolar_geometry/homography.jpg" alt="homography"></p><ul><li><p>在只有旋转没有平移时，対极约束是恒成立的，此时不能用本质矩阵进行相机的位姿估计。而单应矩阵可以。</p></li><li><p>推导中我们使用了齐次坐标，所以单应约束也是尺度无关的，恢复出来的位姿变化也具有尺度不确定性。</p></li></ul><h2 id="使用单应变换进行透视矫正"><a href="#使用单应变换进行透视矫正" class="headerlink" title="使用单应变换进行透视矫正"></a>使用单应变换进行透视矫正</h2><h2 id="使用单应变换进行全景拼接"><a href="#使用单应变换进行全景拼接" class="headerlink" title="使用单应变换进行全景拼接"></a>使用单应变换进行全景拼接</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] <a href="https://docs.opencv.org/3.4.1/d9/dab/tutorial_homography.html">https://docs.opencv.org/3.4.1/d9/dab/tutorial_homography.html</a></li><li>[2] Richard Hartley and Andrew Zisserman. Multiple view geometry in computer vision. Cambridge university press, 2003.</li><li>[3] 《学习opencv3》</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RANSAC算法的理解与使用</title>
    <link href="/2019/01/26/2019-01-26-ransac/"/>
    <url>/2019/01/26/2019-01-26-ransac/</url>
    
    <content type="html"><![CDATA[<p><strong>随机抽样一致算法(random sample consensus, RANSAC)</strong>，其实就是采用迭代的方法从一组包含离群的被观测数据中估算出数学模型的参数。(比如通过一群点拟合一条直线等)</p><h2 id="基本假设"><a href="#基本假设" class="headerlink" title="基本假设"></a>基本假设</h2><ul><li><p>模型假设：事先知道真实数据满足的数学模型，不知道的只是模型的具体参数；</p></li><li><p>输入假设：输入数据中包含正确数据（即inliers，可以被假设模型描述的数据）；同时也包含异常数据（即outliers，偏离正常范围很远、不能用假设模型描述的数据）；即输入数据集中含有噪声；</p></li><li><p>有解假设：给定一组(通常很小，比如直线模型两个点就够了)内群数据，存在一种解法，可以通过这组内群数据求解出最适用于这一数据模型的一组参数；</p></li></ul><blockquote><p>一般当有效数据占绝大多数，无效数据只是少量时，我们可以通过<strong>最小二乘法</strong>或类似的方法来确定模型的参数与误差；如果无效数据很多，最小二乘法可能就不适用了</p></blockquote><blockquote><p>最小二乘法通过<strong>最小化误差的平方和</strong>来寻找数据的最佳函数匹配。</p></blockquote><h2 id="算法步骤概述"><a href="#算法步骤概述" class="headerlink" title="算法步骤概述"></a>算法步骤概述</h2><ol><li><strong>数据采样</strong>：随机采样最小子集；</li><li><strong>模型计算</strong>：通过第一步采样的最小子集计算出一个模型参数的假设；</li><li><strong>模型验证</strong>：把刚才没有被采样的点带入刚才建立的模型中，统计内群点的数量；</li><li>重复以上1、2、3步骤多次；</li><li><strong>算法终止</strong>：达到终止条件后，选取其中内群点数量最多的那组模型参数作为我们要求的解；</li></ol><h2 id="RANSAC算法的终止条件"><a href="#RANSAC算法的终止条件" class="headerlink" title="RANSAC算法的终止条件"></a>RANSAC算法的终止条件</h2><p>假设某一次采样的最小子集中所有数据都是内点的概率为p，那么在第k次第一次出现所有点都是内点的概率情况如下：</p><div style="text-align: center"><img src="/img/ransac/ransac_stop.png"/></div><p>关于如何确定终止条件，RANSAC的论文里提出了两种方式：</p><ol><li><p><strong>第一种方式</strong>，求解上面k的期望值与方差，然后期望值加上两倍到三倍的方差，作为采样次数;</p></li><li><p><strong>第二种方式</strong>，用的更多，它的原理是要求在采样次数中至少有一次采样全部都是内点的概率大于$\eta$;即</p></li></ol><p>$$ p(1 + (1-p) + (1-p)^2 + … + (1-p)^{n-1}) &gt; \eta $$</p><p>即</p><p>$$ 1 - (1-p)^n &gt; \eta $$</p><p>即</p><p>$$ n &gt; \frac{log(1 - \eta)}{log(1-p)} $$</p><p>此处，如果这个数据集合中的内点率为$\delta$时，则(下式中m为最小子集数据的个数)</p><p>$$ p \approx {\delta}^m $$</p><blockquote><p>需要说明的是此处$\delta$可能并不是已知的，此时可以有两个选择，第一是令其值为最坏情况下的$\delta$，第二是先令其值为非常低的一个值，然后每次迭代后，将其值换为之前验证的模型中最大的那个内点率值（因为最好的模型验证的内点率肯定是最高的）。</p></blockquote><h3 id="第二种方式的一种更简单的求解"><a href="#第二种方式的一种更简单的求解" class="headerlink" title="第二种方式的一种更简单的求解"></a>第二种方式的一种更简单的求解</h3><p>其实上面第二种方式还有一种更简单的表示形式，那就是直接计算没有一次最小采样全部是内点的概率，当它小于$1- \eta$时，终止；即：</p><p>$$  (1-{\delta}^m)^n &lt; 1-\eta $$</p><blockquote><p>上面公式中$\delta$表示当前最好模型的内点率，$m$表示最小采样个数，$n$表示当前的迭代次数，只有在当前迭代次数下这个公式满足的情况下，才会终止。此处的这种形式比上面计算迭代次数的形式要好理解一些。</p></blockquote><h2 id="在关键点匹配对筛选中的应用"><a href="#在关键点匹配对筛选中的应用" class="headerlink" title="在关键点匹配对筛选中的应用"></a>在关键点匹配对筛选中的应用</h2><ul><li>模型假设：模型是单应矩阵表示的对极几何模型；</li><li>输入假设：输入的数据中包含正确的匹配(inliers)与误匹配(outliers);</li><li>有解假设：可以通过四对匹配特征点求解处自由度为8的单应矩阵；</li></ul><blockquote><p>具体代码效果可以见<a href="">我的github</a>，不过我直接调用了opencv自带的ransac的实现，并没有自己手写。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] <a href="https://blog.csdn.net/laobai1015/article/details/51682596">https://blog.csdn.net/laobai1015/article/details/51682596</a></li><li>[2] <a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95">https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95</a></li><li>[3] <a href="https://docs.opencv.org/3.4.1/d9/d0c/group__calib3d.html#gae420abc34eaa03d0c6a67359609d8429">https://docs.opencv.org/3.4.1/d9/d0c/group__calib3d.html#gae420abc34eaa03d0c6a67359609d8429</a></li><li>[4] Fischler M A. Random Sample Consensus: A Paradigm for Model Fitting with Applications to Image Analysis and Automated Cartography[J]. Readings in Computer Vision, 1987:726-740.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希表的原理与实现</title>
    <link href="/2019/01/15/2019-01-15-hash-table/"/>
    <url>/2019/01/15/2019-01-15-hash-table/</url>
    
    <content type="html"><![CDATA[<p><strong>哈希表(hash table，也叫散列表)</strong>，是可以根据键(key)直接访问值(value)在内存中存储位置的一种数据结构。哈希表的核心是<strong>哈希函数(hash function)</strong>，正是哈希函数完成了从key到value存储位置的映射。</p><h1 id="在计算机科学中的应用"><a href="#在计算机科学中的应用" class="headerlink" title="在计算机科学中的应用"></a>在计算机科学中的应用</h1><p>哈希算法在计算机科学中应用广泛。例如git的版本管理、IP协议中的checksum都有它的身影。</p><ul><li><p>其中在<strong>git的版本管理</strong>中，文件内容是key，通过SHA算法(一种哈希函数)将文件内容对应为固定长度的字符串（hash值）。如果文件内容发生变化，那其所对应的字符串就会发生变化。git通过比较比较短hash值(字符串)，就可以知道文件内容是否发生了变动。</p></li><li><p>还有一种应用是用于<strong>计算机的登录密码的存储</strong>。密码一般都是一串字符，但是为了安全问题，计算机不会直接保存这个字符串，而是保存该字符串的hash值（可以使用MD5、SHA或者其他算法作为hash函数）。当用户下次登录时，输入密码字符串。如果该密码字符串的hash值与保存的hash值一致，那么就认为用户输入了正确的密码。这样就算黑客闯入了数据中取出了密码记录，也只能看到密码的hash值。一般hash函数都会有很好的单向性，从hash值很难回推处键值。不过有一些网站存储的是明文密码。</p></li></ul><blockquote><p>需要注意的一点是，hash只要求完成从key到value的映射，并没有限定该对应关系必须是一一映射。因此会出现两个不同的key对应同一个value的情况。这种情况叫做<strong>哈希碰撞（hash collision）</strong>。比如通常MD5算法常用来计算密码的hash值，但是已有实验表明，MD5算法有可能会发生碰撞，也就是不同的明文密码生成相同的hash值，这给系统带来了很大的安全漏洞。</p></blockquote><h1 id="哈希表与搜索"><a href="#哈希表与搜索" class="headerlink" title="哈希表与搜索"></a>哈希表与搜索</h1><p>哈希表被广泛应用于<strong>搜索</strong>。设定集合A为搜索对象，集合B为存储位置。可以通过hash函数将搜索对象与存储位置对应起来。这样我们只需要一次hash计算，就可以找到对象存储的位置。这就是C++中的<code>unordered_map</code>(map对应的是红黑树)与python中的<code>dict</code>的原理。</p><h2 id="哈希表的实现"><a href="#哈希表的实现" class="headerlink" title="哈希表的实现"></a>哈希表的实现</h2><p>实现的话，一般很常见的是使用一个数组来存储对象，然后通过对键值进行hash计算来确定对象在数组中的存储的下标，由于数组可以根据数组下标进行随机存取（random access，算法复杂度为1），所以搜索操作将取决于hash函数的复杂程度。</p><p>下面是一个简单的例子，我们以人名（一个字符串）为key,以数组下标为对应的hash值。每一个数组元素中存储了一个指针，指针指向对应的关于这个人的记录（有人名和电话号码）。</p><p>如下是一个简单的hash函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> HASHSIZE 1007</span><br><br><span class="hljs-comment">/* By Vamei</span><br><span class="hljs-comment"> * hash function</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">char</span> *p)</span><br>&#123;<br>    <span class="hljs-type">int</span> value=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>((*p) != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>       value = value + (<span class="hljs-type">int</span>) (*p); <span class="hljs-comment">// convert char to int, and sum</span><br>       p++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (value % HASHSIZE); <span class="hljs-comment">// won&#x27;s exceed HASHSIZE</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><p>hash函数的计算是通过将key中的每个字母的ACII值相加然后求除以1007的余数，得到一个在<code>0~1006</code>之间的index值。我们建立一个1007大小的数组用于存储指向每个记录的指针。一般HASHSIZE被选择为质数，以便hash值可以分布的更加均匀。下图是hash搜索的一个示例，输入”Vamei”得到在数组index为498的地方存储着一个指针指向“Vamei”的记录。</p><p><img src="/img/hash/hash1.png" alt="hash1"></p><p>如果步采用hash，只在一个数组中进行搜索的话，我们需要一次访问每条记录，知道找到目标记录，算法复杂度为n。而利用键值使用hash函数进行查找，在没有hash碰撞的情况下，我们只需要一次hash计算就可以找到我们想要的元素。</p><h3 id="hash碰撞的解决"><a href="#hash碰撞的解决" class="headerlink" title="hash碰撞的解决"></a>hash碰撞的解决</h3><p>由于不是一一映射，所以hash函数需要解决hash冲突的问题。比如上面的那种hash函数的映射方式，”Obama”与“Oaamb”有相同的hash值，发生冲突。</p><ul><li>一种解决方案是将发生冲突的记录使用链表进行存储，让hash值处的数组元素指向该链表。这种方法叫做<strong>open hashing</strong></li></ul><p><img src="/img/hash/hash2.png" alt="hash2"></p><blockquote><p>这种方法我们需要将每个记录的数据结构封装成链表节点，在通过hash值找到这个链表后，通过遍历链表找到想要的记录。</p></blockquote><ul><li>还有一种解决方案是当冲突出现时，我们将冲突记录放在数组中依然空闲的位置，比如图中的”Obama”被插入后，随后的“Oaamb”计算hash值也是480。但是由于480已经被占据，于是找到下一个空闲位置481进行记录。这种方法叫做<strong>closed hashing</strong></li></ul><p><img src="/img/hash/hash3.png" alt="hash3"></p><blockquote><p>closed hashing的关键在于如何找到下一个位置。上面的做法是<code>index+1</code>。但是也可以是其他的方法。当我们在搜索的时候，首先依据hash函数找到初始index，通过比对key值，如果不是想要的记录，就不断的找下一个位置，直到找到想要的记录。</p></blockquote><blockquote><p>如果HASHSIZE太小，会导致hash碰撞太多，此时会极大地影响查找效率。我们需要增大HASHSIZE，并将原来的记录放入新的比较大的数组中，这样的操作叫做<strong>rehashing</strong>。</p></blockquote><p>c语言实现见我的github里c语言学习文件夹<code>c_learn/hash_table</code></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] <a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8">https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8</a></li><li>[2] <a href="http://www.cnblogs.com/vamei/archive/2013/03/24/2970339.html">http://www.cnblogs.com/vamei/archive/2013/03/24/2970339.html</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>算法与数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解对极几何与基本矩阵</title>
    <link href="/2019/01/13/2019-01-13-epipolar-geometry/"/>
    <url>/2019/01/13/2019-01-13-epipolar-geometry/</url>
    
    <content type="html"><![CDATA[<p>对极几何是<strong>双视图</strong>之间内在的射影几何。它独立于景物结构，只依赖于摄像机的内参外参。</p><p>而基本矩阵是对对极几何的代数表示。</p><h1 id="对极几何"><a href="#对极几何" class="headerlink" title="对极几何"></a>对极几何</h1><p>如下图所示，对极几何通常用来解决双眼匹配搜索对应点的问题。</p><p><img src="/img/epipolar_geometry/epipolar1.png" alt="epipolar1"></p><p>上图a中两个摄像机的中心分别是C与C’，而X为一个三维空间点，它在两个摄像机的成像平面上的投影点分别是x与x’。我们常称：</p><ul><li><strong>基线</strong>：两个摄像机光心的连线$CC’$</li><li><strong>对极点</strong>：上图b中的e与e’，它们分别是一幅视图中另一个摄像机中心的像。二维表示为基线$CC’$与两个成像平面的交点。</li><li><strong>对极平面</strong>：是一张包含基线的平面，存在着对极平面的一个集合（以基线为轴转动），上图中的一个例子就是$CXC’$。</li><li><strong>对极线</strong>：对极平面与图像平面的交线。上图中的例子是$xe$与$x’e’$，一个成像平面上的所有的对极线相交于对极点。</li></ul><blockquote><p>上图中还体现了一些性质，对于一幅图像上的每一点x，在第二幅图像上，任何与该点x匹配的点x’必然在对极线I’上，该对极线是过点x与第一个摄像机中心C的射线在第二幅图像上的投影。</p></blockquote><h2 id="基本矩阵F"><a href="#基本矩阵F" class="headerlink" title="基本矩阵F"></a>基本矩阵F</h2><p>由上面的讲述，我们知道，在深度未知的情况下，对于一幅图像上的一点x，映射在另一幅图像上是一条与之对应的对极线I’。</p><p>$$ x \rightarrowtail I’ $$</p><p><strong>基本矩阵F表示的正是这个从一个点到一条直线的射影映射</strong>。</p><blockquote><p>由上，我们发现基本矩阵F实现的是从二维（二维点）到一维（一条线上的点）的转换，因此F的秩只能是2。</p></blockquote><h3 id="推导出基础矩阵与本质矩阵"><a href="#推导出基础矩阵与本质矩阵" class="headerlink" title="推导出基础矩阵与本质矩阵"></a>推导出基础矩阵与本质矩阵</h3><p>由<a href="https://xhy3054.github.io/camerca-module/">相机成像的几何描述</a>我们可以理解如下的公式(世界坐标到像素坐标的转换)：</p><p>$$ Z_1p_{uv1} = K_1P_w   $$</p><p>$$ Z_2p_{uv2} = K_2(RP_w + t)   $$</p><p>其中K是相机内参，R与t是第二个相机在第一个相机的相机坐标系下的外参，$P_w$是此空间点在第一个相机的相机坐标系下的坐标。Z是空间点到相机光心的距离(也是相机坐标系下的z轴坐标)。$p_{uv1}$与$p_{uv2}$是空间点$P_w$在两个相机平面上的投影点。</p><ul><li>首先做出如下定义（其中$x_1$与$x_2$是归一化的相机坐标（X/Z,Y/Z,1））：</li></ul><p>$$ x_1 = K_1^{-1}p_{uv1} $$</p><p>$$ x_2 = K_2^{-1}p_{uv2} $$ </p><ul><li>带入如上定义可得：</li></ul><p>$$ Z_2 x_2 = Z_1 Rx_1 + t $$</p><ul><li>上式两边同时左乘<code>t^</code>，也就是两侧同时与t做外积：</li></ul><p>$$ Z_2 t^{\land} x_2 = Z_1 t^{\land} R x_1 $$</p><ul><li>两侧同时左乘$x_{2}^T$：</li></ul><p>$$ Z_2 x_{2}^T t^{\land} x_2 = Z_1 x_{2}^T t^{\land} R x_1 $$</p><ul><li>上式中由于等式左侧 $t^{\land} x_2$ 是一个与t、$x_2$都垂直的向量，再和$x_2$做内积将得到0，因此上式子其实可以写成如下形式：</li></ul><p>$$ x_{2}^T t^{\land} R x_1 = 0 $$</p><ul><li>上式就是大名鼎鼎的<strong>対极约束</strong>，将 $x_1$ 与 $x_2$ 换下，重新带入 $p_{uv1}$ 与 $p_{uv2}$ 可得：</li></ul><p>$$ p_{uv2}^T K_2^{-T} t^{\land} R K_1^{-1} p_{uv1} = 0 $$</p><ul><li>其中，中间项就是<strong>基础矩阵</strong>，满足如下：</li></ul><p>$$ p_{uv2}^T F p_{uv1} = 0 $$</p><p>$$ F = K_2^{-T} t^{\land} R K_1^{-1} $$</p><blockquote><p>此处注意，当点$p_{uv1}$与基础矩阵F确定时，上式演变成一个直线方程，更好的诠释了基础矩阵的本质是<strong>从一个点到一条直线的射影映射的代数表示。</strong></p></blockquote><ul><li><strong>本质矩阵</strong>是基础矩阵中只与外参相关的部分，即去掉相机内参，可以得到：</li></ul><p>$$ E = t^{\land} R  $$</p><p>$$ F = K_2^{-T} E K_1^{-1} $$</p><h2 id="基础矩阵与本质矩阵的性质"><a href="#基础矩阵与本质矩阵的性质" class="headerlink" title="基础矩阵与本质矩阵的性质"></a>基础矩阵与本质矩阵的性质</h2><ol><li><p><strong>本质矩阵</strong>是两个矩阵的乘积，其中R的秩为3（满秩），$t^{\land}$的秩为2，因此E的<strong>秩为2</strong>。</p></li><li><p><strong>基础矩阵</strong>是四个矩阵的乘积，其中只有$t^{\land}$的秩为2，其他的三个都是满秩的（为3）,最终<strong>秩也为2</strong>。</p></li><li><p><strong>基础矩阵</strong>是四个矩阵的乘积，其中左右相机内参矩阵待定参数各4个，平移自由度是3，旋转自由度也是3，因此总共应该是14个待定参数。但是实际上F是一个$3 \times 3$的矩阵，总共9个参数，所以它最大自由度是9。又因为F满足以下两个约束，所以F的<strong>自由度其实是$9-2=7$</strong>。</p><ul><li>尺度等价性</li><li>def(f)=0</li></ul></li><li><p><strong>本质矩阵</strong>的自由度由平移与旋转的各三个自由度组成，加上尺度等价性，因此本质矩阵<strong>自由度为5。</strong></p></li></ol><h2 id="对极约束条件的探讨"><a href="#对极约束条件的探讨" class="headerlink" title="对极约束条件的探讨"></a>对极约束条件的探讨</h2><ol><li><p>一般在slam中，可以通过本质矩阵E的奇异值分解得到相机相对于前一时刻的位姿变换。</p></li><li><p>但是在只有旋转没有平移时，対极约束是恒成立的，此时不能用本质矩阵进行相机的位姿估计。</p></li><li><p>対极约束条件是尺度无关的，所以恢复出来的的位姿变换具有尺度的不确定性。</p></li></ol><h2 id="基础矩阵与本质矩阵的求解"><a href="#基础矩阵与本质矩阵的求解" class="headerlink" title="基础矩阵与本质矩阵的求解"></a>基础矩阵与本质矩阵的求解</h2><p>由上面我们知道基础矩阵自由度为7，所以最少我们可以使用7对点来求解基础矩阵。同样，本质矩阵自由度是5，我们最小可以使用5对点进行求解。但是因为它们的内在性质中很多都是非线性的性质，因此使用最少的点数求解会比较麻烦，所以一般情况下，只考虑尺度等价性，然后使用8对点进行求解。这也叫作<strong>八点法</strong>。</p><p>考虑一对匹配点，它们的像素坐标（如果是求解本质矩阵，那就是归一化坐标）为$$x_1 = [u_1, v_1, 1]^T, x_2 = [u_2, v_2, 1]^T$$。根据对极约束，有：</p><p>$$<br>\left(u_{2}, v_{2}, 1\right)\left(\begin{array}{lll}{e_{1}} &amp; {e_{2}} &amp; {e_{3}} \\ {e_{4}} &amp; {e_{5}} &amp; {e_{6}} \\ {e_{7}} &amp; {e_{8}} &amp; {e_{9}}\end{array}\right)\left(\begin{array}{l}{u_{1}} \\ {v_{1}} \\ {1}\end{array}\right)=0<br>$$</p><p>将上面矩阵展开，写成向量的形式（为了后续好解）：</p><p>$$<br>e=\left[e_{1}, e_{2}, e_{3}, e_{4}, e_{5}, e_{6}, e_{7}, e_{8}, e_{9}\right]^{\mathrm{T}}<br>$$</p><p>此时上面对极约束的等式可以写成如下的形式</p><p>$$<br>\left[u_{2} u_{1}, u_{2} v_{1}, u_{2}, v_{2} u_{1}, v_{2} v_{1}, v_{2}, u_{1}, v_{1}, 1\right] \cdot e=0<br>$$</p><p>将八个点的对极约束放在一起便可以得到一个方程组：</p><p>$$<br>\left(\begin{array}{cccccccc}{u_{2}^{1} u_{1}^{1}} &amp; {u_{2}^{1} v_{1}^{1}} &amp; {u_{2}^{1}} &amp; {v_{2}^{1} u_{1}^{1}} &amp; {v_{2}^{1} v_{1}^{1}} &amp; {v_{2}^{1}} &amp; {u_{1}^{1}} &amp; {v_{1}^{1}} &amp; {1} \\ {u_{2}^{2} u_{1}^{2}} &amp; {u_{2}^{2} v_{1}^{2}} &amp; {u_{2}^{2}} &amp; {v_{2}^{2} u_{1}^{2}} &amp; {v_{2}^{2} v_{1}^{2}} &amp; {v_{2}^{2}} &amp; {u_{1}^{2}} &amp; {v_{1}^{2}} &amp; {1} \\ {\vdots} &amp; {\vdots} &amp; {\vdots} &amp; {\vdots} &amp; {\vdots} &amp; {\vdots} &amp; {\vdots} &amp; {\vdots} \\ {u_{2}^{8} u_{1}^{8}} &amp; {u_{2}^{8} v_{1}^{8}} &amp; {u_{2}^{8}} &amp; {v_{2}^{8} u_{1}^{8}} &amp; {v_{2}^{8} v_{1}^{8}} &amp; {v_{2}^{8}} &amp; {u_{1}^{8}} &amp; {v_{1}^{8}} &amp; {1}\end{array}\right)\left(\begin{array}{c}{e_{1}} \\ {e_{2}} \\ {e_{3}} \\ {e_{4}} \\ {e_{5}} \\ {e_{6}} \\ {e_{7}} \\ {e_{8}} \\ {e_{9}}\end{array}\right) = 0<br>$$</p><p>解方程组便可以求解出本质矩阵或基础矩阵。</p><h2 id="通过本质矩阵恢复处R与T"><a href="#通过本质矩阵恢复处R与T" class="headerlink" title="通过本质矩阵恢复处R与T"></a>通过本质矩阵恢复处R与T</h2><p>在上述工作完成求解出本质矩阵E之后，可以通过SVD分解得到如下等式</p><p>$$<br>\boldsymbol{E}=\boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^{\mathrm{T}}<br>$$</p><p>其中U和V是正交阵，中间$\boldsymbol{\Sigma}$是奇异值矩阵。根据E的内在性质，我们知道$$\boldsymbol{\Sigma} = diag(\mu, \mu, 0)$$。通过SVD分解，任意一个E，存在两个可能的R和t与其对应。</p><p>$$<br>\begin{array}{l}{t_{1}^{\wedge}=U R_{Z}\left(\frac{\pi}{2}\right) \Sigma U^{\mathrm{T}}, \quad R_{1}=U R_{Z}^{\mathrm{T}}\left(\frac{\pi}{2}\right) V^{\mathrm{T}}} \\ {t_{2}^{\wedge}=U R_{Z}\left(-\frac{\pi}{2}\right) \Sigma U^{\mathrm{T}}, \quad R_{2}=U R_{Z}^{\mathrm{T}}\left(-\frac{\pi}{2}\right) V^{\mathrm{T}}}\end{array}<br>$$</p><p>其中$$R_{Z}\left(\frac{\pi}{2}\right)$$表示沿Z轴旋转90°得到的旋转矩阵。同时由于E无论是否取符号都是等价的，因此对上面得到的t取负号也会得到相同的结果。因此每个E通过分解一共有四种可能的解。 </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] 《Multiple View Geometry in Computer Vision (Second Edition)》</li><li>[2] 《视觉slam十四讲》</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解齐次坐标</title>
    <link href="/2019/01/11/2019-01-11-homogeneous-coordinates/"/>
    <url>/2019/01/11/2019-01-11-homogeneous-coordinates/</url>
    
    <content type="html"><![CDATA[<p>齐次坐标系（Homogeneous Coordinates）是计算机视觉与图形学中的一个重要的数学工具。</p><h1 id="齐次坐标的引入"><a href="#齐次坐标的引入" class="headerlink" title="齐次坐标的引入"></a>齐次坐标的引入</h1><p>在<strong>欧式空间</strong>里，两条公面的平行线无法相交，但是在<strong>投影空间</strong>(Projective Space)里不是这样。一个直观的表示如下：两条轨道的间距随着视线变远而逐渐变小，直到在无限远处相交。</p><p><img src="/img/homogeneous_coordinates/railway.jpg" alt="railway"></p><p>在欧式空间里采用$(x, y, z)$表示一个三维点，但是<strong>无穷远点</strong>$(\infty, \infty, \infty)$在欧式空间里是没有意义的，<strong>在投影空间中进行图形和几何运算</strong>并不是一个简单的问题，为了解决这个问题，数学家　August Ferdinand Möbius　提出了齐次坐标系，使用 N+1 个量来表示　N 维坐标。例如在二维齐次坐标系中，我们引入一个量w，将一个二维点$(x, y)$重新表示为$(X, Y, w)$的形式，其中转换关系为：</p><p>$$ x = \frac{X}{w} $$</p><p>$$ y = \frac{Y}{w} $$</p><p>例如，欧式坐标中的一个二维点$(1, 2)$可以在齐次坐标中表示为$(1, 2, 1)$，如果点逐渐移动向无穷远处，其欧式坐标变为$(\infty, \infty, \infty)$，齐次坐标变为$(1, 2, 0)$。其中齐次坐标在表示无穷远处的点时不需要用到$\infty$。</p><blockquote><p>其中齐次坐标$(1, 2, 1)$等价于齐次坐标$(2, 4, 2)$…即$(k, 2k, k)，k \in R$，此处这些点具有<strong>尺度不变性</strong>，是齐性的，所以称为<strong>齐次坐标</strong></p></blockquote><h2 id="照片中平行线相交的不太严格的证明"><a href="#照片中平行线相交的不太严格的证明" class="headerlink" title="照片中平行线相交的不太严格的证明"></a>照片中平行线相交的不太严格的证明</h2><p>欧式空间中假设有如下两条平行线:</p><p>$$ Ax + By + C = 0 $$</p><p>$$ Ax + By + D = 0 $$</p><p>上面两条先在欧式空间中除非$C = D$，否则不相交。使用$\frac{x}{w}, \frac{y}{w}$替换$x, y$(正如前文提到的使用$N+1$个量表示N维坐标，这里增加了一个量w)，可以得到：</p><p>$$ Ax + By + Cw = 0 $$</p><p>$$ Ax + By + Dw = 0 $$</p><p>上式可以得到解$(x, y, 0)$，即两条平行线的齐次坐标表示在$(x, y, 0)$也就是无穷点处相遇</p><blockquote><p>当然这只是一个不严格不严谨的表示，齐次坐标真正的作用在于下文。</p></blockquote><h1 id="齐次坐标可以区分点与向量"><a href="#齐次坐标可以区分点与向量" class="headerlink" title="齐次坐标可以区分点与向量"></a>齐次坐标可以区分点与向量</h1><p>以二维空间为例，$(a, b)$这样的表示既可以是一个坐标表示，也可以是一个向量表示。假设这个坐标系$xOy$中两个基向量为$\vec{x}, \vec{y}$，坐标原点为o，则其中</p><ul><li>表示向量$\vec{v}$时，代表$\vec{v} = a\vec{x} + b\vec{y}$</li><li>表示一个点p时，代表$ p - o = a\vec{x} + b\vec{y} $</li></ul><p>如果没有附加说明，我们不能区别$(a, b)$表示的是向量还是点。用三个量来表示的化，我们可以明确的区分向量和点</p><ul><li>齐次点$(a, b, 1)$</li><li>齐次向量$(a, b, 0)$</li></ul><h1 id="齐次坐标更易描述仿射变换"><a href="#齐次坐标更易描述仿射变换" class="headerlink" title="齐次坐标更易描述仿射变换"></a>齐次坐标更易描述仿射变换</h1><p>一个二维点的仿射变换可以用一个矩阵乘法(线性变换)与一个矩阵加法(平移变换)的叠加来表示：</p><ul><li>矩阵乘法可以表示线性变换，线性变换可以表示旋转变换或者缩放变换（不局限于表示这两种）</li></ul><p>$$ \left[ \begin{array}{ccc} x’\\  y’ \end{array} \right] = \left[ \begin{array}{ccc} cos(\theta) &amp; -sin(\theta) \\  sin(\theta) &amp; cos(\theta) \end{array} \right] \left[ \begin{array}{ccc} x\\  y \end{array} \right]$$</p><p>$$ \left[ \begin{array}{ccc} x’\\  y’ \end{array} \right] = \left[ \begin{array}{ccc} S_x &amp; 0 \\  0 &amp; S_y \end{array} \right] \left[ \begin{array}{ccc} x\\  y \end{array} \right] $$</p><ul><li>矩阵加法可以表示平移变换（不局限于表示平移）</li></ul><p>$$ \left[ \begin{array}{ccc} x’\\  y’ \end{array} \right] = \left[ \begin{array}{ccc} x’\\  y’ \end{array} \right] + \left[ \begin{array}{ccc} t_x\\  t_y \end{array} \right] $$</p><p>如上，我们发现原本的平移变换不能用矩阵相乘的形式表达。在引入齐次坐标后（具有尺度不变性，实际上在高一维的空间映射到$w=1$平面后的结果可直接导出到欧式空间）</p><ul><li>旋转变换和尺度变换</li></ul><p>$$ \left[ \begin{array}{ccc} x’\\  y’\\ 1 \end{array} \right] = \left[ \begin{array}{ccc} cos(\theta) &amp; -sin(\theta) &amp; 0 \\  sin(\theta) &amp; cos(\theta) &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{array} \right] \left[ \begin{array}{ccc} x\\  y \\ 1 \end{array} \right]$$</p><p>$$ \left[ \begin{array}{ccc} x’\\  y’\\ 1 \end{array} \right] = \left[ \begin{array}{ccc} S_x &amp; 0 &amp; 0 \\  0 &amp; S_y &amp; 0\\ 0 &amp; 0 &amp; 1\end{array} \right] \left[ \begin{array}{ccc} x\\  y\\ 1 \end{array} \right] $$</p><ul><li>平移变换</li></ul><p>$$ \left[ \begin{array}{ccc} x’\\  y’\\ 1 \end{array} \right] = \left[ \begin{array}{ccc} 1 &amp; 0 &amp; t_x \\  0 &amp; 1 &amp; t_y\\ 0 &amp; 0 &amp; 1\end{array} \right] \left[ \begin{array}{ccc} x\\  y\\ 1 \end{array} \right] $$</p><ul><li>这样，我们可以导出整个仿射变换的矩阵形式</li></ul><p>$$ T = \left[ \begin{array}{ccc} A &amp; t \\ O_{1*2} &amp; 1\end{array} \right] \left[ \begin{array}{ccc} x\\  y\\ 1 \end{array} \right] $$</p><p>仿射变换保留了点的共线、共面、比例等关系，是图形处理中十分重要的一环。而齐次坐标的引入<strong>使得仿射变换能够以一种紧凑统一的矩阵形式表示和计算</strong>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>齐次坐标表示是计算机图形学的重要手段之一，它既能够用来<strong>明确的区分向量和点</strong>，同时也更<strong>易于进行仿射几何变换</strong>。　—— F.S.Hill Jr.《计算机图形学(OpenGL版)》</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] 《计算机图形学(OpenGL版)》-　F.S.Hill Jr.</li><li>[2] 《Computer Vision: Algorithms and Applications》- Richard Szeliski </li><li>[3]  <a href="https://oncemore.wang/blog/homogeneous/">https://oncemore.wang/blog/homogeneous/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>相机成像的几何描述</title>
    <link href="/2019/01/10/2019-01-10-camerca-module/"/>
    <url>/2019/01/10/2019-01-10-camerca-module/</url>
    
    <content type="html"><![CDATA[<p>相机成像，就是指通过摄像机将真实的三维空间中的点映射到成像平面（2维）上。这个过程可以通过一个几何模型来表示，本文使用最简单的针孔成像模型进行讲解。</p><h1 id="针孔相机模型"><a href="#针孔相机模型" class="headerlink" title="针孔相机模型"></a>针孔相机模型</h1><p>如下图所示，是针孔相机的成像模型。</p><p><img src="/img/camera_needle/camera_needle.jpg" alt="camera_needle"></p><p>其中，O为相机的光心，也是针孔模型的针孔。现实世界的空间点P，在经过小孔O投影之后，落在了物理成像平面<code>O&#39;-x&#39;-y&#39;</code>上，成像点是 P’ ，假设P的相机坐标系坐标是$[X,Y,Z]^T$，P’　的相机坐标系坐标为$[X’,Y’,Z’]^T$，并且假设物理成像平面到小孔的距离为f(焦距)。则这会构成如下相似三角形</p><p><img src="/img/camera_needle/trang.jpg" alt="trang"></p><p>那么根据三角形相似的关系有：</p><p>$$\frac{Z}{f} = - \frac{X}{X’} = - \frac{Y}{Y’}$$</p><p>其中负号是因为成的像是<strong>倒</strong>的，所以坐标系数会相反，不过一般为了简化模型，我们统一将成像平面对称到相机的前方，使得成像平面与三维空间点一起放在摄像机坐标系的同一侧，这叫做<strong>虚像</strong>。这样，我们可以去掉上式中的负号，如下：</p><p>$$\frac{Z}{f} = \frac{X}{X’} = \frac{Y}{Y’}$$</p><blockquote><p>此处之所以可以随意的将成像平面挪到前方，是因为我们拍照相机输出的照片都是正常的，并不是倒像，这是因为相机自身的软件会帮助我们翻转这张图片。虽然原理上小孔成像是倒的，但是实际应用中我们在理解照片与实际场景的成像时应该是将成像平面放到前面的。</p></blockquote><h1 id="相机几何坐标转换"><a href="#相机几何坐标转换" class="headerlink" title="相机几何坐标转换"></a>相机几何坐标转换</h1><p>如上的针孔模型，一个空间点在投影到2d的像素平面上时会经历如下三步：</p><ol><li>空间点从世界坐标系转换到相机坐标系;</li><li>由空间点的相机坐标系的坐标得到成像平面上投影点的坐标;</li><li>最后由成像平面投影点的坐标得到像素平面上的像素坐标。</li></ol><p><img src="/img/camera_needle/coor1.png" alt="coor1"></p><h2 id="从世界坐标系到相机坐标系"><a href="#从世界坐标系到相机坐标系" class="headerlink" title="从世界坐标系到相机坐标系"></a>从世界坐标系到相机坐标系</h2><p>这个转换很容易完成，是一种刚体运动，可以用平移、旋转来描述</p><ul><li>第一步是平移操作，平移操作变换是将光心位置移动到坐标原点的那个向量。</li><li>第二步是旋转操作，旋转矩阵是将相机角度旋转到朝向ｚ轴的那个矩阵。</li></ul><p>$$ P_c=R(P_w - C) $$</p><p>上式中，R是旋转矩阵，C是一个平移矩阵，式中将其写为了负的形式，整个矩阵形式如下图</p><p><img src="/img/camera_needle/matrix1.png" alt="matrix1"></p><blockquote><p>此处的旋转与平移信息相对于相机的一些内部参数而言属于外部参数，在讨论相机外部参数时，往往会将上式写成如下形式，使用R与T的联合矩阵(4<em>4)来表示*</em>相机外参**（一般是对相机位姿求逆）</p></blockquote><p><img src="/img/camera_needle/matrix2.png" alt="matrix2"></p><h2 id="由空间点的相机坐标系的坐标得到成像平面上投影点的坐标"><a href="#由空间点的相机坐标系的坐标得到成像平面上投影点的坐标" class="headerlink" title="由空间点的相机坐标系的坐标得到成像平面上投影点的坐标"></a>由空间点的相机坐标系的坐标得到成像平面上投影点的坐标</h2><p>这部分变换其实前面已经讲过了，成像平面与真实物体还有相机光心的位置大概如下所示（下图中我们使用新的坐标命名参数）：</p><p><img src="/img/camera_needle/camera1.png" alt="camera1"></p><p>其中相机坐标系坐标<code>(X,Y,Z)</code>到投影平面上的齐次坐标<code>(x,y,1)</code>可以表示如上。</p><blockquote><p>注意，此处主要是两步，第一步是$(X,Y,Z)$变为$(\dfrac{X}{Z}, \dfrac{Y}{Z}, 1)$，即<strong>从相机坐标系坐标变换到归一化平面上</strong>。第二步是将$(\dfrac{X}{Z}, \dfrac{Y}{Z})$变换为$(f \dfrac{X}{Z}, f \dfrac{Y}{Z})$，<strong>即将坐标从归一化平面变换到成像平面上</strong>。这里的第二步其实是包含在了内参操作里的。</p></blockquote><h2 id="转换为像素坐标"><a href="#转换为像素坐标" class="headerlink" title="转换为像素坐标"></a>转换为像素坐标</h2><p>由上已经知道，空间点相机坐标系坐标<code>(X,Y,Z)</code>到成像平面投影的坐标<code>(x,y)</code>变换为</p><p>$$ x = f\frac{X}{Z} $$</p><p>$$ y = f\frac{Y}{Z} $$</p><p>而像素坐标系通常的定义方式是：原点o’位于图像的左上角，$\mu$轴向右与本来x轴平行，$\nu$轴向下与y轴平行。像素坐标系与成像平面之间，相差了一个缩放和一个原点的平移。我们假设像素坐标在$\mu$轴上缩放了$\alpha$倍，在$\nu$上缩放了$\beta$倍。同时，原点平移了$[c_x,c_y]^T$。所以，(x,y)与(u,v)的关系如下：</p><p>$$ u = \alpha x + c_x $$</p><p>$$ v = \beta y + c_y $$</p><p>其中$\alpha$代表的含义可以理解为横轴分辨率(1m有多少像素)，$\beta$类似，接下来将上面两个式子合并，得到直接<strong>从相机坐标系坐标到像素坐标</strong>的变换如下：</p><p>$$ u = f_x\frac{X}{Z} + c_x $$</p><p>$$ v = f_y\frac{Y}{Z} + c_y $$</p><p>其中，将$\alpha f$合并成$f_x$，$\beta f$合并成$f_y$。</p><p>下面是使用矩阵表示，左边使用齐次坐标。</p><p>$$ \left( \begin{array}{ccc} u\\  v\\   1 \end{array} \right) = \frac{1}{Z} \left( \begin{array}{ccc} f_x&amp; 0 &amp; c_x\\  0&amp; f_y&amp; c_y\\   0 &amp; 0&amp; 1 \end{array} \right) \left( \begin{array}{ccc} X\\  Y\\   Z \end{array} \right) = \frac{1}{Z} K P_c $$</p><p>其中矩阵K就是相机的<strong>内参矩阵</strong>，我们通常认为，内参矩阵在相机出厂之后是固定的，不会再使用过程中发生变化。有时我们并不知道相机的内参，自己确定内参的操作叫做<strong>标定</strong>。</p><blockquote><p>还有一点可以观察到，在相机坐标系下，<strong>从原点出发的射线上的点全部都投影到一个像素坐标上了</strong>。这个可以通过将上式右边的三维坐标<code>(X,Y,Z)</code>任意乘以一个常数，由于齐次坐标的尺度等价性，最后的投影结果不会改变。</p></blockquote><h1 id="总结：公式变换过程"><a href="#总结：公式变换过程" class="headerlink" title="总结：公式变换过程"></a>总结：公式变换过程</h1><p>换一种方式更详细地进行总结(此处有简化细节)：</p><ol><li><p>首先，世界坐标系下有一个固定的点P，<strong>世界坐标</strong>是 $P_w$</p></li><li><p>获得点P的<strong>相机坐标系坐标</strong>，可以利用<strong>相机外参</strong>R与t得到 $ P_c = RP_w + t $</p></li><li><p>在2中获得的 $P_c$ 仍然是三维的 (X,Y,Z) ，将其<strong>投影到归一化平面</strong> $Z=1$ 上，得到<strong>归一化相机坐标</strong>：$ P_C = [X/Z, Y/Z, 1]^T $</p></li><li><p>最后一步，利用<strong>内参K</strong>，将归一化相机坐标转换成<strong>像素坐标</strong>： $ P_{uv} = KP_C $</p></li></ol><p>上述<strong>整合</strong>起来也得到：</p><p>$$ ZP_{uv} = K(RP_w + t) $$</p><blockquote><p>参考上面详细的成像原理，其实总结中的第三步与第四步是可以没有先后关系的。因为都是线性的运算，所以谁先谁后都不影响最后结果。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] 《视觉SLAM十四讲》，高翔著；</li><li>[2] <a href="http://www.cnblogs.com/gemstone/archive/2011/12/19/2293932.html">http://www.cnblogs.com/gemstone/archive/2011/12/19/2293932.html</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵的奇异值分解(SVD)</title>
    <link href="/2019/01/03/2019-01-03-matrix-singular-value/"/>
    <url>/2019/01/03/2019-01-03-matrix-singular-value/</url>
    
    <content type="html"><![CDATA[<p>矩阵的本质可以是代表着一定维度空间上的线性变换。矩阵分解的本质是将原本<code>m*n</code>复杂的矩阵分解成对应的几个简单矩阵的乘积的形式。使得矩阵分析起来更加简单。</p><p>前面写过一篇博客讲的是矩阵的特征值分解，但是我们知道很多矩阵都是不能够进行特征值分解的。这种情况下，如果我们想通过矩阵分解的形式将原本比较复杂的矩阵问题分解成比较简单的矩阵相乘的形式，会对其进行<strong>奇异值分解</strong>。</p><h1 id="简单回顾特征值分解"><a href="#简单回顾特征值分解" class="headerlink" title="简单回顾特征值分解"></a>简单回顾特征值分解</h1><p>如果一个<code>n*n</code>矩阵A有n个特征值，并且这n个特征值所对应的n个特征向量线性无关，则矩阵A可以使用下式进行特征值分解：</p><p>$$ A=W\Sigma W^{-1} $$</p><p>其中，W是n个特征向量所张成的<code>n*n</code>维矩阵，而$Sigma$是一个对角矩阵，对角线上是矩阵A的n个特征值。</p><blockquote><p>一般情况下，我们会将特征向量标准化（即令他们是单位向量），此时矩阵W的n个特征向量为标准正交基，所以会有$W^TW=I$，即$W^T=W^{-1}$，也就是说W为<strong>酉矩阵</strong>。所以特征值分解也可以写成$A=W\Sigma W^T$</p></blockquote><h1 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h1><p>奇异值分解并没有特征值分解那么苛刻的要求，对于任意一个<code>m*n</code>的矩阵A，可以对其进行如下奇异值分解：</p><p>$$  A = U\Sigma V^T $$</p><p>其中，</p><ul><li>U是一个<code>m*m</code>的矩阵；</li><li>$Sigma$是一个<code>m*n</code>的对角矩阵，主对角线上的元素成为<strong>奇异值</strong>；</li><li>V是一个<code>n*n</code>的矩阵，U与V都是酉矩阵，即组成它们的都是标准正交基。</li></ul><p><img src="/img/matrix_singularvalue/singular_value.png" alt="singular_value"></p><h2 id="如何奇异值分解？"><a href="#如何奇异值分解？" class="headerlink" title="如何奇异值分解？"></a>如何奇异值分解？</h2><ol><li><p>首先，利用A的转置乘以A会得到一个<code>n*n</code>的矩阵$A^TA$，对这个矩阵进行特征值分解，得到的n个特征向量张成的<code>n*n</code>矩阵就是<strong>V矩阵</strong>，在这里我们将V中的每一个特征向量叫做A的<strong>右奇异向量</strong>；</p></li><li><p>然后，利用A乘以A的转置得到<code>m*m</code>的矩阵$AA^T$，对这个矩阵进行特征值分解，得到的m个特征向量张成的<code>m*m</code>矩阵就是<strong>U矩阵</strong>，在这里我们将每一个特征向量叫做<strong>左奇异向量</strong>；</p></li><li><p>最后，利用下式求得每个<strong>奇异值</strong><br>$$A=U\Sigma V^T \Rightarrow AV=U\Sigma V^TV \Rightarrow AV=U\Sigma \Rightarrow  Av_i = \sigma_i u_i  \Rightarrow  \sigma_i =  Av_i / u_i$$</p></li></ol><h3 id="上述奇异值分解步骤的依据"><a href="#上述奇异值分解步骤的依据" class="headerlink" title="上述奇异值分解步骤的依据"></a>上述奇异值分解步骤的依据</h3><p>在上面，我们说矩阵$A^TA$的特征向量组成的就是SVD的V矩阵，矩阵$AA^T$的特征向量组成的就是SVD的U矩阵，可以通过如下推导证明(以V矩阵为例)：</p><p>$$ A=U\Sigma V^T \Rightarrow A^T=V\Sigma^T U^T \Rightarrow A^TA = V\Sigma^T U^TU\Sigma V^T = V\Sigma^2V^T $$</p><blockquote><p>上式中我们还发现矩阵$A^TA$特征值矩阵等于A奇异值矩阵的平方，即$\sigma_i = \sqrt{\lambda_i}$，所以其实在第三步中我们求奇异值的方式其实也可以通过求出矩阵$A^TA$的特征值取平方根来求奇异值。</p></blockquote><h2 id="SVD求解实例"><a href="#SVD求解实例" class="headerlink" title="SVD求解实例"></a>SVD求解实例</h2><ul><li>对于一个矩阵A:</li></ul><p>$$ \mathbf{A} = \left( \begin{array}{ccc} 0&amp; 1\\  1&amp; 1\\   1&amp; 0 \end{array} \right) $$</p><ul><li>首先计算出$A^TA$和$AA^T$</li></ul><p>$$ \mathbf{A^TA} = \left( \begin{array}{ccc} 0&amp; 1 &amp;1\\ 1&amp;1&amp; 0 \end{array} \right) \left( \begin{array}{ccc} 0&amp; 1\\  1&amp; 1\\   1&amp; 0 \end{array} \right) = \left( \begin{array}{ccc} 2&amp; 1 \\ 1&amp; 2 \end{array} \right) $$</p><p>$$ \mathbf{AA^T} =  \left( \begin{array}{ccc} 0&amp; 1\\  1&amp; 1\\   1&amp; 0 \end{array} \right) \left( \begin{array}{ccc} 0&amp; 1 &amp;1\\ 1&amp;1&amp; 0 \end{array} \right) = \left( \begin{array}{ccc} 1&amp; 1 &amp; 0\\ 1&amp; 2 &amp; 1\\ 0&amp; 1&amp; 1 \end{array} \right) $$</p><ul><li>求出$A^TA$的特征值与特征向量</li></ul><p>$$ \lambda_1= 3; v_1 = \left( \begin{array}{ccc} 1/\sqrt{2} \\ 1/\sqrt{2} \end{array} \right); \lambda_2= 1; v_2 = \left( \begin{array}{ccc} -1/\sqrt{2} \\ 1/\sqrt{2} \end{array} \right) $$</p><ul><li>求出$AA^T$的特征值与特征向量</li></ul><p>$$ \lambda_1= 3; u_1 = \left( \begin{array}{ccc} 1/\sqrt{6} \\ 2/\sqrt{6} \\ 1/\sqrt{6} \end{array} \right); \lambda_2= 1; u_2 = \left( \begin{array}{ccc} 1/\sqrt{2} \\ 0 \\ -1/\sqrt{2} \end{array} \right);  \lambda_3= 0; u_3 = \left( \begin{array}{ccc} 1/\sqrt{3} \\ -1/\sqrt{3} \\ 1/\sqrt{3} \end{array} \right) $$</p><ul><li>利用$ Av_i = \sigma_i u_i, i=1,2 $求得奇异值，我们会发现求得的结果与$ \sigma_i = \sqrt{\lambda_i} $的结果相同;</li></ul><p>$$ \left( \begin{array}{ccc} 0&amp; 1\\  1&amp; 1\\   1&amp; 0 \end{array} \right) \left( \begin{array}{ccc} 1/\sqrt{2} \\ 1/\sqrt{2} \end{array} \right) = \sigma_1 \left( \begin{array}{ccc} 1/\sqrt{6} \\ 2/\sqrt{6} \\ 1/\sqrt{6} \end{array} \right) \Rightarrow  \sigma_1=\sqrt{3} $$</p><p>$$ \left( \begin{array}{ccc} 0&amp; 1\\  1&amp; 1\\   1&amp; 0 \end{array} \right) \left( \begin{array}{ccc} -1/\sqrt{2} \\ 1/\sqrt{2} \end{array} \right) = \sigma_2 \left( \begin{array}{ccc} 1/\sqrt{2} \\ 0 \\ -1/\sqrt{2} \end{array} \right) \Rightarrow  \sigma_2=1 $$</p><ul><li>最终得到A的奇异值分解为</li></ul><p>$$ A=U\Sigma V^T = \left( \begin{array}{ccc} 1/\sqrt{6} &amp; 1/\sqrt{2} &amp; 1/\sqrt{3} \\ 2/\sqrt{6} &amp; 0 &amp; -1/\sqrt{3}\\ 1/\sqrt{6} &amp; -1/\sqrt{2} &amp; 1/\sqrt{3} \end{array} \right) \left( \begin{array}{ccc} \sqrt{3} &amp; 0 \\  0 &amp; 1\\ 0 &amp; 0 \end{array} \right) \left( \begin{array}{ccc} 1/\sqrt{2}  &amp; 1/\sqrt{2}  \\ -1/\sqrt{2}  &amp; 1/\sqrt{2}  \end{array} \right) $$</p><h1 id="奇异值分解用于压缩"><a href="#奇异值分解用于压缩" class="headerlink" title="奇异值分解用于压缩"></a>奇异值分解用于压缩</h1><ul><li>首先，对于奇异值分解$ A = U\Sigma V^T $，我们也可以写成如下形式，我们假设奇异值大小顺序排列，即$\sigma_1 \geq \sigma_2 \geq…\geq \sigma_n&gt;0$，并且其中每一项的$uv^T$都是秩为1的(m*n)矩阵。</li></ul><p>$$ A = \sigma_1u_1v_1^T + \sigma_2u_2v_2^T + … + \sigma_nu_nv_n^T $$</p><ul><li>对于如下一幅图像，像素（矩阵尺度）为<code>450*333</code></li></ul><p><img src="/img/matrix_singularvalue/compression1.jpg" alt="compression1"></p><ul><li>我们如果只保留最大的奇异值那一项，即另$A_1 = \sigma_1u_1v_1^T$，然后保存这个矩阵，图像显示如下：</li></ul><p><img src="/img/matrix_singularvalue/compression2.jpg" alt="compression2"></p><ul><li>保留前五项，得到下图：</li></ul><p><img src="/img/matrix_singularvalue/compression3.jpg" alt="compression3"></p><ul><li>保留前50项，得到下图：</li></ul><p><img src="/img/matrix_singularvalue/compression4.jpg" alt="compression4"></p><blockquote><p>我们会发现保留前50项就已经得到很不错的图像了，但是这时需要存储的元素为<code>(1+450+333)*50=39200</code>个，远远小于<code>450*333=149850</code>个。</p></blockquote><h1 id="奇异值分解与特征值分解的思考"><a href="#奇异值分解与特征值分解的思考" class="headerlink" title="奇异值分解与特征值分解的思考"></a>奇异值分解与特征值分解的思考</h1><ul><li><p>这两种分解都是在矩阵分析中对复杂矩阵进行<strong>简化矩阵</strong>的手段；</p></li><li><p>奇异值全都大于０，因为是平方根，所以肯定大于0</p></li><li><p>如果将矩阵看做是线性变换的话，特征值分解与奇异值分解都是将矩阵分解成三个线性变换的叠加（两个旋转，一个拉伸）</p></li><li><p>特征值分解与奇异值分解都可以用于压缩矩阵（通过抛弃较小的奇异值/特征值）,pca降维时的计算方式就与其很相关。</p></li></ul><blockquote><p>在opencv中提供了<code>cv::SVD</code>可以直接对矩阵进行奇异值分解</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] 《学习opencv3》（中文版）</li><li>[2] <a href="https://www.cnblogs.com/LeftNotEasy/archive/2011/01/19/svd-and-applications.html">https://www.cnblogs.com/LeftNotEasy/archive/2011/01/19/svd-and-applications.html</a></li><li>[3] <a href="https://www.cnblogs.com/pinard/p/6251584.html">https://www.cnblogs.com/pinard/p/6251584.html</a></li><li>[4] <a href="https://www.zhihu.com/question/22237507">https://www.zhihu.com/question/22237507</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性判别分析(LDA)</title>
    <link href="/2019/01/03/2019-01-03-ml-LDA/"/>
    <url>/2019/01/03/2019-01-03-ml-LDA/</url>
    
    <content type="html"><![CDATA[<p>线性判别分析(Linear Discriminant Analysis，简称LDA)是一种经典的<strong>有监督线性学习</strong>方法，最早在1936年由fisher在二分类问题上提出。这种方法主要用于分类与降维。此处需要说明的是，LDA常常还会是隐含狄利克雷分布(Latent Dirichlet Allocation)的简称，这是自然语言处理领域一种处理文档的主题模型，与本文讲的线性判别分析关系不大。</p><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>LDA的思想及其朴素，这是一种<strong>有监督</strong>学习的技术。给定训练样例集合，设法将样例投影到低维度的空间里，使得同类样例的投影点尽可能接近、异类样例的投影点尽可能远离。概括一下为<strong>投影后类内方差最小，类间方差最大。</strong></p><blockquote><p>一般广义线性模型可表示为$y = g^{-1}(W^{T}x)$,其中W完成线性映射，g函数为联系函数，可以完成非线性转换（比如分类时将回归连续值转换成离散值）。LDA要做的其实是首先使用W将样本从高维空间映射到低维空间，然后根据y的真值将样本分成一群群，通过最大化样本的类间距离、最小化样本的类内方差原则来估计出W。</p></blockquote><p>为了尽量表达清楚，先从最简单的二分类的LDA进行讲解。如下图：</p><p><img src="/img/lda/2lda.png" alt="2lda"></p><h2 id="二分类LDA"><a href="#二分类LDA" class="headerlink" title="二分类LDA"></a>二分类LDA</h2><ul><li><p>假设有数据集$ D=\{(x_1,y_1), (x_2,y_2), …,((x_m,y_m))\} $，其中$x_i$为n维向量，$ y_i \in \{0,1\} $。我们定义</p><ul><li>$N_j(j=0,1)$为第j类样本的个数;</li><li>$X_j(j=0,1)$为第j类样本的集合;</li><li>$u_j(j=0,1)$为第j类样本的均值向量，即$ \mu_j = \frac{1}{N_j}\sum\limits_{x \in X_j}x;;(j=0,1) $;</li><li>$\Sigma_j(j=0,1)$为第j类样本的协方差矩阵，即$ \Sigma_j = \sum\limits_{x \in X_j}(x-\mu_j)(x-\mu_j)^T;;(j=0,1) $；</li></ul></li><li><p>由于两类，所以只需要将数据投影到一条直线上即可。投影到一条直线上，则：</p><ul><li><p>投影矩阵是一个向量，假设为w</p></li><li><p>样本$x_i$投影后为$w^Tx_i$</p></li><li><p>投影后的样本中心为$w^Tu_i$</p></li><li><p>投影后类间方差为$ w^T\Sigma_0w $与$ w^T\Sigma_1w $，类内方差为</p><p>$$ ||w^T\mu_0-w^T\mu_1||_2^2 =  w^T(\mu_0-\mu_1)(\mu_0-\mu_1)^Tw $$</p></li></ul></li><li><p>我们的目标是投影后类内方差最小，类间方差最大，即：</p><p>   $$ \underbrace{arg;max}_w;;J(w) = \frac{||w^T\mu_0-w^T\mu_1||_2^2}{w^T\Sigma_0w+w^T\Sigma_1w} = \frac{w^T(\mu_0-\mu_1)(\mu_0-\mu_1)^Tw}{w^T(\Sigma_0+\Sigma_1)w} $$</p></li><li><p>一般我们定义类内散度为$S_w$为：</p><p>  $$ S_w = \Sigma_0 + \Sigma_1 = \sum\limits_{x \in X_0}(x-\mu_0)(x-\mu_0)^T + \sum\limits_{x \in X_1}(x-\mu_1)(x-\mu_1)^T $$</p></li><li><p>类间散度为$S_b$为：</p><p>  $$ S_b = (\mu_0-\mu_1)(\mu_0-\mu_1)^T $$</p></li><li><p>最后，我们将优化目标重写为</p><p>  $$ \underbrace{arg;max}_w;;J(w) = \frac{w^TS_bw}{w^TS_ww} $$</p></li></ul><blockquote><p>最后的这个优化结果其实是一个<strong>广义瑞利商</strong></p></blockquote><h2 id="瑞利商与广义瑞利商"><a href="#瑞利商与广义瑞利商" class="headerlink" title="瑞利商与广义瑞利商"></a>瑞利商与广义瑞利商</h2><h3 id="瑞利商"><a href="#瑞利商" class="headerlink" title="瑞利商"></a>瑞利商</h3><p>瑞利商是指这样的函数$ R(A,x) $</p><p>$$ R(A,x) = \frac{x^HAx}{x^Hx} $$</p><p>其中：</p><ul><li>x为非零向量</li><li>A为<code>n*n</code>的Hermitan矩阵(共轭转置等于自身的矩阵)，即$A^H = A$，只要A为实矩阵，并且满足$ A^T=A $,即为一个Hermitan矩阵。</li></ul><p>瑞利商$R(A,x)$有一个非常重要的性质，即它的最大值等于矩阵A最大的特征值（此时x为对应的特征向量），而最小值等于矩阵A的最小的特征值，也就满足</p><p>$$ \lambda_{min} \leq \frac{x^HAx}{x^Hx} \leq \lambda_{max} $$</p><blockquote><p>我们可以发现瑞利商的分子分母都是x的二次项，所以最后的结果肯定是与x的长度无关的，只会与x的方向有关，这个结论刚好体现了这样一点。</p></blockquote><h3 id="广义瑞利商"><a href="#广义瑞利商" class="headerlink" title="广义瑞利商"></a>广义瑞利商</h3><p>广义瑞利商是指这样的函数$R(A,B,x)$;</p><p>$$ R(A,x) = \frac{x^HAx}{x^HBx} $$</p><p>其中：</p><ul><li>x为非零向量</li><li>而A,B为<code>n*n</code>的Hermitan矩阵。B为正定矩阵。</li></ul><p>另$x = B^{-1/2}x’ $,此处分母可以转换成：</p><p>$$ x^HBx = x’^H(B^{-1/2})^HBB^{-1/2}x’ = x’^HB^{-1/2}BB^{-1/2}x’ = x’^Hx’ $$</p><p>分子可以转换成：</p><p>$$ x^HAx =  x’^HB^{-1/2}AB^{-1/2}x’ $$</p><p>此时我们的$R(A,B,x)$转化为 $ R(A,B,x’) $</p><p>$$ R(A,B,x’) = \frac{x’^HB^{-1/2}AB^{-1/2}x’}{x’^Hx’} $$</p><p>利用前面的瑞利商的性质，我们可以很快的知道，$R(A,B,x)$的最大值为矩阵$ B^{-1/2}AB^{-1/2} $的最大特征值，而最小值为矩阵$ B^{-1/2}AB^{-1/2} $的最小特征值。或者说是$B^{-1}A$的最大特征值。</p><h3 id="二类LDA的广义瑞利商结果"><a href="#二类LDA的广义瑞利商结果" class="headerlink" title="二类LDA的广义瑞利商结果"></a>二类LDA的广义瑞利商结果</h3><p>接下来回到二类LDA的优化目标</p><p>$$ \underbrace{arg;max}_w;;J(w) = \frac{w^TS_bw}{w^TS_ww} $$</p><p>这个广义瑞利商的最大值为矩阵$ S^{−\frac{1}{2}}_wS_bS^{−\frac{1}{2}}_w $的最大特征值，对应的w为其对应的特征向量。而$S_w^{-1}S_b$的特征值和$S^{−\frac{1}{2}}_wS_bS^{−\frac{1}{2}}_w$的特征值相同，$S_w^{-1}S_b$的特征向量w’和$S^{−\frac{1}{2}}_wS_bS^{−\frac{1}{2}}_w$的特征向量满足$w’ = S^{−\frac{1}{2}}_ww$的关系。　　　　</p><h2 id="多类LDA"><a href="#多类LDA" class="headerlink" title="多类LDA"></a>多类LDA</h2><ul><li>数据集$ D=\{(x_1,y_1), (x_2,y_2), …,((x_m,y_m))\} $，其中$x_i$为n维向量，$y_i \in \{C_1,C_2,…,C_k\}$为所属类别</li><li>我们定义$N_i$为第i类样本个数，$X_i$为第i类样本的集合</li><li>$\mu_i$为第i类样本的均值向量，$\Sigma_i$为第i类样本的协方差矩阵。</li></ul><p>此时为多类向低维度空间的投影，我们假设投影到的低维度空间的维度为d，对应的基向量为$(w_1,w_2,…w_d)$，基向量组成的投影矩阵为W，它是一个<code>n*d</code>的矩阵(d==1为二分类情况)。</p><p>此时优化目标是：</p><p>$$ \frac{W^TS_bW}{W^TS_wW} $$</p><p>其中，</p><ul><li>$ S_b = \sum\limits_{j=1}^{k}N_j(\mu_j-\mu)(\mu_j-\mu)^T $,代表类间散度(u为所有样本均值向量)</li><li>$ S_w =  \sum\limits_{j=1}^{k}S_{wj} = \sum\limits_{j=1}^{k}\sum\limits_{x \in X_j}(x-\mu_j)(x-\mu_j)^T $，代表类内散度之和</li></ul><p>此时，$W^TS_bW$与$W^TS_wW$都是矩阵，不是标量，无法作为一个标量函数进行优化。</p><p>可以将上式进行分解(与奇异值分解压缩形式类似)</p><p>$$ J(W) = \frac{W^TS_bW}{W^TS_wW} = \frac{\prod\limits_{i=1}^dw_i^TS_bw_i}{\prod\limits_{i=1}^dw_i^TS_ww_i} = \prod\limits_{i=1}^d\frac{w_i^TS_bw_i}{w_i^TS_ww_i} $$</p><p>此时右边又变成了广义瑞利商。每个乘积项最大值是矩阵$S_w^{-1}S_b$的最大特征值，最大的乘积就是矩阵$S_w^{-1}S_b$的最大的d个特征值的乘积。此时对应的投影矩阵W就对应着最大的d个特征值对应的特征向量张成的矩阵。</p><h2 id="LDA算法流程"><a href="#LDA算法流程" class="headerlink" title="LDA算法流程"></a>LDA算法流程</h2><ul><li>输入：数据集$ D=\{(x_1,y_1), (x_2,y_2), …,((x_m,y_m))\} $，其中任意样本$x_i$为n维向量，$ y_i \in \{C_1,C_2,…,C_k\} $，降维到的维度d。</li><li>输出：投影矩阵W与降维后的样本集D’</li></ul><ol><li>计算类内散度矩阵$S_w$</li><li>计算类间散度矩阵$S_b$</li><li>计算矩阵$S_w^{-1}S_b$</li><li>计算$S_w^{-1}S_b$最大的d个特征值和对应的d个特征向量$(w_1,w_2,…w_d)$，得到投影矩阵W(二分类时是向量)</li><li>对样本集中的每一个样本特征$x_i$，转化成新的样本$z_i = W^Tx_i$;</li><li>得到输出样本集$ D’=\{(z_1,y_1), (z_2,y_2), …,((z_m,y_m))\} $</li></ol><h2 id="LDA与PCA的比较"><a href="#LDA与PCA的比较" class="headerlink" title="LDA与PCA的比较"></a>LDA与PCA的比较</h2><ol><li>这两种方法都有降维的思想</li><li>pca是无监督的，lda是有监督的</li><li>pca主要用来压缩与简化</li><li>lda是一种线性分类器，主要用来分类等</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] 《机器学习》，周志华著；</li><li>[2] <a href="https://www.cnblogs.com/pinard/p/6244265.html">https://www.cnblogs.com/pinard/p/6244265.html</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵的特征值分解</title>
    <link href="/2018/12/26/2018-12-26-matrix-eigenvalue/"/>
    <url>/2018/12/26/2018-12-26-matrix-eigenvalue/</url>
    
    <content type="html"><![CDATA[<h1 id="特征值分解"><a href="#特征值分解" class="headerlink" title="特征值分解"></a>特征值分解</h1><p>物理意义： </p><ol><li>矩阵可以表示一种变换；</li><li>特征向量表示矩阵变换的方向；</li><li>特征值表示矩阵变换在对应特征向量方向上的变换速度；</li></ol><h2 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h2><p>如下一个二维向量$\vec{v_{}}$，这个二维空间的基向量是$\vec{i_{}}$与$\vec{j_{}}$;</p><p><img src="/img/matrix_eigenvalue/p1.png" alt="p1"></p><p>将向量$\vec{v_{}}$左乘一个矩阵$\mathbf{A}$，情况变成如下：</p><p><img src="/img/matrix_eigenvalue/p2.png" alt="p2"></p><p>奇妙的来了，如果调整一下被乘的向量$\vec{v_{}}$的方向到一个特定的方向，则会出现如下情况</p><p><img src="/img/matrix_eigenvalue/p3.png" alt="p3"></p><p>可以观察到，调整后的$\vec{v_{}}$和$A\vec{v_{}}$在同一根直线上，只是$A\vec{v_{}}$的长度相对$\vec{v_{}}$的长度变长了。此时，我们就称$\vec{v_{}}$是$A$的<strong><em>特征向量</em></strong>，而$A\vec{v_{}}$的长度是$\vec{v_{}}$的长度的$\lambda$倍，$\lambda$就是<strong>特征值</strong>。</p><p>从而，特征值与特征向量的定义式就是这样的：</p><p><img src="/img/matrix_eigenvalue/p4.png" alt="p4"></p><p>特征向量所在的直线上的所有向量都满足特征向量的上述定义，我们称其为<strong>特征空间</strong>。不过一般每个特征向量通常定义为一个单位向量（因为主要的意义是用来表示方向的）。</p><blockquote><p>当然了，一个矩阵通常不止一个特征向量，比如一个<code>n*n</code>的矩阵最多有n个特征向量，每个特征向量之间相互正交，也有可能没有特征向量（求得时候发现方程无解或是复数）</p></blockquote><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>上面说了，特征向量表示矩阵变换的方向，特征值表示该方向上的变换速度。整个变换怎么理解呢？</p><p>我们可以这样想，每个矩阵在对一个向量做变换的时候，</p><ol><li>首先将这个向量使用特征向量组成的正交基向量进行<strong>分解</strong></li><li>然后目标向量在每个特征向量方向上的分量分别进行<strong>拉伸操作</strong></li><li>对所有特征向量方向上的拉伸结果进行<strong>合并</strong>。</li></ol><blockquote><p>这个分解操作可以由下面的特征值分解进行解释</p></blockquote><h2 id="特征值分解其实是运动分解"><a href="#特征值分解其实是运动分解" class="headerlink" title="特征值分解其实是运动分解"></a>特征值分解其实是运动分解</h2><p>一个矩阵进行特征值分解，这是一种将矩阵分解表示的操作。可以通过只保留比较重要的特征向量（将其他置为零）来压缩矩阵。</p><p>$$  \mathbf{A} = \mathbf{V} \mathbf{D} \mathbf{V^{-1}} $$</p><p>其中，</p><ul><li>V是n个特征向量组成的<code>n*n</code>维矩阵</li><li>D是n个特征值组成的一个对角矩阵（只有对角线上值不为0，维度也是<code>n*n</code>）</li><li>上面V与D中的特征向量与特征值是有序配对的，即第i个特征值对应第i个特征向量</li></ul><p>使用一个具体例子进行解释如下：</p><p><img src="/img/matrix_eigenvalue/p5.png" alt="p5"></p><p>如果使用这个矩阵对向量进行变换操作，我们会发现</p><p><img src="/img/matrix_eigenvalue/p6.png" alt="p6"></p><p>特征值分解其实就是将矩阵的变换操作分解了，将旋转与拉伸分离开来，最后达到上述<a href="#意义">意义</a>的效果。我们逐步解释</p><ul><li>首选这是原本的基向量</li></ul><p><img src="/img/matrix_eigenvalue/p7.png" alt="p7"></p><ul><li>左乘$ {V^{-1}}$后，将原本的基向量进行了旋转，变换到矩阵特征向量上，即“将目标向量使用特征向量组成的正交基向量进行了<strong>分解</strong>”</li></ul><p><img src="/img/matrix_eigenvalue/p8.png" alt="p8"></p><ul><li>下面再左乘对角矩阵$ \mathbf{D} $，将<strong>目标向量在每个特征向量方向上的分量分别进行了拉伸操作</strong></li></ul><p><img src="/img/matrix_eigenvalue/p9.png" alt="p9"></p><ul><li>最后在左乘$ {V^{}}$，这个操作将基向量重新变换到原本的基向量上，即可以理解成”对所有特征向量方向上的拉伸结果进行<strong>合并</strong>“</li></ul><p><img src="/img/matrix_eigenvalue/p10.png" alt="p10"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过了解了整个特征值分解的意义，我们应该便能理解为什么说只对<strong>方阵</strong>进行特征值分解了。</p><blockquote><p>这是因为只有方阵才能够在矩阵空间提取出符合<strong>完全正交基</strong>的特征向量，这样对于任何一个目标向量进行变换时，才能使用特征向量对目标向量进行完全表示。如果不能提取出满足条件的特征向量，则特征值分解的公式是<strong>不成立</strong>的!</p></blockquote><p>$$  \mathbf{A} = \mathbf{V} \mathbf{D} \mathbf{V^{-1}} $$</p><p>那不能特征值分解时怎么办呢？我们可以使用<strong>奇异值分解</strong></p><h3 id="应用案例：压缩图像"><a href="#应用案例：压缩图像" class="headerlink" title="应用案例：压缩图像"></a>应用案例：压缩图像</h3><p>如下有一幅<code>512*512</code>的灰度图像(只有方阵才能压缩)</p><p><img src="/img/matrix_eigenvalue/p11.jpg" alt="p11"></p><p>这个图片可以放到一个矩阵里面去，就是把每个像素的颜色值填入到一个$512 \times 512$的A矩阵中。<br>根据之前描述的有：<br>$$  \mathbf{A} = \mathbf{V} \mathbf{D} \mathbf{V^{-1}} $$</p><p>其中，$ \mathbf{D} $是对角阵，对角线上是从大到小排列的特征值。</p><p>我们在$ \mathbf{D} $中只保留前面50个的特征值（也就是最大的50个，其实也只占了所有特征值的百分之十），其它的都填0，重新计算矩阵后，恢复为下面这样的图像：</p><p><img src="/img/matrix_eigenvalue/p12.jpg" alt="p12"></p><p>效果还可以，其实一两百个特征值之和可能就占了所有特征值和的百分之九十了，其他的特征值都可以丢弃了。</p><blockquote><p>不过注意:在通过特征值分解的方式压缩过后，这个图像就不再是以前的图像了。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] <a href="https://www.matongxue.com/madocs/228.html">https://www.matongxue.com/madocs/228.html</a></li><li>[2] <a href="https://zh.wikipedia.org/zh-hans/%E7%89%B9%E5%BE%81%E5%88%86%E8%A7%A3">https://zh.wikipedia.org/zh-hans/%E7%89%B9%E5%BE%81%E5%88%86%E8%A7%A3</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>光流算法简述</title>
    <link href="/2018/12/24/2018-12-24-optical-flow/"/>
    <url>/2018/12/24/2018-12-24-optical-flow/</url>
    
    <content type="html"><![CDATA[<p><strong>光流(optical　flow)</strong>，字面意思描述的是图像中像素强度的流动。光流法的<strong>目的</strong>是根据图像中像素点的灰度值强度变化估计出物体移动速度与方向。</p><h1 id="光流"><a href="#光流" class="headerlink" title="光流"></a>光流</h1><h2 id="光流的假设"><a href="#光流的假设" class="headerlink" title="光流的假设"></a>光流的假设</h2><p>首先，光流估计指的是利用时间上相邻的两帧图像内<strong>像素强度的变化</strong>来计算点的运动。原理决定了这种方法是建立在一系列假设上的。</p><ul><li>前后两帧中点的位移不大</li><li>灰度不变假设，这要求外界光强保持恒定</li><li>空间相关性，每个点的运动和邻近的点类似</li></ul><blockquote><p>好像这么多假设有些不靠谱，但是其实光流的输入图像一般时间间隔极小，这使得这么短的时间内，位移，光照强度等都变化极小。这样的假设其实是可以接受的。</p></blockquote><h2 id="光流的原理"><a href="#光流的原理" class="headerlink" title="光流的原理"></a>光流的原理</h2><p>上述假设中的核心是第二条，灰度不变假设。</p><p>$$ I(x,y,t) = I(x+dx, y+dy, t+dt) $$</p><p>将上式右项进行泰勒展开，可以得到</p><p>$$ I(x+dx, y+dy, t+dt) \approx I(x,y,t) + \frac{\partial I}{\partial x}dx + \frac{\partial I}{\partial y}dy + \frac{\partial I}{\partial t}dt $$</p><p>由于我们假设灰度不变，所以即</p><p>$$ \frac{\partial I}{\partial x}dx + \frac{\partial I}{\partial y}dy + \frac{\partial I}{\partial t}dt \approx 0 $$</p><p>上式同时除以$dt$得：</p><p>$$ \frac{\partial I}{\partial x}\frac{dx}{dt} + \frac{\partial I}{\partial y}\frac{dy}{dt} = - \frac{\partial I}{\partial t} $$</p><ul><li>上式中$\frac{dx}{dt}$代表的是像素在ｘ轴上的运动速度，$\frac{dy}{dt}$代表的是像素在ｙ轴上的运动速度，此处我们将其分别记为$u,v$。</li><li>上式中$\frac{\partial I}{\partial x}$代表的是像素在x方向上的梯度，$\frac{\partial I}{\partial y}$代表的是像素在y方向上的梯度，我们将其记为$I_x,I_y$</li></ul><p>上式可写成如下形式</p><p>$$ \begin{bmatrix} I_x &amp; I_y \end{bmatrix} \begin{bmatrix} u \\ v \end{bmatrix} = -I_t $$</p><ul><li>其中$I_x,I_y$我们可以通过简单的求梯度卷积操作计算得到</li><li>$ I_t $可以通过图像序列得到</li></ul><blockquote><p>由此我们可以计算出$(u,v)$，一般一幅图像中如果我们选取n个点(一般这n个点比较靠近，因为图像中不同区域中的点运动尺寸很可能不一致)进行光流跟踪，就会有n个方程。多个方程求解两个变量，我们可以<strong>迭代</strong>求得一个最优解。</p></blockquote><h2 id="LK光流"><a href="#LK光流" class="headerlink" title="LK光流"></a>LK光流</h2><p>LK光流指的是通过建立一个<strong>观察窗口</strong>，假设窗口内的像素点的位移是相同的。由此可以建立一个超定方程。使用最小二乘法进行求解。</p><blockquote><p>需要指出的是，上述推导中添加了时间项，其实不加时间也是可以的。加了时间求解出来的$(u,v)$是该点移动的速度，如果不加时间的话，求解出来的就是该点移动的向量了。</p></blockquote><h2 id="维持位移小假设"><a href="#维持位移小假设" class="headerlink" title="维持位移小假设"></a>维持位移小假设</h2><p>问题：上面提到光流的第一条假设是前后两帧中的点位移相差不大。这是因为位移较大时，泰勒展开近似就会不成立了。</p><p>解决方法：使用图像金字塔建立多尺度的图像空间，这样本来较大的位移在新的层级比较高的尺度空间上会变小。</p><blockquote><p>此种做法也叫作$coarse to fine$，即代表的是，首先在分辨率最小的层级上进行光流跟踪，将得到的结果带入到分辨率次低的层上作为输入，再进行光流跟踪。顺着金字塔依次执行到最低层。可以增加在位移较大情况下的稳定性。</p></blockquote><h2 id="维持光度不变假设"><a href="#维持光度不变假设" class="headerlink" title="维持光度不变假设"></a>维持光度不变假设</h2><p>问题：我们知道光流三大假设中最核心的假设是光度不变假设。但是有时由于光照条件、相机曝光时间等因素，此假设很难满足。</p><p>解决方案：此时我们的解决方法有多种，比较简单的方法有图像块去均值，稍微复杂一点的方法有光度标定。</p><blockquote><p>此处光度标定的原理暂且不展开讲了，之后我会专门写一篇博客讲述光度标定的原理。</p></blockquote><h2 id="维持相关性假设"><a href="#维持相关性假设" class="headerlink" title="维持相关性假设"></a>维持相关性假设</h2><p>问题：上面提到的三大假设的最后一项是空间相关性假设，即假设建立超定方程的点群的位移相同。此假设在相机只有位移的时候，可以大概满足。但是当相机只发生旋转的时候，我们会发现其实一个$9*9$方块中的点似乎不在是位移相同的了。</p><p>解决方法：使用带有6个元素的仿射变换代替只有两个元素的位移来描述窗口中每个元素的变换，由于仿射变换可以应对旋转的情况，因此会更加鲁棒。缺点是参数变多了，超定方程组需要更大点。</p><h2 id="光流方法评价"><a href="#光流方法评价" class="headerlink" title="光流方法评价"></a>光流方法评价</h2><p>光流方法速度很快，求解方法可以使用求解超定方程组，也可以使用高斯牛顿等迭代操作完成。</p><h2 id="光流残差的构造方式"><a href="#光流残差的构造方式" class="headerlink" title="光流残差的构造方式"></a>光流残差的构造方式</h2><h3 id="前向-forward-与逆向-inverse"><a href="#前向-forward-与逆向-inverse" class="headerlink" title="前向(forward)与逆向(inverse)"></a>前向(forward)与逆向(inverse)</h3><p>上面推导光流原理时提到我们需要使用图像中该点处的像素梯度，前向光流使用的目标帧的图像梯度，逆向光流使用的是当前帧的图像梯度。</p><h3 id="叠加式-additive-与构造式-compositional"><a href="#叠加式-additive-与构造式-compositional" class="headerlink" title="叠加式(additive)与构造式(compositional)"></a>叠加式(additive)与构造式(compositional)</h3><p>在传统光流中估计的是点的位移，但是更鲁棒的做法可能是估计该二维点到另一个二维点的仿射变换。假设该变换函数为w，参数为p，则对于原本的二维点x，经过变换到新的位置为$w(x,p)$。</p><p>叠加式与构造式指的是在优化解决光流时更新参数p的方式，其中叠加式为：</p><p>$w(x, p + \delta p)$</p><p>构造式为：</p><p>$w( w(x, p), \delta p) $</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] 视觉SLAM十四讲</li><li>[2] <a href="https://xmfbit.github.io/2017/05/03/cs131-opticalflow/">https://xmfbit.github.io/2017/05/03/cs131-opticalflow/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主成分分析(PCA)</title>
    <link href="/2018/12/20/2018-12-20-ml-PCA/"/>
    <url>/2018/12/20/2018-12-20-ml-PCA/</url>
    
    <content type="html"><![CDATA[<h1 id="1-主成分分析原理介绍"><a href="#1-主成分分析原理介绍" class="headerlink" title="1. 主成分分析原理介绍"></a>1. 主成分分析原理介绍</h1><blockquote><p>PCA是一种<strong>无监督的降维方法</strong>，主要作用是压缩与简化</p></blockquote><p>顾名思义，主成分分析(PCA)是用来分析数据的主要成分的。</p><p>打个比方，一些ｎ维点可以用一个ｎ维的坐标完全表示。主成分分析，可以提取出<strong>ｎ个空间基向量</strong>来表示这些数据点。不过你可以理解成这ｎ个空间基向量是按顺序求出的，首先根据这些ｎ维点确定第一个空间基向量方向，使得如果只能用一个基向量来表示这些点，只使用这个基向量表示这些二维点误差最小。然后求下一个基向量，使得只使用这两个基向量表示这些ｎ维点误差最小。依次类推，直到求出n维度完备的空间向量基，便肯定可以完全表示了。</p><p><img src="/img/pca/pca_line.png" alt="pca_line"></p><p>如上图，是根据一些二维点计算出来的第一个“主成分”基向量。</p><p><img src="/img/pca/pca_eigen.png" alt="pca_eigen"></p><p>如上图，是这些二维点的两个<strong>主成分</strong>基向量。</p><blockquote><p>由上面分析我们发现，PCA可以用来做<strong>降维</strong>。虽然肯定会有些精度损失，但是这已经是最小的精度损失了。</p></blockquote><h1 id="2-主成分分析-PCA-的代码实现"><a href="#2-主成分分析-PCA-的代码实现" class="headerlink" title="2. 主成分分析(PCA)的代码实现"></a>2. 主成分分析(PCA)的代码实现</h1><p>通常m个n维点排列在一起会得到一个<code>m*n</code>矩阵，很奇妙的是，我们可以通过数学推导得出ｎ个特征向量，这个矩阵包含的点集合的<strong>主成分</strong>就是这n个特征向量集合。这些特征向量的代表的主要成分的重要重要程度可以用其对应的特征值来衡量，<strong>特征值越大，其对应的特征向量代表的主成分越重要</strong>。</p><p>比如你有$x_1…x_m$总共m个数据，其中每个数据由n个变量表示，我们的目的是将这m个数据使用少于n个变量表示，比如将维度降为<code>p，p&lt;n</code>。这个过程叫做<strong>降维</strong>。具体操作步骤如下：</p><h2 id="2-1-组织数据集"><a href="#2-1-组织数据集" class="headerlink" title="2.1 组织数据集"></a>2.1 组织数据集</h2><p>首先将数据整理成如下固定形式。</p><ul><li>将$x_1…x_m$写成行向量，每一行有n个元素，即n列。</li><li>将这些行向量放入一个单一的矩阵x，矩阵维度是<code>m*n</code></li></ul><h2 id="2-2-计算经验均值"><a href="#2-2-计算经验均值" class="headerlink" title="2.2 计算经验均值"></a>2.2 计算经验均值</h2><ul><li>计算每一个维度的经验均值，维度总共有$j = 1, …, n$</li><li>将计算出来的n个经验均值放入一个向量u，这个向量维度是<code>n*1</code></li></ul><p>$$ \mathbf{u[j]} = \frac{1}{m}\sum_{i=1}^{m}\mathbf{X[i,j]} $$</p><h2 id="2-3-计算离均值的偏差矩阵"><a href="#2-3-计算离均值的偏差矩阵" class="headerlink" title="2.3 计算离均值的偏差矩阵"></a>2.3 计算离均值的偏差矩阵</h2><p>我们计算均值的原因是我们想把数据搬移到原点附近，让原点处于这些数据的中心，这样可以使得均方误差最小。所以这一步要做的就是：</p><ul><li>将矩阵x的每一行都减去均值向量u</li><li>得到一个新的均值矩阵B，维度也是<code>m*n</code></li></ul><p>上述操作可以使用如下方式完成</p><p>$$ \mathbf{B} = \mathbf{X} - \mathbf{h}\mathbf{u^{T}} $$</p><p>其中，h是一个<code>m*1</code>的列向量，并且值为全1。</p><h2 id="2-4-计算上述偏差矩阵的协方差矩阵"><a href="#2-4-计算上述偏差矩阵的协方差矩阵" class="headerlink" title="2.4 计算上述偏差矩阵的协方差矩阵"></a>2.4 计算上述偏差矩阵的协方差矩阵</h2><ul><li>这一步是计算B矩阵的协方差矩阵C，C矩阵的维度会是<code>n*n</code>。可以使用下式实现</li></ul><p>$$ \mathbf{C} = \frac{1}{m-1} \mathbf{B^{*}} \cdot \mathbf{B} $$</p><p>上式中<code>*</code>是共轭转置运算符。不过由于一般B中包含的都是实数，所以在大部分情况下这个操作相当于一个转置运算符。</p><h2 id="2-5-由特征值分解求得上一步中协方差矩阵的特征值与特征向量"><a href="#2-5-由特征值分解求得上一步中协方差矩阵的特征值与特征向量" class="headerlink" title="2.5 由特征值分解求得上一步中协方差矩阵的特征值与特征向量"></a>2.5 由特征值分解求得上一步中协方差矩阵的特征值与特征向量</h2><p>首先说明一下，特征值与特征向量还有矩阵之间的关系。</p><blockquote><p>特征向量是<strong>矩阵空间的基向量</strong>，长度为1，特征向量之间互相正交，特征值是矩阵在对应特征向量上的投影。将矩阵理解成一种变换，则每个特征向量就是这个变换的一个方向，对应的特征值就是在这个方向上的变换速度。</p></blockquote><p>一般对于一个矩阵C(维度为<code>n*n</code>)，会存在n个特征向量(每个维度都是n)，与n个特征值，每个特征值对应一个特征向量。它们之间的关系如下：</p><p>$$ \mathbf{V^{-1}} \mathbf{C} \mathbf{V} = \mathbf{D} 　也可以写成　 \mathbf{C} = \mathbf{V} \mathbf{D} \mathbf{V^{-1}} $$</p><p>其中，</p><ul><li>V是n个特征向量组成的<code>n*n</code>维矩阵</li><li>D是n个特征值组成的一个对角矩阵（只有对角线上值不为0，维度也是<code>n*n</code>）</li><li>上面V与D中的特征向量与特征值是有序配对的，即第i个特征值对应第i个特征向量</li></ul><blockquote><p><strong>特征值分解</strong>(变换矩阵必须是方阵)就是从矩阵C中分解出V与D，我们下面可以做的就是根据特征值的大小保留前p个特征向量，作为新的维度基础。实现将n维度降维到p维度。</p></blockquote><h1 id="3-opencv中的cv-PCA类的使用"><a href="#3-opencv中的cv-PCA类的使用" class="headerlink" title="3. opencv中的cv::PCA类的使用"></a>3. opencv中的<code>cv::PCA</code>类的使用</h1><p>见我的<a href="">github</a></p><h1 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h1><ul><li>[1] <a href="https://docs.opencv.org/3.4.1/d1/dee/tutorial_introduction_to_pca.html">https://docs.opencv.org/3.4.1/d1/dee/tutorial_introduction_to_pca.html</a></li><li>[2] <a href="https://robospace.wordpress.com/2013/10/09/object-orientation-principal-component-analysis-opencv/">https://robospace.wordpress.com/2013/10/09/object-orientation-principal-component-analysis-opencv/</a></li><li>[3] <a href="https://en.wikipedia.org/wiki/Principal_component_analysis">https://en.wikipedia.org/wiki/Principal_component_analysis</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统下文件权限问题解析</title>
    <link href="/2018/12/16/2018-12-16-linux-file-permission/"/>
    <url>/2018/12/16/2018-12-16-linux-file-permission/</url>
    
    <content type="html"><![CDATA[<p>我们都知道，在linux下一切都是文件，目录也是文件，本文主要讨论常规文件与目录文件的权限问题。</p><p>使用<code>ll</code>(即ls -l)我们可以查看当前文件夹下的文件的及其相关属性。</p><p><img src="/img/file_permission/ls.png" alt="ls"></p><p>我们会发现每个文件都会有三种权限<code>rwx</code>，且为其拥有者、所属用户组成员、其他用户分别进行了不同的设置。</p><blockquote><p>在每行最前面一位，在这里我们会发现是符号<code>d</code>或<code>-</code>，这代表的是文件类型，<code>-</code>代表着常规文件，<code>d</code>代表目录文件，当然还会有一些其他的特殊文件类型，可以查看书《鸟哥的linux私房菜第四版》163页。</p></blockquote><h2 id="文件所有者与所有群"><a href="#文件所有者与所有群" class="headerlink" title="文件所有者与所有群"></a>文件所有者与所有群</h2><p>Linux/Unix 是多用户多任务操作系统，所有的文件皆有其拥有者（Owner）。利用<code>chown</code>命令 可以将文件的拥有者加以改变。一般来说，这个命令只能由系统管理者(root)使用，一般用户没有权限来改变别人的文件的拥有者，也没有权限可以将自己的文件的拥有者改设为别人。只有<strong>系统管理者(root)</strong>才有这样的权限。</p><blockquote><p><code>chgrp</code>命令与<code>chown</code>一样，但是<code>chmod</code>不需要系统管理员权限，普通用户就可以使用。</p></blockquote><h2 id="常规文件的rwx权限"><a href="#常规文件的rwx权限" class="headerlink" title="常规文件的rwx权限"></a>常规文件的<code>rwx</code>权限</h2><ul><li>r(read): 用户可以读取此文件的内容，比如读取文本文件的文字内容等；</li><li>w(write): 用户可以编辑、新增或是修改该文件的内容（但不含删除该文件）；</li><li>x(execute): 用户具有执行该文件的权限；</li></ul><blockquote><p>常规文件的<strong>基本权限</strong>是<code>r</code>权限，如果你想要修改一个文件或者执行一个文件，除了<code>w</code>或<code>x</code>权限，你还需要拥有该文件的<code>r</code>权限。</p></blockquote><h2 id="目录文件的rwx权限"><a href="#目录文件的rwx权限" class="headerlink" title="目录文件的rwx权限"></a>目录文件的<code>rwx</code>权限</h2><ul><li>r(read): 用户具有读取目录结构列表的权限；</li><li>w(write): 用户具有改动目录结构列表的权限，比如<ul><li>建立新的文件与目录；</li><li>删除已经存在的文件与目录（不论该文件的权限是什么）；</li><li>将已存在的文件或目录进行更名；</li><li>移动该目录内的文件、目录位置</li></ul></li><li>x(execute): 用户具有进入该目录，并将该目录作为工作目录（其实就是能对该目录下的文件或者在该目录下执行命令）的权限；</li></ul><blockquote><p>目录文件的<strong>基本权限</strong>是<code>x</code>权限，因为只有具备了它，你才能执行一切与该目录下有关的命令操作。（其实如果只有r权限的话，也是可以执行ls操作获得文件列表的，只是系统还是会提示权限不够，如下）</p></blockquote><p><img src="/img/file_permission/dir.png" alt="dir"></p><h2 id="文件的隐藏属性"><a href="#文件的隐藏属性" class="headerlink" title="文件的隐藏属性"></a>文件的隐藏属性</h2><p>除了上述的三个常用的权限属性外，文件还会有一些隐藏属性，可以使用<code>lsattr</code>查看，使用<code>chattr</code>进行设置。</p><p>比如说，使用<code>lsattr</code>查看当前文件夹下文件的隐藏属性</p><p><img src="/img/file_permission/lsattr.png" alt="lsattr"></p><p>我们会发现隐藏属性里只开启了一个<code>e</code>属性，这个属性是ext3与ext4文件系统自带的属性。</p><blockquote><p>具体还有哪些隐藏属性，这两个命令更详细操作方式，可以查看《鸟哥的linux私房菜第四版》197页，此处只进行简单的讲解。</p></blockquote><p>##　文件的特殊权限<br>有时我们会发现有些文件的权限并不是<code>rwx</code>，而是<code>rws</code>、<code>rwt</code>等，这里的s与t都是特殊权限。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] 鸟哥的linux私房菜（第四版）</li><li>[2] <a href="http://blog.51cto.com/1024079574/1746139">http://blog.51cto.com/1024079574/1746139</a></li><li>[3] <a href="https://blog.csdn.net/wh8_2011/article/details/69815660">https://blog.csdn.net/wh8_2011/article/details/69815660</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>磁盘分区问题解析</title>
    <link href="/2018/12/02/2018-12-02-disk-partition/"/>
    <url>/2018/12/02/2018-12-02-disk-partition/</url>
    
    <content type="html"><![CDATA[<p>要想使用一块硬盘，我们需要怎么做呢？假设操作系统已经识别到了一块硬盘，剩下的在linux上主要可以分成三步来完成：</p><ul><li>分区(对硬盘进行划分)</li><li>格式化分区(在分区上进行文件系统初始化)</li><li>将格式化好的分区(文件系统)进行挂载</li></ul><p>这篇博客主要记录磁盘分区知识。</p><p>目前，磁盘分区主要使用两种方式，分别是<strong>MBR</strong>磁盘分区方式与<strong>GPT</strong>磁盘分区方式。其中前者是比后者先出现，后来随着磁盘容量越来越大，前者已经不能很好的适应新的状况了，于是出现了后者。但是如今个人电脑磁盘分区主要还是使用MBR分区方式，因为在磁盘容量没有大于2.2TB时，完全够用，而且可以很好的兼容旧的主板。</p><blockquote><p>其实所谓的分区方式其实是一种格式，按照<strong>某种格式</strong>对磁盘进行划分。</p></blockquote><h1 id="MBR分区格式"><a href="#MBR分区格式" class="headerlink" title="MBR分区格式"></a>MBR分区格式</h1><blockquote><p>MBR(<strong>Master Boot Record</strong>，主引导记录)的根源是windows用来处理启动引导程序和分区表的方式。早期的linux系统为了兼容windows的磁盘，也使用了这种分区方式。</p></blockquote><p>所以，MBR分区格式的做法其实是将<strong>启动引导程序记录区</strong>与<strong>分区表</strong>都放在了磁盘的第一个扇区（早期通常是一个扇区512字节）。其中</p><ul><li>主引导记录(Master Boot Record，也就是MBR): 也就是可以安装启动引导程序的地方，占据446字节。</li><li>分区表(partition table): 记录整块硬盘分区的状态，占据64字节空间。</li></ul><p>我们今天主要讨论的就是上述的分区表。这个分区表只有64字节，最多放置<strong>四组记录区</strong>，每组记录区<strong>记录</strong>了一个分区的起始与结束的柱面号码。如下大致如下图所示：</p><p><img src="/img/mbr_gpt/mbr_partition.png" alt="mbr_partition"></p><blockquote><p>上述由磁盘<strong>第一个</strong>扇区上的分区表划分出来的分区（<strong>最多四个</strong>）叫做<strong>主要</strong>分区或者叫做<strong>扩展</strong>分区。分区的<strong>最小单位</strong>是柱面(cylinder)。什么是柱面可以参考下面的磁盘构造图</p></blockquote><p><img src="/img/mbr_gpt/disk.png" alt="disk"></p><p>只能划分四个分区是肯定不行的，在MBR分区格式中我们还可以使用<strong>扩展分区</strong>的方式来实现多于四个分区的情况。如下图所示，便是一个扩展分区的例子。</p><p><img src="/img/mbr_gpt/mbr_extend.png" alt="mbr_extend"></p><p>在这个例子中，磁盘第一个扇区上的分区表我们只使用了前两组分区记录表，第一个是主分区，第二个是扩展分区。通常每组分区记录中会有一个字节是存储分区类型值的，可以在此指定为扩展分区。然后扩展分区会在自己的区域再次进行分区划分，图中的<code>L1~L5</code>是扩展分区上划分出来的五个<strong>逻辑分区</strong>。</p><blockquote><p>其实<strong>扩展分区本质</strong>上并不是一个分区，它是一个指向下一个分区的指针，这种指针结构最后会形成一个单向链表。具体扩展分区形式比较复杂，以后我完全弄懂了再补充，如今先按照上图中的方式理解。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>主要分区与扩展分区最多可以有４个</li><li>扩展分区最多只能有１个（操作系统的限制）</li><li>逻辑分球是由扩展分区持续划分出来的分区</li><li>主要分区与逻辑分区可以被格式化或最为数据存取的分区，扩展分区不能（本质上不是一个分区）</li><li>逻辑分区的容量依据操作系统而不同，在linux上SATA硬盘可以突破63个以上的分区限制。</li></ul><blockquote><p>每个<strong>物理磁盘</strong>文件的文件名为<code>/dev/sd[a~p]</code>的格式，而每个磁盘上的<strong>分区文件</strong>的文件名（拿<code>/dev/sda</code>磁盘文件举例）被命名成<code>/dev/sda[1~128]</code>，mbr分区表中<code>/dev/sda[1~4]</code>是主分区或扩展分区，剩下的是逻辑分区。</p></blockquote><h1 id="GPT分区格式"><a href="#GPT分区格式" class="headerlink" title="GPT分区格式"></a>GPT分区格式</h1><p>MBR分区格式虽然使用的很多，但是它也有局限。首先硬盘首扇区上的分区表上只有64字节，于是每组记录区只有16字节，可以记录的信息十分有限。通常会有如下问题：</p><ul><li>操作系统无法使用超过2TB(具体没分析)以上的磁盘容量；</li><li>MBR上只有一个区块记录分区信息，被破坏后基本就是坏了；</li><li>MBR内的启动引导程序只有446字节，无法存储较多程序代码。</li></ul><blockquote><p>首先目前其实已经有4k扇区的磁盘出现，但是为了兼容所有的磁盘，大多会使用<strong>逻辑区块地址</strong>(logical block address, LBA)来规划磁盘区块，每个LBA默认512字节。</p></blockquote><p>GPT(GUID partition table)磁盘分区表可以解决MBR的问题。首先，GPT使用磁盘前34个LBA区块(LBA0~LBA33)来记录分区信息，并且将硬盘最后34个LBA区块拿来作为备份。整体结构如下图所示。</p><p><img src="/img/mbr_gpt/gpt.png" alt="gpt"></p><p>其中，上图中的结构解释如下：</p><ul><li>LBA0(MBR兼容区块)</li></ul><p>　　与MBR模式兼容，这个区块的结构基本不变，第一部分是446字节的第一阶段的启动引导程序。而第二部分放的不是分区信息，而是标识符用来表示磁盘使用GPT分区格式。如果是不能读懂GPT分区表格式的磁盘管理程序就不能使用这块磁盘。</p><ul><li><p>LBA1(GPT表头记录)</p><p>  这部分记录了分区表本身的位置与大小，同时记录了备份用的GPT分区放置的位置。同时还有一个用来检测GPT分区表是否正常的校验码，如果检测结果是不正常，便可以获取前面记录的备份用的GPT分区信息使得可以获得正确的分区信息。</p></li><li><p>LBA2~LBA33(实际记录分区信息的地方)</p><p>  这32个区块，每个记录了四组分区信息(512字节)，所以默认一共可以记录128组分区信息，每组分区信息使用128字节存储。这128字节的空间中有除去记录标识符之类的信息外，使用64位来记录分区开始/结束的扇区号码。所以可以寻址的空间是<code>2^64 * 512字节</code>也就是 $ 2^33 $TB的空间。</p></li></ul><h1 id="linux界面分区软件gparted"><a href="#linux界面分区软件gparted" class="headerlink" title="linux界面分区软件gparted"></a>linux界面分区软件gparted</h1><p>启动软件</p><pre><code class="hljs">sudo gparted</code></pre><p>如果没有安装，需要先安装</p><pre><code class="hljs">sudo apt install gparted</code></pre><p>运行后如下界面</p><p><img src="/img/mbr_gpt/gparted.png" alt="gparted"></p><p>这是我虚拟机的分区情况，首先有一个主分区<code>/dev/sda1</code>，挂载在<code>/</code>目录下，与一个扩展分区<code>/dev/sda2</code>，扩展分区只分了一个逻辑分区<code>/dev/sda5</code>作为内存的交换分区。</p><blockquote><p>一般这种图形界面的分区软件都是分区与文件系统初始化同时进行的。十分周到到位，下面讲的命令行分区命令一般都是仅仅进行分区操作（即只对分区表进行填写），文件系统初始化需要专用的命令进行。</p></blockquote><h1 id="分区命令行"><a href="#分区命令行" class="headerlink" title="分区命令行"></a>分区命令行</h1><ul><li><code>lsblk</code>列出计算机硬盘与分区情况 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">xhy@ubuntu:~$ lsblk<br>NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT<br>sr0     11:0    1 1024M  0 rom <br>sda      8:0    0   50G  0 disk <br>├─sda2   8:2    0    1K  0 part <br>├─sda5   8:5    0    2G  0 part <br>└─sda1   8:1    0   48G  0 part /<br></code></pre></td></tr></table></figure></li></ul><hr><ul><li><code>blkid</code>查看一个分区的文件系统，UUId等</li><li>使用<code>parted</code>可以列出磁盘的分区表类型与分区信息（其实它的功能十分强大），也可以使用这个命令来进行磁盘分区操作（两种分区表格式都支持）。</li></ul><p><img src="/img/mbr_gpt/parted-blkid.png" alt="parted-blkid"></p><ul><li>分区操作命令<code>gdisk</code>与<code>fdisk</code>（前一个针对gpt分区表的磁盘，后一个针对mbr分区表的磁盘）</li></ul><h1 id="linux交换分区的设置"><a href="#linux交换分区的设置" class="headerlink" title="linux交换分区的设置"></a>linux交换分区的设置</h1><h2 id="第一种方法：分区挂载"><a href="#第一种方法：分区挂载" class="headerlink" title="第一种方法：分区挂载"></a>第一种方法：分区挂载</h2><ul><li><p>使用上述分区方法得到一个<code>/dev/sda5</code>的分区</p></li><li><p>交换分区一般并没有挂载，可以在觉得内存不足时再进行挂载。如下使用<code>free</code>命令查看内存是否挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">xhy@ubuntu:~$ free<br>              total        used        free      shared  buff/cache   available<br>Mem:        2017308      894012      362524       24756      760772      892696<br>Swap:             0           0           0<br></code></pre></td></tr></table></figure></li></ul><hr><ul><li>如上，显示交换分区并没有挂载，可以使用<code>swapon</code>命令进行挂载<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">xhy@ubuntu:~$ sudo swapon /dev/sda5 <br>[sudo] xhy 的密码： <br>xhy@ubuntu:~$ free<br>              total        used        free      shared  buff/cache   available<br>Mem:        2017308      894712      360908       24756      761688      892008<br>Swap:       2046972           0     2046972<br></code></pre></td></tr></table></figure></li></ul><hr><p>如上，挂载成功。</p><ul><li><p>每一次都手动挂载如果不耐烦，可以设置自动挂载，在文件<code>/etc/fstab</code>最后一行添加<code>/dev/sda5 swap swap defaults 0 0</code>即可。</p></li><li><p>然后先使用<code>swapoff /dev/sda5</code>即可将前面的挂载的交换分区卸载。然后<code>swapon -a</code>执行一下，不用重启即可自动挂载。</p></li><li><p>最后使用<code>swapon -s</code>查看交换分区挂载情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">xhy@ubuntu:~$ swapon -s<br>Filename                Type        Size    Used    Priority<br>/dev/sda5                               partition   2046972 0   -2<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="第二种方法：文件挂载"><a href="#第二种方法：文件挂载" class="headerlink" title="第二种方法：文件挂载"></a>第二种方法：文件挂载</h2><ul><li><p>具体思路</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建16g交换空间文件</span><br>sudo fallocate -l 16G /swapfile<br><span class="hljs-comment"># 修改交换空间文件权限</span><br>sudo <span class="hljs-built_in">chmod</span> 600 /swapfile<br><span class="hljs-comment"># 格式化交换空间文件</span><br>sudo mkswap /swapfile<br><span class="hljs-comment"># 设置开机自动挂载</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/swapfile swap swap defaults 0 0&quot;</span> | sudo <span class="hljs-built_in">tee</span> -a /etc/fstab<br><br></code></pre></td></tr></table></figure></li><li><p>如果fallocate报错<code>fallocate: fallocate failed: Text file busy</code>，表示目前已经有交换空间，并且在使用中，可以通过<code>sudo swapoff -a</code>先关闭交换空间</p></li><li><p>如果不想重启，也可以直接<code>sudo swapon /swapfile</code>直接挂载交换空间文件</p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] 鸟哥的linux私房菜（第四版）</li><li>[2] <a href="https://baike.baidu.com/item/%E6%89%A9%E5%B1%95%E5%88%86%E5%8C%BA">https://baike.baidu.com/item/%E6%89%A9%E5%B1%95%E5%88%86%E5%8C%BA</a></li><li>[3] <a href="https://gparted.org/">https://gparted.org/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像特征之Harris角点检测</title>
    <link href="/2018/12/01/2018-12-01-corner-detect-harris/"/>
    <url>/2018/12/01/2018-12-01-corner-detect-harris/</url>
    
    <content type="html"><![CDATA[<h1 id="1-角点与角点的检测"><a href="#1-角点与角点的检测" class="headerlink" title="1. 角点与角点的检测"></a>1. 角点与角点的检测</h1><h2 id="1-1-什么是角点？"><a href="#1-1-什么是角点？" class="headerlink" title="1.1 什么是角点？"></a>1.1 什么是角点？</h2><p>从图像分析的角度来看，一般而言角点有如下两种定义：</p><ol><li>角点可以是两个边缘的角点；</li><li>角点是邻域内具有两个主方向的特征点；</li></ol><p>如同下图所示，前俩例子一个是平坦区域，一个是边缘。第三个就如上述两种定义方式的角点一样，设置一个滑动窗口，无论朝那个方向移动，对应位置上的亮度都会有很大变化，</p><p><img src="/img/harris/corner.png" alt="harris"></p><h2 id="1-2-不同的角点检测方法"><a href="#1-2-不同的角点检测方法" class="headerlink" title="1.2 不同的角点检测方法"></a>1.2 不同的角点检测方法</h2><p>角点定义出来了以后，如何检测角点呢？这个有好多种方法，比如以前提到的orb特征里的fast关键点的检测方式，就是一种角点检测方法。本文提到的harris也是一种角点检测方法，而且应该是名气很大的一种方法。除此之外，还有一些其他的角点检测方法，比如Shi-Tomasi算法、SUSAN算子等。</p><h1 id="2-harris角点检测"><a href="#2-harris角点检测" class="headerlink" title="2. harris角点检测"></a>2. harris角点检测</h1><h2 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h2><p>由1.1中所述，我们知道在一个角点处设置一个滑动窗口，这个窗口无论朝哪个方向滑动，对应位置上的亮度都会有很大变化。对应如下公式</p><p>$$E(u,v) = \sum _{x,y} w(x,y)[ I(x+u,y+v) - I(x,y)]^{2}$$</p><p>其中：</p><ul><li>w(x,y)是滑动窗口系数，系数越大，代表这个位置上的亮度差异对结果所占权重更大。一般使用二维高斯窗口</li><li>(u,v)是一个确定位移</li><li>I(x,y)是在位置(x,y)的亮度值，(x,y)是在滑动窗口范围内的一个点</li></ul><p>上述公式中，有如下一项存在操作空间</p><p>$$[I(x+u,y+v) - I(x,y)]^{2}$$</p><p>可以泰勒展开<strong>近似</strong>成</p><p>$$ [ I(x,y) + u I_{x} + vI_{y} - I(x,y)]^{2} $$</p><p>消去并展开方程，带入原式得</p><p>$$ E(u,v) \approx \sum_{x,y} w(x,y)(u^{2}I_{x}^{2} + 2uvI_{x}I_{y} + v^{2}I_{y}^{2}) $$</p><p>写成矩阵形式是（可以这样写是因为$(u,v)$仅仅代表一个移动方向，与窗口的大小、系数都不相关）：</p><p>$$ E(u,v) \approx \begin{bmatrix} u &amp; v \end{bmatrix} \left ( \displaystyle \sum_{x,y} w(x,y) \begin{bmatrix} I_x^{2} &amp; I_{x}I_{y} \\ I_xI_{y} &amp; I_{y}^{2} \end{bmatrix} \right ) \begin{bmatrix} u \\ v \end{bmatrix} $$</p><p>可以定义矩阵M为</p><p>$$ M = \displaystyle \sum_{x,y} w(x,y) \begin{bmatrix} I_x^{2} &amp; I_{x}I_{y} \\ I_xI_{y} &amp; I_{y}^{2} \end{bmatrix} $$</p><p>现在式子变成</p><p>$$ E(u,v) \approx \begin{bmatrix} u &amp; v \end{bmatrix} M \begin{bmatrix} u \\ v \end{bmatrix} $$</p><blockquote><p>我们知道，如果是角点的话，无论$(u,v)$往哪个方向，$E(u,v)$的值都会变化很大，而这个性质是由二维矩阵$M$决定的。或者说，这个性质是由矩阵M的特征值与特征向量决定的。在特征值大的特征向量方向，$E(u,v)$的值变化较快，在特征值较小的特征向量方向，$E(u,v)$的值变化较慢</p></blockquote><p>上式如果左值固定，这个式子本质上是一个椭圆，椭圆的扁率与尺寸是由M的特征值$ \lambda_1、\lambda_2 $决定的，椭圆的方向是由M的特征矢量决定的。假设椭圆方程如下</p><p>$$ \begin{bmatrix} u &amp; v \end{bmatrix} M \begin{bmatrix} u \\ v \end{bmatrix} = 1  $$</p><p><img src="/img/harris/eclipse.png" alt="eclipse"></p><p>因此由矩阵M的特征值$ \lambda_1、\lambda_2 $的情况，可以将图像上的一个点分为三种情况：</p><ol><li>图像中<strong>边缘上的点</strong>。一个特征值大，另一个特征值小，即$ \lambda_1\gg \lambda_2 $或$ \lambda_2\gg \lambda_1 $，在窗口朝某一方向滑动时，E的值变化明显，其他方向上不明显。</li><li>图像中<strong>平面上的点</strong>。两个特征值都小，且近似相等。窗口朝各个方向上滑动，E的值变化都不明显。</li><li>图像中<strong>角点</strong>。两个特征值都大，且近似相等。窗口朝每个方向滑动，E的值都会有很明显的变化。</li></ol><p><img src="/img/harris/analyse.png" alt="analyse"></p><p>上述分析过后，我们知道如何使用M矩阵的特征值来判断一个点是边缘点、平面点还是角点。Harris提出可以计算一个harris<strong>角点响应值R</strong>来判断一个点是否是角点，而无需计算具体的矩阵特征值。R的计算公式如下：</p><p>$$ R=det \boldsymbol{M} - \alpha(trace\boldsymbol{M})^2 $$</p><p>其中：</p><ul><li>$det\boldsymbol{M}$是矩阵M的行列式，并且$det\boldsymbol{M} = \lambda_1\lambda_2 = AC-B^2$，A,B,C,D是M矩阵的四个元素</li><li>$trace\boldsymbol{M}$是矩阵M的直迹，并且$trace\boldsymbol{M}=\lambda_2+\lambda_2 = A+C$</li><li>$\alpha$是一个经验系数，通常取值范围在0.04~0.06。下文还会对这个系数进行探讨。</li></ul><p>至于为什么Harris响应值R如此定义，可以由下图知道原因。</p><p><img src="/img/harris/harris.png" alt="harris"></p><h2 id="2-2-实际代码实现步骤"><a href="#2-2-实际代码实现步骤" class="headerlink" title="2.2 实际代码实现步骤"></a>2.2 实际代码实现步骤</h2><p>在上述原理讲解完毕后，代码实现主要可以分为五步：</p><ol><li><p>分别计算像素I(x,y)在x,y方向的梯度，使用<strong>sobel算子</strong>：$$I_x=\frac{\partial I}{\partial x}=I\otimes(-1\ 0\ 1)，I_y =\frac{\partial I}{\partial x}=I\otimes(-1\ 0\ 1)^T$$</p></li><li><p>计算两个方向梯度的乘积：$$ I_x^2=I_x\cdot I_y，I_y^2=I_y\cdot I_y，I_{xy}=I_x\cdot I_y $$</p></li><li><p>生成高斯系数窗口，并最终<strong>确定M矩阵</strong>(前三步都是为了确定矩阵M)。</p></li><li><p>依据M矩阵计算每个像素的<strong>harris响应值R</strong>，并设置一个阈值，小于阈值的清零。</p></li><li><p>在$3\times3或5\times5$的领域内进行<strong>非极大值抑制</strong>，局部最大值点即为图像中的角点。</p></li></ol><blockquote><p><strong>非极大值抑制</strong>原理是，在一个窗口内，如果有多个角点则用值最大的那个角点，其他的角点都删除。这样做可以祛除一些黏在一起的角点，好处是可以防止角点太密集，出现一小撮全是角点的情况。</p></blockquote><h2 id="2-3-harris角点性质"><a href="#2-3-harris角点性质" class="headerlink" title="2.3 harris角点性质"></a>2.3 harris角点性质</h2><h3 id="2-3-1-旋转不变性"><a href="#2-3-1-旋转不变性" class="headerlink" title="2.3.1 旋转不变性"></a>2.3.1 旋转不变性</h3><p>由我们上述讲解的原理可知，当旋转发生时，矩阵M确定的椭圆也会发生旋转，但是椭圆的长短轴的大小是不会变化的。而椭圆的长短轴是<strong>矩阵M的特征值平方根的倒数</strong>，也就是说矩阵的特征值不会发生变化，所以harris响应值的大小也不会发生变化。因此harris角点检测具有旋转不变性。</p><h3 id="2-3-2-光照不敏感"><a href="#2-3-2-光照不敏感" class="headerlink" title="2.3.2 光照不敏感"></a>2.3.2 光照不敏感</h3><p>这是因为我们在进行harris响应值的计算时，并没有直接使用像素亮度信息，而是使用了像素亮度的梯度信息。但由于梯度信息对于像素亮度的拉升与收缩变化并不敏感，就算光照条件发生变化导致像素亮度整体发生变化，也不会影响harris响应值的极值点出现的位置。最多由于阈值的选择，会影响检测到的角点数量而已。</p><p><img src="/img/harris/brightness.png" alt="brightness"></p><h3 id="2-3-3-不具备尺度不变"><a href="#2-3-3-不具备尺度不变" class="headerlink" title="2.3.3 不具备尺度不变"></a>2.3.3 不具备尺度不变</h3><p>这一点同样容易理解，下图解释的尤其形象。</p><p><img src="/img/harris/scale.png" alt="scale"></p><h3 id="2-3-4-参数-alpha-的意义"><a href="#2-3-4-参数-alpha-的意义" class="headerlink" title="2.3.4 参数$\alpha$的意义"></a>2.3.4 参数$\alpha$的意义</h3><p>假设已经得到了矩阵M的特征值$\lambda_1\ge\lambda_2\ge0$，令$\lambda_2=k\lambda_1,0\le k\le 1$。由特征值与矩阵M的直迹和行列式的关系可得：</p><p>$$ det\boldsymbol{M}=\prod_i\lambda_i \ \ \ \ \ \  trace\boldsymbol{M}=\sum_i\lambda_i $$</p><p>所以角点的响应值为</p><p>$$ R=\lambda_2\lambda_2=\alpha(\lambda_2+\lambda_2)^2=\lambda^2(k-\alpha(1+k)^2) $$</p><p>若有R不小于0，则</p><p>$$ 0\le \alpha \le\frac{k}{(1+k)^2}\le0.25 $$</p><p>并且有如下结论：<strong>增大α的值，将减小角点响应值R，降低角点检测的灵性，减少被检测角点的数量；减小α值，将增大角点响应值R，增加角点检测的灵敏性，增加被检测角点的数量。</strong></p><h2 id="2-4-harris角点检测的opencv接口与自己的c-实现"><a href="#2-4-harris角点检测的opencv接口与自己的c-实现" class="headerlink" title="2.4 harris角点检测的opencv接口与自己的c++实现"></a>2.4 harris角点检测的opencv接口与自己的c++实现</h2><p>见我的<a href="https://github.com/xhy3054/myopencv/tree/master/08_feature2d_module/01_harris_corner_detector">github</a></p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>由上面的描述我们知道了什么是角点，harris角点响应值的定义等，<strong>其实角点的定义都是相同的，只是不同的角点检测方法定义了不同的角点响应值的计算方式罢了。上述推导了最出名的harris响应值的定义公式，还有其他的角点响应值，比如Shi-Tomasi角点响应值是矩阵M较小的那个特征值。这种方法不仅充分，而且在很多情况下（比如跟踪）会比harris更加有效。</strong></p><h1 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h1><ul><li>[1] <a href="https://docs.opencv.org/3.4.1/d4/d7d/tutorial_harris_detector.html">https://docs.opencv.org/3.4.1/d4/d7d/tutorial_harris_detector.html</a></li><li>[2] <a href="https://www.cnblogs.com/ronny/p/4009425.html#4056636">https://www.cnblogs.com/ronny/p/4009425.html#4056636</a></li><li>[3] <a href="https://blog.csdn.net/lwzkiller/article/details/54633670">https://blog.csdn.net/lwzkiller/article/details/54633670</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++中关于命名空间中成员的使用</title>
    <link href="/2018/11/07/2018-11-07-cpp-namespace-use/"/>
    <url>/2018/11/07/2018-11-07-cpp-namespace-use/</url>
    
    <content type="html"><![CDATA[<p>使用c++进行开发的我们总会不可避免的使用很多外部的库，这样可以避免自己重复造轮子，大大提高工作效率。但是每个库都会定义大量的全局名字，如类、函数、模板等。如果这些名字都放在全局命名空间中，不可避免的会出现相同的名字，形成<strong>命名冲突。</strong></p><p><strong>命名空间</strong>就是为了防止命名冲突而出现的，每个库都可以拥有自己的命名空间，每个命名空间是一个作用域。然后如何使用一个特定命名空间里的成员，就是本文主要要讲的内容，不过我只挑了一些我认为需要记录下来的，因为有很多常识性的规则实在没有多说的必要。</p><h1 id="using声明"><a href="#using声明" class="headerlink" title="using声明"></a>using声明</h1><p>一条<code>using</code>声明语句一次只引入命名空间的一个成员。例如最常见的<code>using std::cout</code>就是使用using声明将std命名空间中的标准输出对象<code>cout</code>引入<strong>当前作用域</strong>。其实就是在当前作用域声明了有<code>cout</code>这个对象，并且说明它定义在命名空间<code>std</code>里。因此如果当前作用域中已经有一个同名的对象，将会<strong>报错</strong>。</p><p>需要注意的是using声明<strong>引入的是一个名字</strong>，所以在在引入一个<strong>函数</strong>时比较特殊。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">using</span> <span class="hljs-title">ns::print</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<span class="hljs-comment">//错误：只能引入一个名字，不能指定形参列表</span><br><span class="hljs-keyword">using</span> ns::print;<span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure><hr><p>并且在引入一个函数时，会出现如下情况。</p><ol><li>如果using声明出现在局部作用域中，则引入的名字将隐藏外层作用域的相关声明；</li><li>如果using声明所在的作用域中已经有一个函数与新引入的函数同名且形参列表相同，则将引发错误；</li><li>除了上面两种情况，其他同名函数都会进行<strong>重载</strong>，最终扩展候选函数集的规模。</li></ol><h1 id="using指示"><a href="#using指示" class="headerlink" title="using指示"></a>using指示</h1><p><code>using</code>指示是将某个命名空间中的所有内容都变得有效。但是有一点需要注意，那就是using指示是对<strong>最近的外层作用域</strong>有效。如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// namespace A and function f are defined at global scope</span><br><span class="hljs-comment">//定义在全局作用域</span><br><span class="hljs-keyword">namespace</span> A &#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">42</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> A; <span class="hljs-comment">// 把A中的名字注入到全局作用域</span><br><br><span class="hljs-comment">// uses i and j from namespace A</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; j: &quot;</span> &lt;&lt; j &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>并且using指示后在同一作用域出现相同名字的时候，并<strong>不会马上报错</strong>，而是直到使用时出现二义性的代码时才会报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> blip &#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">16</span>, j = <span class="hljs-number">15</span>, k = <span class="hljs-number">23</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; j: &quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot; k: &quot;</span> &lt;&lt; k &lt;&lt; endl; &#125;<br>&#125;<br><br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;  <span class="hljs-comment">// ok: j inside blip is hidden inside a namespace</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// using directive; </span><br><span class="hljs-comment">// the names in blip are ``added&#x27;&#x27; to the global scope</span><br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> blip; <span class="hljs-comment">// clash between ::j and blip::j</span><br>                          <span class="hljs-comment">// detected only if j is used</span><br><br>    ++i;        <span class="hljs-comment">// sets blip::i to 17</span><br>    ++j;        <span class="hljs-comment">//　二义性错误，是全局的j还是blip::j?</span><br>    ++::j;      <span class="hljs-comment">// ok: sets global j to 1</span><br>    ++blip::j;  <span class="hljs-comment">// ok: sets blip::j to 16</span><br><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">97</span>; <span class="hljs-comment">// local k hides blip::k</span><br>    ++k;        <span class="hljs-comment">// sets local k to 98</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，如果使用using指示引入函数与最近的外层作用域重名，会直接被添加到重载集合，即使出现同名且参数列表相同的函数也不会报错，而是知道出现二义性代码才会报错。</p><blockquote><p>通常情况下大家都是在最外层的全局作用域使用using指示，此时没有更外层的作用域了，所以会直接将成员注入到全局作用域。</p></blockquote><h1 id="实参相关与类类型形参的函数查找"><a href="#实参相关与类类型形参的函数查找" class="headerlink" title="实参相关与类类型形参的函数查找"></a>实参相关与类类型形参的函数查找</h1><p>如果不用using指示与using声明，通常我们在使用一个命名空间中的成员时，需要使用作用域限定符<code>::</code>指明出处，但是有一点例外，那就是在使用函数时。</p><ol><li><p>当我们调用一个函数，并且此函数的实参传递一个类类型的对象是，<strong>除了在常规作用域进行函数查找外，还会查找实参类所属的命名空间</strong>（比如<code>std::cout&lt;&lt;&quot;helio&quot;</code>中对于重载的输出运算符函数并没有指定作用域，但是依然找到了，便是根据实参cout）。</p></li><li><p>如果形参是一个基类，传入的实参是该基类的一个派生类，则除了在常规作用域与实参类所属的命名空间中进行函数的查找外，还会在<strong>基类的作用域中</strong>进行该函数的查找。如下：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> NS &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Quote</span> &#123; <br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Quote</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Quote::Quote&quot;</span> &lt;&lt; std::endl; &#125; <br>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">const</span> Quote&amp;)</span> </span><br><span class="hljs-function"></span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;display(const Quote&amp;)&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;<br><br><span class="hljs-comment">// Bulk_item&#x27;s base class is declared in namespace NS</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bulk_item</span> : <span class="hljs-keyword">public</span> NS::Quote &#123; <br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Bulk_item</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Bulk_item::Bulk_item&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Bulk_item book1;<br><br>    <span class="hljs-built_in">display</span>(book1); <span class="hljs-comment">// calls Quote::display</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] C++ Primer（第5版）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c与c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++中的模板实例化问题</title>
    <link href="/2018/11/03/2018-11-03-cpp-template-class/"/>
    <url>/2018/11/03/2018-11-03-cpp-template-class/</url>
    
    <content type="html"><![CDATA[<p>在c++中，模板是非常常见并且好用的。基本每一个c++的库都会使用模板，对自己的适用类型进行扩展。本文主要讲的是模板的实例化问题。</p><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><h2 id="模板实例化"><a href="#模板实例化" class="headerlink" title="模板实例化"></a>模板实例化</h2><p>当模板被使用时才会实例化，这一特性意味着，<strong>相同的实例可能出现在多个对象文件中</strong>。举个例子就是说，当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，<strong>每个文件中都会有该模板适用该参数的一个实例。</strong></p><p>上述的问题在小程序里不算什么，但是在一个大的程序中，在多个文件中实例化相同模板的<strong>额外开销会非常严重</strong>。</p><p>在新标准中，我们可以通过控制<strong>显式实例化</strong>来避免这种开销。</p><h3 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h3><p>与多文件中声明一个变量相同，可以使用关键字<code>extern</code>来承诺在程序其他位置会有一个该实例化的非<code>extern</code>声明，只需要在链接成可执行程序时将含有实例化的<code>.o</code>文件链接上就可以了。<strong>因此使用关键字<code>extern</code>进行一个模板的声明时不会在本文件中生成实例化代码。</strong></p><pre><code class="hljs">extern template declaration;//实例化声明template decaration;//实例化定义</code></pre><h2 id="如下演示一下具体如何操作：在第一个文件中，"><a href="#如下演示一下具体如何操作：在第一个文件中，" class="headerlink" title="如下演示一下具体如何操作：在第一个文件中，"></a>如下演示一下具体如何操作：<br>在第一个文件中，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//templatebuild.cpp</span><br><span class="hljs-comment">//实例化文件必须为每个在其他文件中声明为extern的类型和函数提供一个（非extern）的定义</span><br><span class="hljs-function"><span class="hljs-keyword">template</span> <span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;)</span></span>;<br><span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Blob</span>&lt;string&gt;;<br></code></pre></td></tr></table></figure></h2><h2 id="第二个文件中"><a href="#第二个文件中" class="headerlink" title="第二个文件中"></a>第二个文件中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//application.cpp</span><br><span class="hljs-comment">//这些模板类型必须在其他位置已经进行实例化</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Blob</span>&lt;string&gt;;<span class="hljs-comment">//声明，接下来就可以使用类Blob&lt;string&gt;了</span><br>Blob&lt;string&gt; b1;<span class="hljs-comment">//像一个普通的类一样使用</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">template</span> <span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;)</span></span>;<br><span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> k = <span class="hljs-built_in">compare</span>(i,j);<br></code></pre></td></tr></table></figure></h2><p>在编译时，需要将<code>templatebuild.o</code>与<code>application.o</code>链接到一起，生成可执行文件。</p><h3 id="类模板的实例化定义"><a href="#类模板的实例化定义" class="headerlink" title="类模板的实例化定义"></a>类模板的实例化定义</h3><p>此外，需要说明的一点是，<strong>一个类模板的实例化定义会实例化该模板的所有成员</strong>，包括内联的成员函数。</p><p><strong>默认情况下，一个类模板的成员函数只有当程序用到它是才会进行实例化</strong>。但是一个类模板的实例化定义会实例化该模板的所有成员。这是因为当编译器遇到一个实例化定义时，它不了解程序使用哪些成员函数。因此与处理类模板的普通实例化不同，编译器会实例化该类的所有成员。即使我们不使用某个成员，它也会被实例化。因此，如果我们使用一个类型来显式实例化一个类模板，则这个类型必须能用于模板的所有成员。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] C++ Primer（第5版）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c与c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++中的异常处理</title>
    <link href="/2018/11/03/2018-11-04-cpp-exception/"/>
    <url>/2018/11/03/2018-11-04-cpp-exception/</url>
    
    <content type="html"><![CDATA[<p>c++是一门复杂的语言，程序的运行环境也是千奇百怪。因此总会有异常出现，本文主要就是讨论一下c++程序中的异常处理问题。</p><h2 id="异常对象"><a href="#异常对象" class="headerlink" title="异常对象"></a>异常对象</h2><p>讲到异常，这里就要说明一下，什么是异常？<strong>在c++中，异常就是指异常对象</strong>。而异常对象是异常类的实例化，<strong>异常类是我们定义的用来表示程序错误信息的数据抽象</strong>。下图便是标准库异常类的继承体系。<br><img src="%3C!--swig%EF%BF%BC2--%3E/assets/img/exception/exception.jpg" alt="exception"></p><p>由上图我们可以看到，异常类的继承体系中基类是<code>exception</code>类。整个关系可以看成是按照层次关系组织的，层次越低，表示的异常情况就越特殊。</p><p>一般情况下，每个异常类都定义的有：</p><ol><li>拷贝构造函数；</li><li>拷贝赋值运算符；</li><li>虚析构函数；</li><li>一个名叫<code>what</code>的虚成员函数。没有参数，返回一个<code>const char*</code>的指针指向一个以<code>null</code>结尾的字符数组，并且确保不会抛出任何异常。</li></ol><h2 id="函数try语句块"><a href="#函数try语句块" class="headerlink" title="函数try语句块"></a>函数try语句块</h2><p>一般异常处理部分使用try语句块处理异常，try语句块以关键字try开始，并以一个或多个<strong>catch子句</strong>结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句“处理”异常，所以它们也被称作<strong>异常处理代码</strong>。其一般形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">//program-statements</span><br>&#125;<br><span class="hljs-built_in">catch</span>(exception-declaration)&#123;<br><span class="hljs-comment">//handler-statements</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="抛出异常（throw）"><a href="#抛出异常（throw）" class="headerlink" title="抛出异常（throw）"></a>抛出异常（throw）</h3><p><strong>抛出异常一般指的是抛出一个异常对象</strong>。一般使用如下语句进行异常的抛出。</p><pre><code class="hljs">throw exception1;    //其中，exception1是一个异常对象。</code></pre><p>这样的形式特别像<code>return</code>语句。它们的作用机理也会有些许相似，都提供一个待接收的对象。</p><h3 id="捕获异常（catch）"><a href="#捕获异常（catch）" class="headerlink" title="捕获异常（catch）"></a>捕获异常（catch）</h3><p><strong>捕获异常也是指捕获一个异常对象</strong>。捕获的过程也就是<strong>参数匹配</strong>的过程。一般捕获异常使用如下形式进行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//exception-declaration通常与函数形参的声明形式一样，可以与throw抛出的异常对象进行参数匹配。</span><br><span class="hljs-built_in">catch</span>(exception-declaration)&#123;<br><span class="hljs-comment">//handler-statements</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="异常匹配过程解析"><a href="#异常匹配过程解析" class="headerlink" title="异常匹配过程解析"></a>异常匹配过程解析</h3><p>通常最完美的一个异常处理过程如下：</p><ul><li>如果在一个try语句块内有异常抛出，则检查与该try块关联的catch子句，如果找到了匹配的catch，就使用该catch处理异常。然后执行完这个catch子句后，找到与try块关联的最后一个catch子句之后的点，并从这里继续执行。</li></ul><p>但是一般情况下，并不会如此顺利，往往一个更完整的异常匹配过程如下：</p><ul><li>对于在一个try语句块内有异常抛出，则检查与该try块关联的catch子句，如果找到了匹配的catch，就使用该catch处理异常。否则，如果该try语句嵌套在其他try块中，则继续检查与外层try匹配的catch子句。如果仍然没有找到匹配的catch，则退出当前这个主调函数，如果调用语句也是在一个try语句块内，继续在调用了刚刚退出的这个函数的try代码块中寻找。直到找到与之匹配的catch，并使用该catch处理异常。然后执行完这个catch子句后，找到与这个catch对应的try块关联的最后一个catch子句之后的点，并从这里继续执行。上述过程也叫作<strong>栈展开</strong>。</li></ul><blockquote><p>栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch子句为止；或者也可能一直没找到匹配的catch语句，则退出主函数后查找过程终止。（如果找不到匹配的catch时，程序会调用标准库函数<code>terminate</code>终止程序）</p></blockquote><h3 id="异常捕获中的参数匹配规则"><a href="#异常捕获中的参数匹配规则" class="headerlink" title="异常捕获中的参数匹配规则"></a>异常捕获中的参数匹配规则</h3><p>上文说过，catch语句的捕获与throw语句的抛出异常之间会进行<strong>参数匹配</strong>。匹配规则类似函数的形参与实参的匹配，但是也不是完全相同。</p><p>一般而言要求异常的类型与catch声明的类型是<strong>精确匹配</strong>的，匹配时一般只有如下三种类型转换可用：</p><ol><li>允许从非常量向常量的类型转换，也就是说，一条非常量１对象的throw语句可以匹配一个接受常量引用的catch语句；</li><li>允许从派生类向基类的类型转换；</li><li>数组被转换成指向数组（元素）类型的指针，函数被转换成指向该函数类型的指针。</li></ol><p>除此之外，包括标准算数类型的转换和类类型转换在内，其他所有转换规则都不能在匹配catch的过程中使用。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] C++ Primer（第5版）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c与c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++继承体系中的成员函数调用问题探究</title>
    <link href="/2018/10/28/2018-10-28-cpp-inheritance-virtual-func/"/>
    <url>/2018/10/28/2018-10-28-cpp-inheritance-virtual-func/</url>
    
    <content type="html"><![CDATA[<p>c++中带有继承关系的类在进行成员函数调用时，需要考虑很多问题，是否是虚函数？动态静态类型是否一致？调用形式？本文主要就是对这些问题进行一一剖析。</p><h2 id="动态类型与静态类型"><a href="#动态类型与静态类型" class="headerlink" title="动态类型与静态类型"></a>动态类型与静态类型</h2><p>当我们在继承体系中进行成员函数调用时，一个变量（或表达式）的<strong>静态类型</strong>与其<strong>动态类型</strong>与其息息相关。</p><ul><li>静态类型：一个变量（或表达式）的静态类型在编译时总是已知的，它是变量声明时的类型（或表达式生成的类型）；</li><li>动态类型：是一个变量或表达式表示的内存中的对象的类型，往往直到运行时才可知。</li></ul><blockquote><p>通常如果一个表达式（变量名也是表达式）<strong>不是引用也不是指针，则它的动态类型与静态类型永远一致</strong>。<strong>基类的指针或引用的静态类型可能与其动态类型不一致</strong>。我们都知道一个派生类对象的存储中<strong>基类部分与派生类部分是分开存储的</strong>。并且在我们使用一个派生类对象对一个基类对象进行赋值时，<strong>调用的是等式左边的基类对象的拷贝赋值运算符</strong>，所以参数传入时将一个基类引用绑定到右边的派生类对象上。在拷贝赋值操作中其实是将右边派生类对象的基类部分拷贝给左边的基类对象。本质也就是将派生类部分“切掉”再赋值给基类对象的，也就是说<strong>得到的基类对象就是一个实打实的基类对象。除了数据成员值相同，与原本的派生类对象不再有任何关系</strong>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">derived</span>: <span class="hljs-keyword">public</span> base&#123;&#125;;<br>derived d1;<br>base b1 = d1;<span class="hljs-comment">//静态类型与动态类型都是base</span><br>base *b2 = &amp;d1;<span class="hljs-comment">//静态类型base,动态类型derived</span><br></code></pre></td></tr></table></figure><hr><blockquote><p>对象、指针和引用的<strong>静态类型</strong>决定了我们能够使用哪些成员。就算是虚函数，也是因为这个虚函数本身在静态类型的基类中也存在。</p></blockquote><h2 id="继承体系中的虚函数与非虚函数"><a href="#继承体系中的虚函数与非虚函数" class="headerlink" title="继承体系中的虚函数与非虚函数"></a>继承体系中的虚函数与非虚函数</h2><p>我们都知道面向对象的编程中，<strong>每个类定义了自己的作用域</strong>。当存在继承关系时，<strong>派生类的作用域嵌套在其基类的作用域之内</strong>。如果一个名字在派生类的作用域中无法正确解释，编译器会继续在外层的基类作用域中寻找该名字的定义。因此，派生类往往可以像使用自己的成员一样使用基类的成员。</p><p>和其他作用域一样，派生类也能重定义在其直接或间接基类中的名字，此时<strong>定义在内层作用域的名字将隐藏定义在外层作用域的名字</strong>。如果派生类中定义了与基类中一样名字的函数，则其会直接隐藏基类中的函数，无论它们参数形式是否一致（因为是隐藏不会重载）。</p><blockquote><p>如果想要使用一个被隐藏的基类成员，可以使用作用域运算符<code>::</code>来指定使用。</p></blockquote><p>作用域问题讲完，言归正传，在继承体系中调用普通成员函数与虚函数，区别如下。</p><h3 id="普通成员函数"><a href="#普通成员函数" class="headerlink" title="普通成员函数"></a>普通成员函数</h3><p>在调用一个普通成员函数时，会执行调用对象的<strong>静态类型</strong>对应的版本。</p><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>在调用一个虚函数时，会执行调用对象的<strong>动态类型</strong>对应的版本。这也叫做<strong>动态绑定</strong>。</p><h2 id="继承体系中函数调用的解析过程"><a href="#继承体系中函数调用的解析过程" class="headerlink" title="继承体系中函数调用的解析过程"></a>继承体系中函数调用的解析过程</h2><p>此处来分析一下继承体系中函数调用的解析过程，如<code>p-&gt;mem</code>或<code>obj.mem()</code>的解析过程:</p><ol><li><p>首先确定p(或obj)的<strong>静态类型</strong>。因为我们调用的是一个成员，所以该类型<strong>必然是类类型</strong>。</p></li><li><p>在p（或obj）的静态类型对应的类中<strong>查找mem</strong>（如果是虚函数，要么覆盖要么继承此处就可以找到）。如果找不到，则依次在直接基类中不断查找直到到达继承链的顶端。如果找遍了该类及其基类依然<strong>找不到，则编译器将报错</strong>。</p></li><li><p>一旦找到了mem，就进行<strong>常规的类型检查</strong>以确认调用合法。</p></li><li><p>若调用合法，则编译器将根据<strong>是否是虚函数</strong>而产生不同的代码：</p><ul><li>如果mem是<strong>虚函数且我们是通过引用或指针进行的调用</strong>，则编译器产生的代码将在运行时确定运行<strong>指针（或引用）的动态类型的虚函数版本</strong>。</li><li>反之，如果mem<strong>不是虚函数或者我们是通过对象（非引用、指针）进行的调用</strong>，则编译器将产生一个<strong>常规函数调用</strong>。</li></ul></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] C++ Primer（第5版）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c与c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++中的移动操作与引申的push_back</title>
    <link href="/2018/10/27/2018-10-27-cpp-copy-move/"/>
    <url>/2018/10/27/2018-10-27-cpp-copy-move/</url>
    
    <content type="html"><![CDATA[<p>在此需要强调一点，c++中的移动操作不是指标准库函数<code>move</code>，它仅仅只是一个辅助移动操作顺利进行的标准库函数而已，功能十分单一。</p><h1 id="对象的移动"><a href="#对象的移动" class="headerlink" title="对象的移动"></a>对象的移动</h1><p>本文我们讲的移动是指对象的移动操作，与拷贝操作相对等的一种操作。</p><blockquote><p>一般而言，移动操作的目的是将目标源对象管理的资源直接<strong>移动</strong>到本对象，即本对象接管了原本目标对象管理的资源（而拷贝操作一般只是将资源内容复制了一份），因此移动操作往往比拷贝操作效率更高。不过这也就意味着<strong>源目标对象的资源不再可用</strong>。所以一般情况下这种操作都要确保源目标对象在经历了资源被窃取的情况下依旧可以正常的<strong>生老病死</strong>，即依然可以正常进行赋值、析构等操作。</p></blockquote><p>也是因为上述拷贝与移动操作的差别，有一些特殊的对象（IO类对象、unique_ptr类对象等）<strong>只支持移动操作而不支持拷贝操作</strong>，比如标准输入输出对象cout与cin，这是因为输入/输出缓冲区只有一个，不可能有多个对象都管理它。</p><h2 id="移动构造函数与移动赋值运算符"><a href="#移动构造函数与移动赋值运算符" class="headerlink" title="移动构造函数与移动赋值运算符"></a>移动构造函数与移动赋值运算符</h2><p>相比于移动构造函数与移动赋值运算符，我们更熟悉的可能是拷贝构造函数与拷贝赋值运算符。其实二者函数名完全一样，不一样的是<strong>参数形式从左值引用换成了右值引用</strong>。也因此，一般移动操作都会搭配标准库函数<code>std::move()</code>使用，这个函数负责<strong>显式地将一个左值转换为对应的右值类型</strong>，它<strong>返回的是一个右值类型的值</strong>。关于右值引用与<code>std::move()</code>的使用我在<a href="https://xhy3054.github.io/reference-cpp/">c++中的引用</a>这篇博客中有更系统的提到。</p><p>如下是对一个对象同时定义拷贝与移动操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HasPtr</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HasPtr</span>(<span class="hljs-type">const</span> string &amp;s = <span class="hljs-built_in">string</span>()) : <span class="hljs-built_in">ps</span>(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>(s)) &#123;cout&lt;&lt;<span class="hljs-string">&quot;调用HasPtr()&quot;</span>&lt;&lt;endl;&#125;<br>    <span class="hljs-comment">//拷贝</span><br>    <span class="hljs-built_in">HasPtr</span>(<span class="hljs-type">const</span> HasPtr&amp; hp) :<span class="hljs-built_in">ps</span>(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>(*hp.ps)) &#123;cout&lt;&lt;<span class="hljs-string">&quot;调用HasPtr(HasPtr&amp;)&quot;</span>&lt;&lt;endl;&#125;<br><br>    HasPtr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> HasPtr&amp; hp)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;调用operator=(const HasPtr&amp;)&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">auto</span> new_ptr = <span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>(*hp.ps); <span class="hljs-comment">//防止对自身进行赋值，不能先释放ps指向的内存</span><br>        <span class="hljs-keyword">delete</span> ps;<br>        ps = new_ptr;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//移动</span><br>    <span class="hljs-built_in">HasPtr</span>(HasPtr&amp;&amp; hp) <span class="hljs-keyword">noexcept</span>  <span class="hljs-comment">//移动过程中不应该抛出异常</span><br>    :<span class="hljs-built_in">ps</span>(hp.ps) &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;调用HasPtr(HasPtr&amp;&amp;)&quot;</span>&lt;&lt;endl;<br>        hp.ps = <span class="hljs-literal">nullptr</span>;    <span class="hljs-comment">//这样可以使得hp被移动后依然可以正常析构</span><br>    &#125;<br><br>    HasPtr&amp; <span class="hljs-keyword">operator</span>=(HasPtr&amp;&amp; hp) <span class="hljs-keyword">noexcept</span>    <br>    &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;调用operator=(HasPtr&amp;&amp;)&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-comment">//直接检测自赋值</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;hp)&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;不是自赋值&quot;</span>&lt;&lt;endl;<br>            ps = hp.ps;                 <br>            hp.ps = <span class="hljs-literal">nullptr</span>;    <span class="hljs-comment">//使得hp可以正常析构</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">HasPtr</span>()&#123;<span class="hljs-keyword">delete</span> ps;&#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::string *ps;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    HasPtr a;<br>    <span class="hljs-function">HasPtr <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>;<br>    <span class="hljs-function">HasPtr <span class="hljs-title">c</span><span class="hljs-params">(std::move(a))</span></span>;<br>    b = std::<span class="hljs-built_in">move</span>(b);<br>    a = std::<span class="hljs-built_in">move</span>(c);<br>    <span class="hljs-comment">//HasPtr d(a);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>如上代码输出结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">xhy@ubuntu:~/cpp_learn/move$ ./move_copy <br>调用HasPtr()<br>调用HasPtr(HasPtr&amp;)<br>调用HasPtr(HasPtr&amp;&amp;)<br>调用operator=(HasPtr&amp;&amp;)　<br>调用operator=(HasPtr&amp;&amp;)　<br>不是自赋值　<br></code></pre></td></tr></table></figure><hr><p>我们会发现我们<strong>将移动操作声明成<code>noexcept</code></strong>，这个是因为移动操作通常只是<strong>窃取</strong>资源，本身并不分配资源，所以通常不会抛出任何异常。我们提前告诉编译器，可以使编译器可能会为了检测异常做一些额外的工作。</p><p>同时移动操作需要<strong>使得自己的参数对象（源目标对象）在被窃取了资源后依然可以正常赋值、析构</strong>。这个操作必须是移动操作来完成，<code>std::move()</code>函数只是返回一个右值来表示源对象。使得移动操作可以顺利进行。</p><h2 id="合成的移动操作"><a href="#合成的移动操作" class="headerlink" title="合成的移动操作"></a>合成的移动操作</h2><p>与拷贝操作相同，默认情况下，编译器也会<strong>自动生成移动操作</strong>。但是与默认生成拷贝操作的规则大不相同。</p><blockquote><p>通常只有在一个类<strong>没有定义任何自己版本的拷贝控制成员</strong>(包括拷贝构造、拷贝赋值、析构三种，并且将这些成员中的某个定义成删除的也算是定义了自己版本的拷贝控制成员)的情况下，并且此类中的<strong>所有数据成员都支持移动操作</strong>时，编译器才会自动合成移动操作。</p></blockquote><h2 id="如果没有移动操作，右值也可以被拷贝"><a href="#如果没有移动操作，右值也可以被拷贝" class="headerlink" title="如果没有移动操作，右值也可以被拷贝"></a>如果没有移动操作，右值也可以被拷贝</h2><p>上文中已经提过，也是因为上述拷贝与移动操作的差别，有一些特殊的对象（IO类对象、unique_ptr类对象等）<strong>只支持移动操作而不支持拷贝操作</strong>，比如标准输入输出对象cout与cin，这是因为输入/输出缓冲区只有一个，不可能有多个对象都管理它。此种情况下，在调用移动操作时<strong>必须传入右值，传入左值将会报错</strong>。 </p><p>同时，更常见的情况是一个类<strong>只支持拷贝操作，不支持移动操作</strong>，此时，<strong>传入右值依旧可以完成拷贝操作</strong>。</p><blockquote><p><strong>原因</strong>很好理解，我们在定义拷贝操作时，因为不会对源目标对象做更改，所以常将参数声明成<code>const &amp;</code>的类型，而这种类型是可以绑定到一个右值上的。而右值引用不能绑定到一个左值上。</p></blockquote><h2 id="push-back与emplace-back"><a href="#push-back与emplace-back" class="headerlink" title="push_back与emplace_back"></a>push_back与emplace_back</h2><p>c++11新加入了emplace_back函数，push_back与emplace_back都是在容器的末尾添加一个元素。</p><ul><li>push_back的做法是先构造一个临时对象，然后将临时对象拷贝到容器末尾，然后释放原本的临时对象。因此其需要调用调用一次构造函数与一次拷贝构造函数或者移动构造函数；</li><li>emplace_back的做法是直接在容器末尾进行对象的构造，因此只需要一次构造函数即可。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] C++ Primer（第5版）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c与c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++中public、protected与private关键字</title>
    <link href="/2018/10/25/2018-10-25-cpp-public-protected-private/"/>
    <url>/2018/10/25/2018-10-25-cpp-public-protected-private/</url>
    
    <content type="html"><![CDATA[<p>不用说，这三个关键字大家都很熟悉，今天我主要是重新温习一遍，理清一遍。</p><h1 id="访问权限关键字（无继承关系时）"><a href="#访问权限关键字（无继承关系时）" class="headerlink" title="访问权限关键字（无继承关系时）"></a>访问权限关键字（无继承关系时）</h1><ul><li><p>public: 这个关键字代表对外界开放，用户可以通过一个对象直接进行其<code>public</code>成员的访问操作；</p></li><li><p>protected: 这个关键字代表只对自己的派生类开放，对与普通用户不开放；</p></li><li><p>private: 这个关键字代表只对自己内部的成员（或友元）开放，对其他任何外在用户（包括派生类对象）都不开放。</p></li></ul><h1 id="派生类继承来的基类部分的成员的访问权限说明"><a href="#派生类继承来的基类部分的成员的访问权限说明" class="headerlink" title="派生类继承来的基类部分的成员的访问权限说明"></a>派生类继承来的基类部分的成员的访问权限说明</h1><p>派生类继承来的基类部分的成员的访问权限受到两个因素影响：</p><ol><li>在基类中该成员的访问说明符；</li><li>在派生类的派生列表中的访问说明符。</li></ol><p>然后关于派生类继承来的成员的权限可以分为以下两方面来讨论。</p><h2 id="派生类对自己继承的基类部分的成员的访问权限解析"><a href="#派生类对自己继承的基类部分的成员的访问权限解析" class="headerlink" title="派生类对自己继承的基类部分的成员的访问权限解析"></a>派生类对自己继承的基类部分的成员的访问权限解析</h2><p><strong>派生类</strong>对其继承而来的<strong>基类部分的成员</strong>的访问权限只受到１个因素影响：<strong>在基类中该成员的访问说明符</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//下列两个关键字，第一个代表基类中成员的访问说明符；第二个代表派生类派生列表中的访问说明符</span><br><span class="hljs-keyword">public</span> + <span class="hljs-keyword">public</span>:    可以访问<br><span class="hljs-keyword">public</span> + <span class="hljs-keyword">protected</span>: 可以访问<br><span class="hljs-keyword">public</span> + <span class="hljs-keyword">private</span>:   可以访问<br><span class="hljs-keyword">protected</span> + <span class="hljs-keyword">public</span>: 可以访问<br><span class="hljs-keyword">protected</span> + <span class="hljs-keyword">protected</span>:  可以访问<br><span class="hljs-keyword">protected</span> + <span class="hljs-keyword">private</span>:    可以访问<br><span class="hljs-keyword">private</span> + <span class="hljs-keyword">public</span>:   不可访问<br><span class="hljs-keyword">private</span> + <span class="hljs-keyword">protected</span>:    不可访问<br><span class="hljs-keyword">private</span> + <span class="hljs-keyword">private</span>:  不可访问<br></code></pre></td></tr></table></figure><hr><p>由上，只有基类中成员的访问说明符起作用了，派生访问说明符并没有起作用。</p><h2 id="派生访问说明符的作用"><a href="#派生访问说明符的作用" class="headerlink" title="派生访问说明符的作用"></a>派生访问说明符的作用</h2><p>派生访问说明符的<strong>作用</strong>是控制派生类用户（包括派生类的派生类在内）对于这部分基类成员的访问权限。</p><p>所以对于<strong>一个派生类的用户</strong>（包括派生类的派生类在内），其对于此派生类中的<strong>基类部分的成员</strong>的访问权限就是由两个因素决定的了。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//下列两个关键字，第一个代表基类中成员的访问说明符；第二个代表派生类派生列表中的访问说明符</span><br><span class="hljs-keyword">public</span> + <span class="hljs-keyword">public</span>:    可以访问<br><span class="hljs-keyword">public</span> + <span class="hljs-keyword">protected</span>: 派生类的派生类用户可以访问，派生类的其他用户不可访问<br><span class="hljs-keyword">public</span> + <span class="hljs-keyword">private</span>:   不可访问<br><span class="hljs-keyword">protected</span> + <span class="hljs-keyword">public</span>: 派生类的派生类用户可以访问，派生类的其他用户不可访问<br><span class="hljs-keyword">protected</span> + <span class="hljs-keyword">protected</span>:  派生类的派生类用户可以访问，派生类的其他用户不可访问<br><span class="hljs-keyword">protected</span> + <span class="hljs-keyword">private</span>:    不可访问<br><span class="hljs-keyword">private</span> + <span class="hljs-keyword">public</span>:   不可访问<br><span class="hljs-keyword">private</span> + <span class="hljs-keyword">protected</span>:    不可访问<br><span class="hljs-keyword">private</span> + <span class="hljs-keyword">private</span>:  不可访问<br></code></pre></td></tr></table></figure><hr><blockquote><p>同样，还有一点，我们会看到有将派生类向基类类型转换的代码，这个也是有条件的。条件就是，如果对当前代码基类部分的公有成员是可访问的，则派生类向基类的类型转换也是可访问的。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] C++ Primer（第5版）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c与c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++智能指针－－unique_ptr</title>
    <link href="/2018/10/20/2018-10-20-cpp-unique-ptr/"/>
    <url>/2018/10/20/2018-10-20-cpp-unique-ptr/</url>
    
    <content type="html"><![CDATA[<p>众所周知，c语言与c++需要自行管理动态的内存。许多代码写到最后，防止内存泄漏需要花费程序员大量的心力。在c++11标准中，提出了智能指针来帮助程序员<strong>管理动态内存</strong>(如果使用智能指针来管理栈上的内存，则在最后析构阶段释放内存时会出现错误)。智能指针主要有三种，分别是<code>shared_ptr</code>、<code>unique_ptr</code>与<code>weak_ptr</code>。本文主要讲的就是<code>unique_ptr</code>使用中的问题。</p><h1 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h1><p>与<code>shared_ptr</code>不同，某个时刻只能有一个<code>unique_ptr</code>指向其管理的动态内存上的对象。当这个<code>unique_ptr</code>销毁时，它所指向的对象也会被销毁。</p><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> std &#123;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> D = default_delete&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> unique_ptr<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">explicit</span> <span class="hljs-built_in">unique_ptr</span>(pointer p) <span class="hljs-keyword">noexcept</span>;<br>~<span class="hljs-built_in">unique_ptr</span>() <span class="hljs-keyword">noexcept</span>;    <br>T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span>;<br>T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span>;<br><span class="hljs-built_in">unique_ptr</span>(<span class="hljs-type">const</span> unique_ptr &amp;) = <span class="hljs-keyword">delete</span>;<br>unique_ptr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> unique_ptr &amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-built_in">unique_ptr</span>(unique_ptr &amp;&amp;) <span class="hljs-keyword">noexcept</span>;<span class="hljs-comment">//右值引用</span><br>unique_ptr&amp; <span class="hljs-keyword">operator</span>=(unique_ptr &amp;&amp;) <span class="hljs-keyword">noexcept</span>;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">private</span>:<br>pointer __ptr;<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>由上源代码我们可以了解到：</p><ol><li><p><code>unique_ptr</code>内部存储一个内置指针，当<code>unique_ptr</code>析构时，它的析构函数将会负责析构它持有的对象。</p></li><li><p><code>unique_ptr</code>提供了<code>operator*()</code>和<code>operator-&gt;()</code>成员函数，像内置指针一样，我们可以使用 * <strong>解引用</strong>unique_ptr，使用 -&gt; 来<strong>访问</strong>unique_ptr所持有对象的成员。</p></li><li><p><code>unique_ptr</code>并不提供 <strong>copy</strong> 操作，这是为了防止多个<code>unique_ptr</code>指向同一对象。</p></li><li><p>但<code>unique_ptr</code>提供了 <strong>move</strong> 操作，因此我们可以用<code>std::move()</code>来转移unique_ptr。</p></li><li><p>两种构造函数，一种传入内置指针，一种传入<code>unique_ptr</code>的右值。第一种是<code>explicit</code>的，第二种不是（所以在函数传参时，赋值时～）。</p></li></ol><h3 id="构造选择"><a href="#构造选择" class="headerlink" title="构造选择"></a>构造选择</h3><p>与<code>shared_ptr</code>不同，并没有类似<code>make_shared()</code>的标准库函数返回一个<code>unique_ptr</code>。当我们定义一个unique_ptr时，<strong>只能使用直接初始化</strong>，参数是<strong>一个指向动态内存的内置指针或者一个<code>unique_ptr</code>类型的右值引用（通过 move 获得）</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;hello~&quot;</span>))</span></span>;<br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(std::move(p1))</span></span>;<span class="hljs-comment">//p1管理的动态内存转移到p2，p1可以正常释放，但不再可用</span><br></code></pre></td></tr></table></figure><h3 id="销毁操作"><a href="#销毁操作" class="headerlink" title="销毁操作"></a>销毁操作</h3><p>缺省情况下，<code>unique_ptr</code>会使用<code>delete</code>析构对象，试用于new申请的动态内存。如果不适用，我们可以使用自定义的 deleter。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Widget</span>&#123;  &#125;;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">auto</span> deleter = []( Widget *p ) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;delete Widget!&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span> p;<br>&#125;;<br>unique_ptr&lt;Widget, <span class="hljs-keyword">decltype</span>(deleter)&gt; ptr&#123; <span class="hljs-keyword">new</span> Widget, deleter &#125;;<span class="hljs-comment">//注意！此处模板需要指定删除器的类型，这一点与shared_ptr不同</span><br></code></pre></td></tr></table></figure><hr><p>我们发现，此处模板<strong>需要指定删除器的类型</strong>，这一点与shared_ptr不同。当然，我们可以使用 C++11 的 alias template 特性，这样就可以避免指定 deleter 的类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Widget</span>&#123;  &#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> uniquePtr = unique_ptr&lt;T, <span class="hljs-built_in">void</span>(*)(T*)&gt;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">uniquePtr&lt;Widget&gt; <span class="hljs-title">ptr</span><span class="hljs-params">( <span class="hljs-keyword">new</span> Widget, </span></span><br><span class="hljs-params"><span class="hljs-function">                           []( Widget *p ) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                               cout &lt;&lt; <span class="hljs-string">&quot;delete Widget!&quot;</span> &lt;&lt; endl;</span></span><br><span class="hljs-params"><span class="hljs-function">                               <span class="hljs-keyword">delete</span> p;</span></span><br><span class="hljs-params"><span class="hljs-function">                           &#125;)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>除此之外，<code>unique_ptr</code>为数组提供了<strong>模板偏特化</strong>，因此unique_ptr也可以指向数组，下为<code>unique_ptr</code>源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> std &#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> D&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_ptr</span>&lt;T[], D&gt;<br>    &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">// ...</span><br>        T&amp; <span class="hljs-keyword">operator</span>[]( <span class="hljs-type">size_t</span> i ) <span class="hljs-type">const</span>;<br>    &#125;;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">default_delete</span>&lt;T[]&gt;<br>    &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">( T *p )</span> <span class="hljs-type">const</span></span>;    <span class="hljs-comment">// call delete[] p</span><br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>当<code>unique_ptr</code>指向数组时，可以使用<code>[]</code>来访问数组元素。default_delete也为数组提供模板偏特化，因此当unique_ptr被销毁时，会调用<code>delete []</code>释放数组内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unique_ptr&lt;string[]&gt; ptr&#123; <span class="hljs-keyword">new</span> string[<span class="hljs-number">100</span>] &#125;;<br>ptr[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br>ptr[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;world&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="使用unique-ptr的坑－－需要注意的问题1"><a href="#使用unique-ptr的坑－－需要注意的问题1" class="headerlink" title="使用unique_ptr的坑－－需要注意的问题1"></a>使用unique_ptr的坑－－需要注意的问题1</h3><p><code>unique_ptr</code>是用来独占地持有对象的，所以通过同一原生指针来初始化多个<code>unique_ptr</code>，下面是一种错误的使用方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Widget</span>&#123;  &#125;;<br>Widget *ptr = <span class="hljs-keyword">new</span> Widget;<br>unique_ptr&lt;Widget&gt; p1&#123; ptr &#125;;<br>unique_ptr&lt;Widget&gt; p2&#123; ptr &#125;;     <span class="hljs-comment">// ERROR: multiple ownership</span><br></code></pre></td></tr></table></figure><hr><p>当p1和p2各自被销毁的时候，它们指向的Widget将被delete两次。</p><h3 id="使用unique-ptr的坑－－需要注意的问题2"><a href="#使用unique-ptr的坑－－需要注意的问题2" class="headerlink" title="使用unique_ptr的坑－－需要注意的问题2"></a>使用unique_ptr的坑－－需要注意的问题2</h3><p>不能拷贝或赋值一个<code>unique_ptr</code>，但是可以拷贝或赋值一个<strong>将要被销毁</strong>的<code>unique_ptr</code>。最常见的例子是从函数返回一个<code>unique_ptr</code>，还有在函数实参中构造<code>unique_ptr</code>。在这种情况下，编译器知道这个对象将要销毁，将会执行一种特殊的“拷贝”（其实是<strong>移动操作</strong>）。</p><h3 id="使用unique-ptr的坑－－需要注意的问题2-1"><a href="#使用unique-ptr的坑－－需要注意的问题2-1" class="headerlink" title="使用unique_ptr的坑－－需要注意的问题2"></a>使用unique_ptr的坑－－需要注意的问题2</h3><p>使用<code>unique_ptr</code><strong>并不能绝对地保证异常安全</strong>，你可能很惊讶于这个结论。让我们看看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">func</span>(unique_ptr&lt;T&gt;&#123; <span class="hljs-keyword">new</span> T &#125;, <span class="hljs-built_in">func_throw_exception</span>());<br></code></pre></td></tr></table></figure><hr><p>C++ 标准并没有规定编译器对函数参数的求值次序，所以有可能出现这样的次序：</p><ol><li>调用<code>new T</code>分配动态内存。</li><li>调用<code>func_throw_exception()</code>函数。</li><li>调用<code>unique_ptr</code>的构造函数。</li></ol><p>调用<code>func_throw_exception()</code>函数会抛出异常，所以无法构造<code>unique_ptr</code>，导致<code>new T</code>所分配的内存不能回收，造成了内存泄露。解决这个问题，最好有一个<code>make_unique</code>函数（原子操作）。但是c++11标准库中并没有提供。好消息是c++14中提供了。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] C++ Primer（第5版）</li><li>[2] <a href="http://senlinzhan.github.io/2015/04/20/%E8%B0%88%E8%B0%88C-%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">http://senlinzhan.github.io/2015/04/20/%E8%B0%88%E8%B0%88C-%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c与c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++中const与constexpr关键字</title>
    <link href="/2018/10/20/2018-10-21-cpp-const-constexpr/"/>
    <url>/2018/10/20/2018-10-21-cpp-const-constexpr/</url>
    
    <content type="html"><![CDATA[<p>本文主要讨论const变量与constexpr变量的初始化时刻与constexpr函数的编译期计算问题。<a href="http://senlinzhan.github.io/2015/05/01/%E8%B0%88%E8%B0%88C-%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%E8%AE%A1%E7%AE%97/">转载</a></p><h1 id="const变量的初始化时刻"><a href="#const变量的初始化时刻" class="headerlink" title="const变量的初始化时刻"></a>const变量的初始化时刻</h1><p><code>const</code>修饰变量，表示这个变量是不可修改的，因此const变量必须初始化，一经初始化就不可修改。</p><ol><li><p>如果const变量的初始化值是在编译时就可以确定，则在编译时初始化；</p></li><li><p>如果const变量的初始化值是在运行时才确定，则在运行时初始化；</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><hr><p>由于SIZE的值是在编译时就已经确定的，编译器会使用常量 100 来替代程序中出现的SIZE。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> i = v.<span class="hljs-built_in">size</span>();<br></code></pre></td></tr></table></figure><hr><p>运行时初始化。</p><h1 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h1><h2 id="constexpr函数的编译期计算"><a href="#constexpr函数的编译期计算" class="headerlink" title="constexpr函数的编译期计算"></a>constexpr函数的编译期计算</h2><blockquote><p>constexpr函数则与编译期计算有关，要是constexpr函数所使用的变量其值能够在编译时就确定，那么constexpr函数就能在编译时执行计算。另一方面，要是constexpr函数所使用的变量其值只能在运行时确定，那么constexpr就和一般的函数没区别。</p></blockquote><p>C++11 要求constexpr函数不能多于一条语句，但是碰到 if-else 语句时，但可以巧妙地使用条件操作符来替代：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">fib</span><span class="hljs-params">( <span class="hljs-type">unsigned</span> n )</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ( n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span> ? n : <span class="hljs-built_in">fib</span>( n - <span class="hljs-number">1</span> ) + <span class="hljs-built_in">fib</span>( n - <span class="hljs-number">2</span> ) );<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>C++14 中则放松了这个要求：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">fib</span><span class="hljs-params">( <span class="hljs-type">unsigned</span> n )</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span> )<br>    &#123;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">fib</span>( n - <span class="hljs-number">1</span> ) + <span class="hljs-built_in">fib</span>( n - <span class="hljs-number">2</span> );   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>要是我们传递一个编译时常量给fib()，那么fib()在程序编译的时候就已经执行好了。代价是增加编译时间，但程序能执行得更高效。</p><h2 id="constexpr变量"><a href="#constexpr变量" class="headerlink" title="constexpr变量"></a>constexpr变量</h2><p>const变量的值可以在编译时或运行时确定，与const相比，constexpr的限制更多，因为<strong>constexpr变量的值必须在编译时就能确定</strong>。</p><p>在一些场合之下，变量的值要求是编译期就必须确定的，constexpr变量正好满足要求。比如数组的大小、<code>std::array</code>的大小、<code>std::bitset</code>的大小等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> SIZE = <span class="hljs-number">100</span>;<br>std::array&lt;<span class="hljs-type">int</span>, SIZE&gt; arr;<br></code></pre></td></tr></table></figure><hr><p>定义constexpr变量的时候，变量的类型<strong>只能是基本数据类型</strong>、指针和引用，而不能是其它标准库类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// error: constexpr variable cannot have non-literal type</span><br><span class="hljs-keyword">constexpr</span> string str = <span class="hljs-string">&quot;hello&quot;</span>;<br></code></pre></td></tr></table></figure><hr><p>不过，对于我们自己定义的类型没有这个限制，因为 constructor 和成员函数可以是constexpr函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">Point</span><span class="hljs-params">( <span class="hljs-type">double</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> y = <span class="hljs-number">0</span> )</span></span><br><span class="hljs-function">        : x_( x ), y_( y )</span><br><span class="hljs-function">    &#123;</span>  &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> <span class="hljs-title">x</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123;  <span class="hljs-keyword">return</span> x_;  &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> <span class="hljs-title">y</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123;  <span class="hljs-keyword">return</span> y_;  &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_x</span><span class="hljs-params">( <span class="hljs-type">double</span> x )</span> <span class="hljs-keyword">noexcept</span> </span>&#123;  x_ = x;  &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_y</span><span class="hljs-params">( <span class="hljs-type">double</span> y )</span> <span class="hljs-keyword">noexcept</span> </span>&#123;  y_ = y;  &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> x_, y_;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><p>要是我们使用编译期常量来初始化Point对象，那么，在编译的时候编译器就已经创建了这个对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> Point <span class="hljs-title">pt</span><span class="hljs-params">( <span class="hljs-number">10</span>, <span class="hljs-number">20</span> )</span></span>;     <span class="hljs-comment">// Evaluate at compiling time</span><br></code></pre></td></tr></table></figure><hr><p>在 C++11 中，constexpr函数隐式地是const函数，所以你会发现set_x()和set_y()这两个函数不能是constexpr函数。</p><p>但在 C++14 中，这个限制放宽了，也就是说这两个函数可以声明为constexpr函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">void</span> <span class="hljs-title">set_x</span><span class="hljs-params">( <span class="hljs-type">double</span> x )</span> <span class="hljs-keyword">noexcept</span> </span>&#123;  x_ = x;  &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">void</span> <span class="hljs-title">set_y</span><span class="hljs-params">( <span class="hljs-type">double</span> y )</span> <span class="hljs-keyword">noexcept</span> </span>&#123;  y_ = y;  &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] C++ Primer（第5版）</li><li>[2] <a href="http://senlinzhan.github.io/2015/05/01/%E8%B0%88%E8%B0%88C-%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%E8%AE%A1%E7%AE%97/">http://senlinzhan.github.io/2015/05/01/%E8%B0%88%E8%B0%88C-%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%E8%AE%A1%E7%AE%97/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c与c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++智能指针－－shared_ptr</title>
    <link href="/2018/10/18/2018-10-18-cpp-shared-ptr/"/>
    <url>/2018/10/18/2018-10-18-cpp-shared-ptr/</url>
    
    <content type="html"><![CDATA[<p>众所周知，c语言与c++需要自行管理动态的内存。许多代码写到最后，防止内存泄漏需要花费程序员大量的心力。在c++11标准中，提出了智能指针来帮助程序员<strong>管理动态内存</strong>。智能指针主要有三种，分别是<code>shared_ptr</code>、<code>unique_ptr</code>与<code>weak_ptr</code>。本文主要讲的就是<code>shared_ptr</code>使用中的问题。</p><h1 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h1><p>首先需要说明的是，<code>shared_ptr</code>是一个<strong>模板类</strong>。为了让用户可以像使用内置指针一样使用它，这个类的设计者为<strong>它重载了解应用运算符<code>*</code>、成员访问运算符<code>-&gt;</code>、赋值运算符<code>=</code>还有向bool类型的显式类型转换</strong>等。</p><p>我们都知道，在使用<code>new</code>动态申请一块内存ａ后会返回一个指向这片内存的指针，对这个指针值进行拷贝赋值等操作，最后会出现很多个指针都指向ａ。但是通过指针释放ａ只能释放一次，如果释放了多次，就会出现错误。以前，大都是通过自己创建一种<strong>引用计数机制</strong>来管理这样的情况。</p><p>在c++11中，标准库提供了一种<code>shared_ptr</code>智能指针类型。一个动态分配的对象可以在多个<code>shared_ptr</code>之间共享，因此，<code>shared_ptr</code>支持拷贝操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">shared_ptr&lt;string&gt; ptr1&#123; <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;hello&quot;</span>) &#125;;<br><span class="hljs-keyword">auto</span> ptr2 = ptr1;<span class="hljs-comment">//拷贝构造，ptr1与ptr2指向同一块动态内存（一个string对象）</span><br></code></pre></td></tr></table></figure><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p><code>shared_ptr</code>内部包含两个指针，一个指向对象，另一个指向控制块(control block)，控制块中包含一个引用计数和其它一些数据。由于这个控制块需要在多个shared_ptr之间共享，所以它也是存在于<code>heap</code>中的。<code>shared_ptr</code>对象本身是线程安全的，也就是说<code>shared_ptr</code>的引用计数增加和减少的操作都是原子的。</p><p>![sh2](&#x2F;assets&#x2F;img&#x2F;shared_ptr&#x2F;sh2.png)</p><h3 id="构造选择"><a href="#构造选择" class="headerlink" title="构造选择"></a>构造选择</h3><p>在初始化<code>ptr</code>时一般有两种选择，分别是<code>new</code>与<code>make_shared</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">shared_ptr&lt;std::string&gt; ptr&#123; <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;hello&quot;</span>) &#125;;<br><span class="hljs-keyword">auto</span> ptr = std::<span class="hljs-built_in">make_shared</span>&lt;std::string&gt;(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure><hr><p>推荐使用第二种。因为第一种方式创建<code>shared_ptr</code>时，需要执行两次new操作，一次在 heap 上为 string(“hello”) 分配内存，另一次在 heap 上为控制块分配内存。使用<code>make_shared</code>来创建<code>shared_ptr</code>会高效，因为<code>make_shared</code>仅使用new操作一次，它的做法是在 heap 上分配一块连续的内存用来容纳 string(“hello”) 和控制块。同样，当<code>shared_ptr</code>被析构时，也只需一次<code>delete</code>操作。</p><h3 id="销毁操作"><a href="#销毁操作" class="headerlink" title="销毁操作"></a>销毁操作</h3><p>一般情况下不需要考虑所指对象的销毁问题，只在指向数组时，与<code>unique_ptr</code>不同，标准库并不提供<code>shared_ptr&lt;T[]&gt;</code>，因此，使用<code>shared_ptr</code>处理数组时需要显示指定删除行为，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">shared_ptr&lt;string&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">( <span class="hljs-keyword">new</span> string[<span class="hljs-number">10</span>], </span></span><br><span class="hljs-params"><span class="hljs-function">                         []( string *p ) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-keyword">delete</span>[] p;</span></span><br><span class="hljs-params"><span class="hljs-function">                         &#125;)</span></span>;<br><span class="hljs-function">shared_ptr&lt;string&gt; <span class="hljs-title">ptr2</span><span class="hljs-params">( <span class="hljs-keyword">new</span> string[<span class="hljs-number">10</span>],</span></span><br><span class="hljs-params"><span class="hljs-function">                         std::default_delete&lt;string[]&gt;() )</span></span>;<br></code></pre></td></tr></table></figure><hr><blockquote><p>此处需要说明的还有，一般智能指针管理的资源都是new分配的内存（即默认使用delete进行销毁操作），如果不是，比如说是其他方式申请的动态内存或者申请的不是动态内存等，请记住传递给它一个删除器来订制销毁操作。</p></blockquote><h3 id="使用shared-ptr的坑－－需要注意的问题１"><a href="#使用shared-ptr的坑－－需要注意的问题１" class="headerlink" title="使用shared_ptr的坑－－需要注意的问题１"></a>使用shared_ptr的坑－－需要注意的问题１</h3><p>用同一个内置指针初始化<code>shared_ptr</code>的操作只能出现一次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;<span class="hljs-number">10</span>&#125;;<br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr1&#123; p &#125;;<br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr2&#123; p &#125;;         <span class="hljs-comment">// ERROR</span><br></code></pre></td></tr></table></figure><p>很明显，每次通过内置指针来构造<code>shared_ptr</code>时候就会分配一个控制块，这时存在两个控制块，也就是说存在两个引用计数。这显然是错误的，因为当这两个<code>shared_ptr</code>被销毁时，对象将会被delete两次。</p><h3 id="使用shared-ptr的坑－－需要注意的问题２"><a href="#使用shared-ptr的坑－－需要注意的问题２" class="headerlink" title="使用shared_ptr的坑－－需要注意的问题２"></a>使用shared_ptr的坑－－需要注意的问题２</h3><p>在对象之间出现<strong>循环引用</strong>时，会使得共享指针引用计数不会降到０，也就不能销毁。循环引用示意图如下：</p><p>![am](&#x2F;assets&#x2F;img&#x2F;shared_ptr&#x2F;am.png)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> std::shared_ptr;<br><span class="hljs-keyword">using</span> std::make_shared;<br><span class="hljs-comment">// 一段内存泄露的代码</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Son</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Father</span>&#123;<br>    shared_ptr&lt;Son&gt; son_;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Son</span>&#123;<br>    shared_ptr&lt;Father&gt; father_;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> father = <span class="hljs-built_in">make_shared</span>&lt;Father&gt;();<br>    <span class="hljs-keyword">auto</span> son = <span class="hljs-built_in">make_shared</span>&lt;Son&gt;();<br>    father-&gt;son_ = son;<br>    son-&gt;father_ = father;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;one father&#x27;s son:&quot;</span>&lt;&lt;father.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;  <br>    std::cout&lt;&lt;<span class="hljs-string">&quot;one son&#x27;s father:&quot;</span>&lt;&lt;son.<span class="hljs-built_in">use_count</span>()&lt;&lt;std::endl;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>编译运行结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">xhy@ubuntu:~/cpp_learn/share_ptr$ ./test <br>one father<span class="hljs-string">&#x27;s son:2</span><br><span class="hljs-string">one son&#x27;</span>s father:2<br></code></pre></td></tr></table></figure><p>函数结束前，堆上的两个对象的引用计数都是２，所以即便函数结束，将两个栈上的的共享指针分别析构，最后堆上的两个对象的引用数也不会为０，而是１，两个对象不会调用析构函数进行析构，从而内存泄漏。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] C++ Primer（第5版）</li><li>[2] <a href="http://senlinzhan.github.io/2015/04/24/%E6%B7%B1%E5%85%A5shared-ptr/">http://senlinzhan.github.io/2015/04/24/%E6%B7%B1%E5%85%A5shared-ptr/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c与c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++中类的拷贝控制操作</title>
    <link href="/2018/10/16/2018-10-16-cpp-class-construct-destruct/"/>
    <url>/2018/10/16/2018-10-16-cpp-class-construct-destruct/</url>
    
    <content type="html"><![CDATA[<p>通常一个类的拷贝控制操作由以下三个函数来定义：</p><ol><li><p>拷贝构造函数</p></li><li><p>拷贝赋值运算符</p></li><li><p>析构函数</p></li></ol><p>以上这３个成员，如果在一个类中未自己定义时，编译器会为这个类自动生成默认的版本。三个成员共同构成了一个类基本的的拷贝控制与资源管理操作。</p><h2 id="default-与-delete-的使用"><a href="#default-与-delete-的使用" class="headerlink" title="=default 与 =delete 的使用"></a><code>=default</code> 与 <code>=delete</code> 的使用</h2><p>我们可以通过将拷贝控制成员定义为<code>=default</code>来<strong>显式</strong>地要求编译器生成合成版本的。</p><p>在c++11标准以后我们可以通过将拷贝构造函数与拷贝赋值运算符定义为<code>=delete</code>来<strong>组织拷贝的发生</strong>。<code>=delete</code>告诉编译器，我们不希望定义这些成员。例如，<code>iostream</code>类阻止了拷贝操作。<strong>析构函数不能是<code>=delete</code>的</strong>，如果我们用<code>=delete</code>将一个类的析构函数定义为删除的，则我们不能定义该类型的变量（但是可以动态分配内存），也不能释放指向该类型动态分配对象的指针。</p><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>拷贝构造函数也是一种构造函数。我们知道，不同版本的构造函数的区别在于参数列表的不同。<strong>拷贝构造函数的第一个参数一定是自身类类型的引用</strong>，任何额外参数都有默认值。</p><p>如果一个类未定义自己的拷贝构造函数，则编译器会为其自动生成一个，自动生成的拷贝构造函数就是将类中的每一个数据成员进行简单的拷贝构造。如果不希望自己的类有拷贝构造函数操作，必须显式将拷贝构造函数声明成<code>=delete</code>来指出我们希望将它定义成删除的，比如<code>iostream</code>类就阻止了拷贝操作来避免多个对象写入或者读取相同的IO操作。</p><p>此处编写一个简陋的<code>HasPtr</code>类为例实现<strong>深拷贝</strong>，比较直观有代码感受：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HasPtr</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">HasPtr</span>(<span class="hljs-type">const</span> string &amp;s = <span class="hljs-built_in">string</span>()) : <span class="hljs-built_in">ps</span>(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>(s)) &#123;cout&lt;&lt;<span class="hljs-string">&quot;调用HasPtr()&quot;</span>&lt;&lt;endl;&#125;<br><br><span class="hljs-built_in">HasPtr</span>(<span class="hljs-type">const</span> HasPtr&amp; hp) :<span class="hljs-built_in">ps</span>(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>(*hp.ps)) &#123;cout&lt;&lt;<span class="hljs-string">&quot;调用HasPtr(HasPtr&amp;)&quot;</span>&lt;&lt;endl;&#125;<br><br>~<span class="hljs-built_in">HasPtr</span>()&#123;<span class="hljs-keyword">delete</span> ps;&#125;<br><br><span class="hljs-keyword">private</span>:<br>std::string *ps;<br>&#125;;<br><br></code></pre></td></tr></table></figure><hr><p>如上，这个类有两个版本的构造函数，其中第一个是普通构造函数（可以没有参数，也可以有一个<code>string&amp;</code>类型），第二个是拷贝构造函数（参数是自身类型的引用）。</p><blockquote><p>注意：拷贝构造函数的第一个参数之所以是引用类型，是因为在<strong>函数调用过程中，具有非引用类型的参数要进行拷贝初始化</strong>。如果拷贝构造函数的参数不是引用类型的话，则会对拷贝构造函数的形参进行拷贝初始化，会再一次调用拷贝构造函数，再对这个拷贝构造函数的形参进行拷贝初始化….如此往复，无限循环。</p></blockquote><h2 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h2><p>拷贝赋值运算符其实就是重载了<code>=</code>，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个，合成的拷贝赋值运算符也就是简单的对类的每个数据成员进行简单的拷贝赋值。如果不希望自己的类有拷贝构造函数操作，必须显式将拷贝构造函数声明成<code>=delete</code>来指出我们希望将它定义成删除的，比如<code>iostream</code>类就阻止了拷贝操作来避免多个对象写入或者读取相同的IO操作。继续上一个<code>HasPtr</code>，为其添加拷贝赋值运算符；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HasPtr</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">HasPtr</span>(<span class="hljs-type">const</span> string &amp;s = <span class="hljs-built_in">string</span>()) : <span class="hljs-built_in">ps</span>(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>(s)) &#123;cout&lt;&lt;<span class="hljs-string">&quot;调用HasPtr()&quot;</span>&lt;&lt;endl;&#125;<br><br><span class="hljs-built_in">HasPtr</span>(<span class="hljs-type">const</span> HasPtr&amp; hp) :<span class="hljs-built_in">ps</span>(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>(*hp.ps)) &#123;cout&lt;&lt;<span class="hljs-string">&quot;调用HasPtr(HasPtr&amp;)&quot;</span>&lt;&lt;endl;&#125;<br><br>HasPtr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> HasPtr&amp; hp)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;调用operator=&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">auto</span> new_ptr = <span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>(*hp.ps);<span class="hljs-comment">//防止对自身进行赋值，不能先释放ps指向的内存</span><br><span class="hljs-keyword">delete</span> ps;<br>ps = new_ptr;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>~<span class="hljs-built_in">HasPtr</span>()&#123;<span class="hljs-keyword">delete</span> ps;&#125;<br><br><span class="hljs-keyword">private</span>:<br>std::string *ps;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>因为一个对象通常在自己的作用域结束后会自动销毁，它销毁的方式就是挨个销毁自己的数据成员。但是有时<strong>光销毁自己的数据成员</strong>是不够的，比如说当此类的数据成员中有一个指向一块动态分配来的内存的指针。此时光销毁指针显然是不够的。我们还需要在销毁指针之前将指针指向的这块动态内存给释放了。而析构函数就是做这个工作的。其中成员的销毁是隐式进行的。</p><blockquote><p>析构函数负责在销毁对象的数据成员前完成料理好它们的<strong>身后事</strong>。使得即使这个对象的数据成员被销毁了，依然不会有乱子出现。</p></blockquote><h2 id="三-x2F-五法则（自己翻书把）"><a href="#三-x2F-五法则（自己翻书把）" class="headerlink" title="三&#x2F;五法则（自己翻书把）"></a>三&#x2F;五法则（自己翻书把）</h2><h2 id="探究初始化操作与赋值操作真正调用的函数"><a href="#探究初始化操作与赋值操作真正调用的函数" class="headerlink" title="探究初始化操作与赋值操作真正调用的函数"></a>探究初始化操作与赋值操作真正调用的函数</h2><p>使用上述定义的类，对它进行测试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-function">HasPtr  <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;hello wprld&quot;</span>)</span></span>;  <br>cout&lt;&lt;endl;<br><br><span class="hljs-function">HasPtr <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>;    <br>cout&lt;&lt;endl;<br><br>HasPtr c = a;<br>cout&lt;&lt;endl;<br><br>string s = <span class="hljs-string">&quot;hello&quot;</span>;<br>HasPtr d = s;<br>cout&lt;&lt;endl;<br><br>HasPtr e;<br>e=a;<br> <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>上述程序运行后，输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">xhy@ubuntu:~/cpp_learn/ch13$ ./test_init <br>调用HasPtr()<br><br>调用HasPtr(HasPtr&amp;)<br><br>调用HasPtr(HasPtr&amp;)<br><br>调用HasPtr()<br><br>调用HasPtr()<br>调用operator=<br></code></pre></td></tr></table></figure><p>***　</p><blockquote><p>由上可知，只要是<strong>初始化操作</strong>，无论是直接初始化（使用参数表）还是拷贝初始化（使用＝），全部使用的是构造函数，具体使用哪个版本的构造函数则由括号或者＝号提供的参数形式决定。只有当是普通的赋值操作时，才使用拷贝赋值运算符（重载的＝）。</p></blockquote><h3 id="加强版测试"><a href="#加强版测试" class="headerlink" title="加强版测试"></a>加强版测试</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;initializer_list&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span><br>&#123;<br><span class="hljs-built_in">X</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;X()&quot;</span> &lt;&lt; std::endl; &#125;<br><span class="hljs-built_in">X</span>(<span class="hljs-type">const</span> X&amp;) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;X(const X&amp;)&quot;</span> &lt;&lt; std::endl; &#125;<br>X&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> X&amp;) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;X&amp; operator=(const X&amp;)&quot;</span> &lt;&lt; std::endl; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;<br>~<span class="hljs-built_in">X</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;~X()&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> X &amp;rx, X x)</span></span><br><span class="hljs-function"></span>&#123;<br>std::vector&lt;X&gt; vec;<br>vec.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">2</span>);<br>vec.<span class="hljs-built_in">push_back</span>(rx);<br>vec.<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>X *px = <span class="hljs-keyword">new</span> X;<br><span class="hljs-built_in">f</span>(*px, *px);<br>    X x;<br>    x = *px;<br><span class="hljs-keyword">delete</span> px;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">xhy@ubuntu:~/cpp_learn/ch13$ ./test_all <br>X()<br>X(const X&amp;)<br>X(const X&amp;)<br>X(const X&amp;)<br>~X()<br>~X()<br>~X()<br>X()<br>X&amp; operator=(const X&amp;)<br>~X()<br>~X()<br></code></pre></td></tr></table></figure><hr><p>如上，测试函数说明了：</p><ol><li><p>在函数调用时，<strong>不是引用类型的形参都是采用拷贝构造函数</strong>进行形参的初始化的，引用类型的形参直接绑定到实参上。</p></li><li><p>在<code>vector</code>进行<code>reserve</code>函数进行空间分配时，只是分配了空间，并没有在分配的空间上进行初始化操作。</p></li><li><p>在<code>vector</code>进行<code>push_back</code>操作时，使用拷贝初始化函数对新增元素进行初始化操作；</p></li><li><p>在一个函数作用域结束时，会将此<strong>作用域中的自动变量</strong>一一析构（包括形参）。</p></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] C++ Primer（第5版）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c与c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv中的Mat类讲解</title>
    <link href="/2018/10/10/2018-10-10-opencv-mat/"/>
    <url>/2018/10/10/2018-10-10-opencv-mat/</url>
    
    <content type="html"><![CDATA[<h1 id="Mat类"><a href="#Mat类" class="headerlink" title="Mat类"></a>Mat类</h1><p>很久以前（大概两千年左右），opencv还只是提供ｃ接口的一个库。那时它使用一种ｃ语言的结构体叫做<code>IplImage</code>来存储图像。后来实在是受不了了，因为使用ｃ语言接口的用户需要自己来管理内存，实在特别麻烦并且容易出错。opencv维护者们就使用c++又翻新了一遍opencv库。新版本中（2.0往后）支持使用Mat来存储图像。</p><h2 id="Mat的组成"><a href="#Mat的组成" class="headerlink" title="Mat的组成"></a>Mat的组成</h2><p>Mat主要由两部分组成：</p><ol><li><p>矩阵头信息：主要是矩阵大小、矩阵存储方法、矩阵地址等，矩阵头大小是固定的；</p></li><li><p>图像像素矩阵的指针对象，使用类似智能指针<code>shared_ptr</code>的方法来管理内存；</p></li></ol><h2 id="Mat对象的拷贝问题"><a href="#Mat对象的拷贝问题" class="headerlink" title="Mat对象的拷贝问题"></a>Mat对象的拷贝问题</h2><p>Mat对象的拷贝构造函数、拷贝赋值运算符（重载的<code>=</code>）都是使用的浅拷贝，即只拷贝了指针的值，但是它们指向共同的一片区域。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Mat A, C;                          <span class="hljs-comment">// creates just the header parts</span><br>A = <span class="hljs-built_in">imread</span>(argv[<span class="hljs-number">1</span>], IMREAD_COLOR); <span class="hljs-comment">// here we&#x27;ll know the method used (allocate matrix)</span><br><span class="hljs-function">Mat <span class="hljs-title">B</span><span class="hljs-params">(A)</span></span>;                                 <span class="hljs-comment">// Use the copy constructor</span><br>C = A;                                    <span class="hljs-comment">// Assignment operator</span><br><span class="hljs-function">Mat <span class="hljs-title">D</span> <span class="hljs-params">(A, Rect(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>) )</span></span>; <span class="hljs-comment">// using a rectangle　Ｄ中的指针指向Ａ指针指向矩阵的一片长方形区域</span><br>Mat E = <span class="hljs-built_in">A</span>(Range::<span class="hljs-built_in">all</span>(), <span class="hljs-built_in">Range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)); <span class="hljs-comment">// using row and column boundaries　也是指向一部分区域，第一个参数代表行（全部行），第二个参数代表列（１～３列）</span><br></code></pre></td></tr></table></figure><p>如上，A、B、C三个对象最终指向的都是同一片内存区域。即对它们三个任何一个的图像进行修改，另外两个也修改了。如果想要进行深拷贝，可以使用Mat类自带的两个函数：<code>cv::Mat::clone()</code>与<code>cv::Mat::copyTo()</code>，使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Mat F = A.<span class="hljs-built_in">clone</span>();<br>Mat G;<br>A.<span class="hljs-built_in">copyTo</span>(G);<br></code></pre></td></tr></table></figure><p>现在，Ａ、Ｆ、Ｇ三个Mat对象分别管理属于自己的图像矩阵内存，不会互相干扰。</p><h2 id="Mat对象的存储方法"><a href="#Mat对象的存储方法" class="headerlink" title="Mat对象的存储方法"></a>Mat对象的存储方法</h2><blockquote><p>使用<code>imread(&quot;1.png&quot;)</code>，默认参数是<code>IMREAD_COLOR</code>,即总是将硬盘中的图片转换为8位的3通道BGR彩色图然后读入内存，并返回一个3通道BGR的mat类型</p></blockquote><p>存储方法主要受两个参数影响：</p><ol><li><p>颜色空间：决定了使用何种方法编码一个像素的颜色，比如灰度空间单通道描述、RGB三通道红绿蓝描述、RGBD四通道红绿蓝透明度四通道描述等等；</p></li><li><p>数据类型：使用何种数据类型来描述一个通道，如unsigned char(8位0<del>255)、signed char(8位-128</del>127)、float(32位)、double(64位)等，越大则图像占用内存越大，可描述的色彩越细微；</p></li></ol><p>颜色空间主要有RGB、HSV、HLS、YCrCb等，想了解自己再查书吧。值得一提的是<strong>opencv标准显式中使用的RGB其实是BGR</strong>，即翻转了一下顺序。同时，RGB转灰度空间使用了如下公式：</p><pre><code class="hljs">Gray = R*0.299 + G*0.587 + B*0.114</code></pre><blockquote><p>关于颜色空间更多的知识可以查看<a href="https://www.learnopencv.com/color-spaces-in-opencv-cpp-python/">这篇博文</a>，在opencv中提供了将不同颜色空间的Mat进行转换的函数<code>cv2.cvtColor</code></p></blockquote><h3 id="Mat中指针指向的矩阵中像素的组织形式（灰度空间与BGR空间）"><a href="#Mat中指针指向的矩阵中像素的组织形式（灰度空间与BGR空间）" class="headerlink" title="Mat中指针指向的矩阵中像素的组织形式（灰度空间与BGR空间）"></a>Mat中指针指向的矩阵中像素的组织形式（灰度空间与BGR空间）</h3><p>像素的组织形式主要依赖于颜色空间类型的选择，下图是<strong>灰度空间</strong>下像素的组织形式：<br><img src="/img/opencv-mat/tutorial_how_matrix_stored_1.png" alt="tutorial_how_matrix_stored_1"></p><p>下面这张图是<strong>BGR颜色空间</strong>的组织形式，每个大列下会有三个小列依次代表着三种颜色通道（分别是B、G、R），其实就是每个像素由三个<code>uchar</code>组成（假设<code>data_type</code>是<code>uchar</code>）：<br><img src="/img/opencv-mat/tutorial_how_matrix_stored_2.png" alt="tutorial_how_matrix_stored_2"></p><blockquote><p>无论Mat是几通道的颜色空间，其矩阵都是两维的。只是两维矩阵的每一个元素的大小是<code>通道数*数据类型的大小</code>，即在一个元素中，各通道依次存储。同时有一点需要说明，如果内存足够大，在载入图像时，便会将下一行紧随着上一行存储，所以最后有可能<strong>整幅图像存成了一行</strong>。这种情况是可以帮我们提升扫描速度的（按照一维方式扫描只需要获得一次行首指针），我们可以使用opencv提供的<code>cv::Mat::isContinuous()</code>函数来确定是否是连续存储的。</p></blockquote><h2 id="Mat对象的创建与显示"><a href="#Mat对象的创建与显示" class="headerlink" title="Mat对象的创建与显示"></a>Mat对象的创建与显示</h2><p>Mat的创建有好多方式，同时它重载了<code>&lt;&lt;</code>，使得可以直接用<code>cout</code>进行输出显示，<a href="https://github.com/xhy3054/myopencv/blob/master/004_Mat/mat_creat_print.cpp">mat_creat_print.cpp</a>中实现了各种创建与显示的方法，可以查看代码或者直接运行查看结果。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>opencv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++中的引用</title>
    <link href="/2018/10/09/2018-10-09-reference-cpp/"/>
    <url>/2018/10/09/2018-10-09-reference-cpp/</url>
    
    <content type="html"><![CDATA[<p>在c++中，为了改变c语言中指针使用的种种麻烦与困难，定义了一种新的复合类型－－－引用，引用也分为很多种，比如左值引用、右值引用、常量引用等等。</p><h1 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h1><p>一般情况下，大家见的最多的就是左值引用。右值引用通常与移动操作结合起来的比较多。其中左值引用使用<code>&amp;</code>符号，右值引用使用<code>&amp;&amp;</code>。</p><p>下面是左值引用的两个大类。</p><h2 id="普通引用"><a href="#普通引用" class="headerlink" title="普通引用"></a>普通引用</h2><p>引用为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。通过将声明符写成<code>&amp;d</code>的形式来定义引用类型，其中d是声明的变量名。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i1 = <span class="hljs-number">1024</span>;<br><span class="hljs-type">int</span> &amp;r1 = i1;<span class="hljs-comment">//r1是i1的引用（也就是i1的别名）</span><br><span class="hljs-type">int</span> &amp;r2;<span class="hljs-comment">//错误！引用必须初始化，引用是无法复制的，因为对引用赋值其实是对引用绑定的变量赋值。</span><br><span class="hljs-type">int</span> &amp;r3 = <span class="hljs-number">1024</span>;<span class="hljs-comment">//错误！普通引用不能绑定常量</span><br></code></pre></td></tr></table></figure><p>如下是几个注意问题：</p><ol><li><p>引用<strong>必须初始化</strong>！因为引用是无法赋值的，对引用赋值其实是对引用绑定的变量赋值。</p></li><li><p>普通引用（非常量引用）是<strong>不能绑定常量</strong>的！因为可以使用引用对绑定的变量进行赋值，所以如果引用绑定了常量，就会有改变常量的操作发生的可能。</p></li><li><p><strong>没有引用的引用，但是可以通过引用绑定到一个对象</strong>（如<code>int i=1; int &amp;a=i; int &amp;b=a;</code>这样是可以的，但是b绑定的是i）。因为引用本身只是一个别名，不是一个对象，所以不能定义引用的引用。</p></li><li><p>引用的<strong>类型必须与绑定的对象严格匹配</strong>。</p></li><li><p>引用只能绑定在对象上，<strong>不能与字面值或者某个表达式的计算结果绑定</strong>。</p></li></ol><blockquote><p>拓展：定义内置数组的引用。</p></blockquote><p>因为内置数组不可拷贝，所以内置数组的引用就会十分有用，并且高效。使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>&#125;;<span class="hljs-comment">//第一个元素为１，其他元素默认初始化为０</span><br><span class="hljs-built_in">int</span> (&amp;arrRef)[<span class="hljs-number">10</span>] = arr;<span class="hljs-comment">//其实就是多取了一个名</span><br>cout&lt;&lt;arrRef[<span class="hljs-number">0</span>];<span class="hljs-comment">//输出１</span><br></code></pre></td></tr></table></figure><h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><blockquote><p>科普一下，const可以分为顶层const与底层const两种。一般对象只会有顶层const，表示对象本身是常量不能修改；而对于指针与引用变量除了顶层const外（表示自身是常量，一般只对指针而言，引用一般只关心底层const），还有底层const，表示自身指向或者引用的对象是常量。</p></blockquote><p>此处常量引用指的是底层const，即不能通过此引用改变绑定的对象。常量引用有几个特殊的地方：</p><ol><li><p>常量引用可以<strong>绑定常量，也可以绑定非常量</strong>（但是不能通过此引用改变这个非常量的值）；</p></li><li><p>常量引用的<strong>类型不必与绑定的对象严格一致</strong>，只要可以转换成常量引用的类型即可；</p></li><li><p>常量引用<strong>可与字面值或者某个表达式的计　算结果绑定</strong>；</p></li></ol><p>其中第一条很容易理解，第二条、第三条的原因可由下面例子知道原因：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> d1 = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r1 = d1;<span class="hljs-comment">//正确！</span><br><span class="hljs-comment">//上式等价于如下：</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> temp = d1;<span class="hljs-comment">//先生成一个临时变量（与常量引用类型一致）</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r1 = temp;<span class="hljs-comment">//让r1绑定这个临时量</span><br></code></pre></td></tr></table></figure><p>当所要绑定的对象与常量引用类型不一样时，编译器便会创建一个临时变量，并将原变量转换类型赋值给这个临时变量，常量引用最终绑定的是这个临时变量。当绑定对象是某个表达式时执行操作一样。注意！这种操作只在必要时发生，如果绑定的是一个类型相符的变量，则直接进行绑定操作，不会有什么临时变量。(因此这个引用其实与原变量不再相关，即使原变量值被修改了，这个引用指向的值不变，其实常量引用就相当于一个字面值常量)</p><h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>新标准中为了支持移动操作，有了<strong>右值引用</strong>的概念。顾名思义，右值引用就是绑定到右值的引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> &amp;r = i;<span class="hljs-comment">//正确：r是变量i的引用</span><br><span class="hljs-type">int</span> &amp;&amp;rr = i;<span class="hljs-comment">//错误：不能将一个右值引用绑定到一个左值上</span><br><span class="hljs-type">int</span> &amp;r2 = i*<span class="hljs-number">42</span>;<span class="hljs-comment">//错误：不能将一个普通引用绑定到一个右值上</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r3 = i*<span class="hljs-number">42</span>;<span class="hljs-comment">//正确：可以讲一个常量引用绑定到一个临时变量上</span><br><span class="hljs-type">int</span> &amp;&amp;rr2 = i*<span class="hljs-number">42</span>;<span class="hljs-comment">//正确：将右值引用绑定到一个右值上</span><br></code></pre></td></tr></table></figure><hr><p>由上我们可以看出，左值一般有持久的状态，是一个稳定的对象；而右值要么是字面值常量，要么是表达式求值过程中创建的临时变量。</p><p>此处需要说明的一点是变量表达式都是左值，我们<strong>不能将一个右值引用绑定到一个右值引用上，因为右值引用本身是左值，是可以通过右值引用改变它指向对象的值的</strong>。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> &amp;&amp;r1=<span class="hljs-number">42</span>;<span class="hljs-comment">//正确：42是一个右值</span><br><span class="hljs-type">int</span> &amp;&amp;r2=r1;<span class="hljs-comment">//错误：右值引用类型的变量表达式r1是一个左值</span><br><span class="hljs-comment">//注意：这样的操作在左值引用就是可以成立的。</span><br></code></pre></td></tr></table></figure><h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move()"></a>std::move()</h2><p>提到右值引用，就不得不提<code>std::move()</code>这个函数（头文件<code>utility</code>）。这个函数的作用就是<strong>将参数包装成一个右值</strong>。</p><p>因为<strong>右值引用为左值</strong>，所以我们可以通过右值引用改变源对象的值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//int &amp;&amp;rr1 = i;    错误，不能绑定左值</span><br><span class="hljs-type">int</span> &amp;&amp;rr2 = std::<span class="hljs-built_in">move</span>(i);<span class="hljs-comment">//此处move返回一个右值类型的值被绑定到右值引用类型变量rr2</span><br>rr2 = <span class="hljs-number">2</span>;<span class="hljs-comment">//正确；通过右值引用改变变量i的值</span><br>cout&lt;&lt;i&lt;&lt;endl;<span class="hljs-comment">//输出２</span><br><span class="hljs-comment">//int &amp;&amp;rr3 = rr2;  错误，rr2是左值</span><br></code></pre></td></tr></table></figure><blockquote><p>通常肯定不会这样使用move，通常我们将move函数来辅助完成<a href="https://xhy3054.github.io/cpp-copy-move/">一个对象的移动操作</a>，因此，往往调用<code>move</code>意味着就承诺：除了对源对象重新赋值或者销毁它外，我们将不再使用它。在对一个源对象做了move操作后，我们只能保证移后源对象结构依旧完好，可以正常销毁，但是它的值我们不能做任何假设。</p></blockquote><h1 id="万能引用"><a href="#万能引用" class="headerlink" title="万能引用"></a>万能引用</h1><p>其实还有一种引用，那就是万能引用，万能引用形式和右值引用一样。万能引用只出现在型別推导的场景下，万能引用可以根据不同的语境选择是成为左值或者右值引用。</p><h2 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward()"></a>std::forward()</h2><p>万能引用总是会搭配<code>std::forward()</code>使用，这个函数会根据语境选择是否<strong>将参数包装成一个右值</strong>。仅在实参原本是右值时才会。因此这中操作也叫做<strong>完美转发</strong>。</p><blockquote><p><code>forward</code>和<code>move</code>其实就是强制类型转换，只不过前者是有条件的转换，后者无条件转换。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] C++ Primer（第5版）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c与c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈佛体系结构与冯诺依曼体系结构的区别</title>
    <link href="/2018/10/03/2018-10-03-hafuo-feng-struct/"/>
    <url>/2018/10/03/2018-10-03-hafuo-feng-struct/</url>
    
    <content type="html"><![CDATA[<p>MCS-51单片机有着嵌入式处理器经典的体系结构，这种体系结构在当前嵌入式处理器的高端ARM系列上仍然在延续，这就是哈佛结构。相对于大名鼎鼎的冯·诺依曼结构，哈佛结构的知名度显然逊色许多，但在嵌入式应用领域，哈佛结构却拥有着绝对的优势。哈佛结构与冯·诺依曼结构的最大区别在于<strong>冯·诺依曼结构的计算机采用代码与数据的统一编址，而哈佛结构是独立编址的，代码空间与数据空间完全分开</strong>。</p><p>在<strong>通用计算机系统</strong>中，应用软件的多样性使得计算机要不断地变化所执行的代码的内容，并且频繁地对数据与代码占有的存储器进行重新分配，这种情况下，<strong>冯·诺依曼结构占有绝对优势，因为统一编址可以最大限度地利用资源</strong>，而哈佛结构的计算机若应用于这种情形下则会对存储器资源产生理论上最大可达50%的浪费，这显然是不合理的。</p><p>但是在嵌入式应用中，系统要执行的任务相对单一，程序一般是固化在硬件里。当然这时使用冯·诺依曼结构也完全可以，代码区和数据区在编译时一次性分配好了而已，但是其灵活性得不到体现，所以除了如英特尔公司的8086，英特尔公司的其他中央处理器，现在大量的单片机也还在沿用冯·诺依曼结构，ARM公司的ARM7、MIPS公司的MIPS处理器、TI的MSP430系列、Freescale的HCS08系列等。</p><p>那是为什么说哈佛结构有优势呢？嵌入式计算机在工作时与通用计算机有着一些区别：嵌入式计算机在工作期间的绝大部分时间是无人值守的，而通用计算机工作期间一般是有人操作的；嵌入式计算机的故障可能会导致灾难性的后果，而通用计算机一般就是死死机，重新启动即可。这两点决定了对嵌入式计算机的一个基本要求：<strong>可靠性</strong>。</p><p>使用冯·诺依曼结构的计算机，程序空间不封闭，期程序空间的数据在运行期理论上可以被修改，此外程序一旦跑飞也有可能运行到数据区。虽然都是一些不常见的特殊情况下，但是看看哈佛结构德计算机在这些情况下是怎样的：基于哈佛结构的处理器入MCS-51，不需要可以对代码段进行写操作的指令，所以不会有代码区被改写的问题；程序只能在封闭的代码区中运行，不可能跑到数据区，这也是跑飞的几率减少并且跑飞后的行为有规律（数据区的数据是不断变化的而代码区是不变的）。Microchip公司的PIC系列芯片，还有摩托罗拉公司的MC68系列、Zilog公司的Z8系列、ATMEL公司的AVR系列和ARM公司的ARM9、ARM10和ARM11，51单片机也属于哈佛结构</p><p>所以，<strong>相对于冯·诺依曼结构，哈佛结构更加适合于那些程序固化、任务相对简单的控制系统</strong>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>冯.诺依曼指出：程序只是一种（特殊）的数据，它可以像数据一样被处理，因此可以和数据一起被存储在同一个存储器中——这就是著名的<strong>冯.诺依曼原理</strong>。注意:<strong>数据总线和地址总线共用。</strong></p><p>哈佛结构:</p><p>哈佛结构是一种<strong>并行</strong>体系结构，它的主要特点是将程序和数据存储在不同的存储空间中，即程序存储器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问。与两个存储器相对应的是系统的<strong>4条总线</strong>：程序的数据总线与地址总线，数据的数据总线与地址总线。这种分离的程序总线和数据总线<strong>允许在一个机器周期内同时获得指令字（来自程序存储器）和操作数（来自数据存储器）</strong>，从而提高了执行速度，使数据的吞吐率提高了1倍。又由于程序和数据存储器在两个分开的物理空间中，因此取指和执行能完全重叠。CPU首先到程序指令存储器中读取程序指令内容，解码后得到数据地址，再到相应的数据存储器中读取数据，并进行下一步的操作（通常是执行）。</p><p><a href="https://www.cnblogs.com/li-hao/archive/2011/12/21/2296010.html">参考来源</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令行调试工具gdb小结</title>
    <link href="/2018/10/01/2018-10-01-gdb/"/>
    <url>/2018/10/01/2018-10-01-gdb/</url>
    
    <content type="html"><![CDATA[<p>一个合格的程序猿，肯定熟练掌握一种或者几种编程语言。而要想熟练掌握ｃ与c++语言，gdb这个工具是一定得了解的。额，不过我写它主要是给自己一个快速查看的链接，等到我把这些背下来就没什么价值了。这里只会写最常用最简单的功能，如果想要了解更多，可以查看<strong>gdb技术手册</strong>。</p><h1 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h1><p>GDB是一个由GNU开源组织发布的、UNIX&#x2F;LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。gdb的功能及其强大，命令也十分的多，但是对于普通的绝大部分的工作来说，懂得这其中最常用这些便可以了。下面记录，专为查阅准备。其次如果想对代码进行调试，一定记得在编译源文件时得将源代码调试信息写入可执行文件，这个在用gcc或g++时使用<code>-g</code>参数完成这一步操作。</p><h2 id="1-必要命令行使用方法"><a href="#1-必要命令行使用方法" class="headerlink" title="1. 必要命令行使用方法"></a>1. 必要命令行使用方法</h2><h3 id="1-1-进入gdb"><a href="#1-1-进入gdb" class="headerlink" title="1.1 进入gdb"></a>1.1 进入gdb</h3><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -g test.cpp -o <span class="hljs-built_in">test</span><br>gdb <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>　　</p><blockquote><p>在调试<code>test</code>时，<code>test.cpp</code>源文件一定得在当前目录下，否则执行<code>list</code>命令时会找不到源码。</p></blockquote><h3 id="1-2-gdb常用命令"><a href="#1-2-gdb常用命令" class="headerlink" title="1.2 gdb常用命令"></a>1.2 gdb常用命令</h3><ul><li><p><code>r</code>:  Run的简写，运行被调试的程序。如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处。</p></li><li><p><code>c</code>:  Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。</p></li><li><p><code>b</code>:  Breakpoint的简写，设置断点。可以使用<strong>“行号”“函数名称”“代码地址”</strong>等方式指定断点位置。其中在函数名称前面加“*”符号表示将断点设置在“由编译器生成的prolog代码处”。如果不了解汇编，可以不予理会此用法。</p></li><li><p><code>d</code>: 　Delete breakpoint的简写，删除指定编号的某个断点，或删除所有断点。断点编号从1开始递增。如：<code>d 1</code>。</p></li><li><p><code>s</code>:  step的简写，执行一行源程序代码，如果此行代码中有函数调用，则进入该函数；相当于其它调试器中的“Step Into (单步跟踪进入)”；</p></li><li><p><code>n</code>:  next的简写，执行一行源程序代码，此行代码中的函数调用也一并执行。相当于其它调试器中的“Step Over (单步跟踪)”。</p></li><li><p><code>si/ni</code>:  si命令类似于s命令，ni命令类似于n命令。所不同的是，这两个命令（si&#x2F;ni）所针对的是汇编指令，而s&#x2F;n针对的是源代码。</p></li><li><p><code>p &lt;变量名称&gt;</code>:  Print的简写，显示指定变量（临时变量或全局变量）的值。</p></li><li><p><code>backtrace（或bt）</code>:  查看各级函数调用及参数。</p></li><li><p><code>finish</code> :  连续运行到当前函数返回为止，然后停下来等待命令。</p></li><li><p><code>list（或l）</code> :  列出源代码，接着上次的位置往下列，每次列10行。</p></li><li><p><code>list 函数名</code> :  列出某个函数的源代码。</p></li><li><p><code>start</code> :  开始执行程序，停在main函数第一行语句前面等待命令。</p></li><li><p><code>set var</code> :  修改变量的值。</p></li><li><p><code>clear</code> :  删除程序中所有的断点，<code>clear 行号</code>删除此行中的断点，<code>clear 函数名</code>删除该函数的断点。</p></li><li><p><code>display</code>: 设置程序中断后欲显示的数据及其格式。例如，如果希望每次程序中断后可以看到即将被执行的下一条汇编指令，可以使用命令<code>display /i $pc</code>其中<code>$pc</code>代表当前汇编指令，<code>/i</code>表示以十六进行显示。当需要关心汇编代码时，此命令相当有用。</p></li><li><p><code>undisplay &lt;编号&gt;</code>: 取消先前的display设置，编号从1开始递增。如<code>undisplay 1</code></p></li><li><p><code>i</code>:  Info的简写，locals 查看当前栈帧局部变量的值详情请查阅“help i”。</p></li><li><p><code>q</code>:  Quit的简写，退出GDB调试环境。</p></li><li><p><code>help [命令名称]</code>:  GDB帮助命令，提供对GDB名种命令的解释说明。如果指定了“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令，供用户进一步浏览和查询。</p></li></ul><h3 id="1-3-设置观察点"><a href="#1-3-设置观察点" class="headerlink" title="1.3 设置观察点"></a>1.3 设置观察点</h3><p> 观察点一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化，马上停住程序。</p><h3 id="1-4-设置捕捉点"><a href="#1-4-设置捕捉点" class="headerlink" title="1.4 设置捕捉点"></a>1.4 设置捕捉点</h3><p>你可设置捕捉点来补捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++抛出的某种异常等。</p><h2 id="2-调试多线程"><a href="#2-调试多线程" class="headerlink" title="2. 调试多线程"></a>2. 调试多线程</h2><h2 id="3-调试内核"><a href="#3-调试内核" class="headerlink" title="3. 调试内核"></a>3. 调试内核</h2>]]></content>
    
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像特征之ORB特征详解</title>
    <link href="/2018/09/16/2018-09-16-visual-feature-orb/"/>
    <url>/2018/09/16/2018-09-16-visual-feature-orb/</url>
    
    <content type="html"><![CDATA[<p>学术需要，最近开始着手一些视觉slam的工作，首先接触了如今github上最火的开源valsm的项目－－ORB-Slam，这是一种基于特征点匹配的方法。其实以前我就已经接触过一些图像特征了，比如说SURF、SIFT等经典的特征点，记得当时还依据SURF特征写过一个图像拼接的MATLAB大作业。但是说实话，当时对于图像特征这个概念我的理解是非常浅显的。这次进行视觉SLAM的学习，首先就从ORB特征点开始，这段时间的学习，我对于图像特征又有了全新的理解。希望可以通过这篇博客记录下来。</p><h1 id="１-特征点"><a href="#１-特征点" class="headerlink" title="１　特征点"></a>１　特征点</h1><p>特征点是图像中一些特别的地方。一般而言，人工设计的特征点（比如SIFT、SURF、ORB等）都具有如下的性质：</p><ol><li><strong>可重复性</strong>：即相同的“区域“可以在不同的图像中找到（比如将特征点比作一只猫，在图一和图二中都能找到这只猫）。</li><li><strong>可区别性</strong>：即不同的”区域“有不同的表达。</li><li><strong>高效率</strong>：在同一副图像中，特征点的数量应该远小于像素的数量。</li><li><strong>本地性</strong>：特征仅与一小片图像区域相关。</li></ol><p><strong>特征点</strong>由<strong>关键点</strong>和<strong>描述子</strong>两部分组成。</p><blockquote><p><strong>关键点</strong>通常是指该特征点在图像中的位置，有的特征点还具有朝向、大小等信息。<strong>描述子</strong>通常是一个向量，按照认为设计的方式，描述了该关键点周围像素的信息。描述子的设计原则是<strong>外观相似的特征应该有相似的描述子</strong>。</p></blockquote><h1 id="２-ORB特征"><a href="#２-ORB特征" class="headerlink" title="２　ORB特征"></a>２　ORB特征</h1><p>ORB（Oriented FAST and Rotated BRIEF）特征也是由关键点和描述子组成。正如其英文全名一样，这种特征使用的特征点是”<strong>Oriented FAST</strong>“，描述子是”<strong>Rotated BRIEF</strong>“。其实这两种关键点与描述子都是在ORB特征出现之前就已经存在了，ORB特征的作者将二者进行了一定程度的改进，并将这两者巧妙地结合在一起，得出一种可以快速提取的特征－－<strong>ORB特征</strong>。ORB特征在速度方面相较于SIFT、SURF已经有明显的提升的同时，保持了特征子具有旋转与尺度不变性。</p><h2 id="2-1-FAST-关键点"><a href="#2-1-FAST-关键点" class="headerlink" title="2.1 FAST 关键点"></a>2.1 FAST 关键点</h2><p><strong>FAST特征点</strong>检测算法由E.Rosten和T.Drummond在2006年在其论文“Machine Learning for High-speed Corner Detection”中首次提出。英文全称是“Features from  Accelerated Segment Test”，可以翻译成“基于加速分割测试的特征”。从论文名字可以看出FAST是一种高效的特征点（角点）检测算法，基本上可以满足实时检测系统要求，是计算机视觉领域最主流的角点检测算法之一。虽然FAST特征检测速度很快，但首字母刚好拼成fast，真是一个美丽的巧合。</p><p>FAST的角点检测过程如下：</p><ol><li><p>在图像中选取像素p，假设它的亮度为Ip；</p></li><li><p>设置一个阈值T（比如，Ip的20%）;</p></li><li><p>以像素p为中心，选取半径为３的圆上的16个像素点（如下图选取方式）；</p></li><li><p>假设候选的圆上有连续的N个点的亮度大于Ip+T或者小于Ip-T，那么像素p可以被认为是特征点（N通常取12，即为FAST-12，取为9和11也很常见，它们分别被称为FAST-9和FAST-11）;</p></li><li><p>循环上述操作，对每一个像素执行相同的操作。</p><p> <img src="/img/orb/fast_speedtest.jpg" alt="fast_speedtest"></p></li></ol><p><strong>加速</strong>：通常在FAST-12算法中，为了更加高效，可以添加一项预测试操作，来快速排除图像中海量的不是角点的像素。具体操作为：对于每个像素，直接检测领域圆上的第1、5、9、13个像素的亮度。只有当这四个像素中有三个同时大于Ip+T或者小于Ip-T时，当前像素才有可能是一个角点，继续进行更加严谨的判断，否则直接排除。</p><p><strong>优化</strong>：通常，原始的FAST角点经常出现“扎堆”的现象。所以在第一遍检测之后，还需要用非极大值抑制，在一定范围内仅仅保留响应极大值的角点。这样可以有效缓解角点集中的问题。</p><h3 id="ORB中对fast的一些改进"><a href="#ORB中对fast的一些改进" class="headerlink" title="ORB中对fast的一些改进"></a>ORB中对fast的一些改进</h3><p>因为FAST特征点仅仅是比较像素间亮度的差异，所以速度非常快，但是同时它也存在一些问题，因此<strong>在ORB特征中对其进行了改进</strong>。</p><ol><li><p>首先FAST特征点数量很大并且不确定，而我们希望对图像提取<strong>固定数量的特征</strong>。因此，我们可以指定最终要提取的角点数量N，对原始的FAST角点分别计算Harries响应值，然后选取前N个具有最大响应值的角点作为最终的角点集合。</p></li><li><p>因为FAST角点是固定选取半径为3的圆，所以很容易知道其不具备<strong>尺度不变性</strong>。解决这个问题通过构建图像金字塔（opencv中默认的比例因子是1.2，层数为8），并在金字塔的每一层上都进行角点的检测，最终将在所有比例的图像上提取的角点作为最终的角点集合。</p></li><li><p>最后，FAST角点不具备<strong>方向性</strong>。orb解决这个问题通过灰度质心法，具体是通过分别计算区域图像中灰度值作为权重在ｘ轴与ｙ轴上的质心。并通过这两个质心长度的比值确定方向。</p></li></ol><h2 id="2-2-BRIEF-描述子"><a href="#2-2-BRIEF-描述子" class="headerlink" title="2.2 BRIEF 描述子"></a>2.2 BRIEF 描述子</h2><p>BRIEF是2010年的一篇名为《BRIEF:Binary Robust Independent Elementary Features》的文章中提出，Brief为特征描述子，对已检测到的特征点进行描述，是一种二进制编码描述子，摒弃了区域灰度直方图描述特征点的传统方法，加快特征描述子建立速度，降低特征匹配时间。</p><blockquote><p>了解过SIFT和SURF描述子的人应该知道，它们一个描述子就要占用几百个字节内存空间，十分庞大，计算效率很低。而一个BRIEF描述子只需要128，256或512个比特的空间便可存储（opencv中提供了这三种长度，默认为256）。</p></blockquote><p>BRIEF是一种二进制描述子，描述向量由很多0与1组成。这里0与1的确定是通过比较关键点附近两个像素<strong>灰度值的大小关系</strong>确定。</p><p>两个像素的位置确定使用了<strong>随机取点</strong>的比较，原始的BRIEF描述子不具有旋转不变性，因此在图像发生旋转时容易丢失。而在ORB中通过在<strong>FAST特征点提取阶段计算的关键点的方向信息</strong>，通过方向信息进行随机取点函数的设置，使得Rotated BRIEF 描述子具有了良好的<strong>旋转不变性</strong>。</p><h3 id="ORB中对brief的一些改进"><a href="#ORB中对brief的一些改进" class="headerlink" title="ORB中对brief的一些改进"></a>ORB中对brief的一些改进</h3><p>BRIEF描述子的优点在于速度，但是缺点是不具备尺度不变性与旋转不变性并且对于噪声比较敏感，因此在<strong>ORB中同样对其进行了改进</strong></p><ol><li>旋转不变性：在上面通过灰度质心法计算出fast关键点的方向后，在对这个点进行描述时，依据这个方向旋转启发式搜索的256对匹配点对，获得描述子的旋转不变性；</li><li>尺度不变性：在关键点位于的图像金字塔上进行描述子的计算；</li><li>解决噪声敏感的问题：在brief中使用的是pixel与pixel的大小来构造描述子的每一个bit；这样的后果就是对噪声敏感。在orb中不再使用pixel对，而是使用9*9的patch对，也就是对比的是patch的像素值的和（这个通过积分图可以快速计算）。</li></ol><blockquote><p>在orb论文中，提供了启发式搜索算法计算得到的256对匹配点对，可以直接拿来使用，只需要在计算时将这256对点按照<strong>特征点</strong>的方向信息进行旋转就可以了。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] 视觉SLAM十四讲</li><li>[2] <a href="https://blog.csdn.net/tiandijun/article/details/40679581">https://blog.csdn.net/tiandijun/article/details/40679581</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言和ｃ++语言中的几个常识问题</title>
    <link href="/2018/09/15/2018-09-15-c-cpp-common/"/>
    <url>/2018/09/15/2018-09-15-c-cpp-common/</url>
    
    <content type="html"><![CDATA[<p>在我刚上大学那会儿，学了ｃ语言与c++。当时肯定是没学好哈哈，记得我好长一段时间都认为c++语言就是ｃ语言多了面向对象的部分（这个有可能是因为谭浩强的两本书实在太像了）。这段时间一直在总结c语言和c++语言学习，c++语言确实脱胎于c语言，但是有些地方确实还是会有细微的差别的。已经写了几篇博客了，今天这应该是最后一篇，讲的是一些ｃ语言和c++的几个常识问题．比如关键字struct与关键字class等。这个是收尾工作，所以内容十分平，我写的轻松，看起来也轻松。（因为内容实在是少，而且很简单）</p><h1 id="c语言与c-文件的后缀名问题"><a href="#c语言与c-文件的后缀名问题" class="headerlink" title="c语言与c++文件的后缀名问题"></a>c语言与c++文件的后缀名问题</h1><p>这个问题在ｃ语言中会遇到的比较少，但是C++中可能会遇到比较多，比如我就曾经遇到过后缀名是<code>.cc</code>的文件，当时是有些困惑的，后来搞清楚了就好了．这里就来讲清楚这个．</p><p>ｃ语言中的后缀名：</p><ol><li>源文件：<code>.c</code>;</li><li>头文件：<code>.h</code>;</li></ol><p>c++中的后缀名：</p><ol><li>源文件：<code>.cpp</code>、<code>.cc</code>、<code>cxx</code>、<code>.C</code>、<code>.c++</code>;</li><li>头文件：<code>.hpp</code>、<code>.h</code>、<code>.hxx</code>;</li></ol><p>由上我们看到ｃ语言的后缀名比较固定，没什么好说的，但是c++的后缀名似乎版本比较多样。这个其实没什么大不了的，就是一个标注，给人给机器看的，让我们知道它是哪种语言。但是我们也看到了c++那么多版本也不是说所有版本在所有平台上都是可以的，有的平台不区分大小写（windows），所以<code>.C</code>就不能用在该平台上，有的平台不支持<code>+</code>号做后缀，<code>.c++</code>就不能用，下面就列出各个平台支持的c++源文件后缀名版本：</p><ol><li><p>Unix： C, cc, cxx, c</p></li><li><p>GNU C++： C, cc, cxx, cpp, c++</p></li><li><p>Digital Mars： cpp, cxx</p></li><li><p>Borland： C++ cpp</p></li><li><p>Watcom： cpp</p></li><li><p>Microsoft Visual C++： cpp, cxx, cc</p></li><li><p>Metrowerks CodeWarrior： cpp, cp, cc, cxx, c++</p></li></ol><h1 id="c-中的size-t与size-type"><a href="#c-中的size-t与size-type" class="headerlink" title="c++中的size_t与size_type"></a>c++中的size_t与size_type</h1><p>首先，必须得说，<code>size_t</code>与<code>size_type</code>没有本质的区别，都是被标准定义为一种<code>unsigned int</code>类型。但使用时有一点区别需要注意：</p><ol><li><code>size_t</code>类型是容器无关的，定义在全局名称空间中；</li><li><code>size_type</code>类型是容器概念，没有容器不能使用；</li></ol><blockquote><p><code>size_t</code>定义在cstddef头文件中,该文件是C标准库的头文件stddef.h的C++版本.它是一个与机器相关的unsigned类型,其大小足以保证存储内存中对象的大小。size_t与size_type的引入增强了程序在不同平台上的可移植性。经测试发现，在32位系统中size_t是4字节的，而在64位系统中，size_t是8字节的，这样利用该类型可以增强程序的可移植性。理论上，它可以存储任何类型数组的最大大小。size_t类型通常用于循环，数组索引，大小的存储和地址运算。size_t可以存储一个指针，但有一个更好的选择uintptr_t。</p></blockquote><h1 id="c语言与c-中关键字struct的区别"><a href="#c语言与c-中关键字struct的区别" class="headerlink" title="c语言与c++中关键字struct的区别"></a>c语言与c++中关键字struct的区别</h1><h2 id="c语言中的关键字struct"><a href="#c语言中的关键字struct" class="headerlink" title="c语言中的关键字struct"></a>c语言中的关键字struct</h2><p>首先需要说明一下，在ｃ语言中是没有关键字class的。只有关键字struct。</p><p>在ｃ语言中，关键字struct用来开始构建结构体类型。如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">char</span> b;<br>    <span class="hljs-type">float</span> c;<br>&#125;x,y[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>如上，<code>struct&#123;int a;char b;float c;&#125;</code>是一种结构体类型，上述代码中声明a为这种类型的变量，y为包含10个这种类型变量的数组。不过会有人发现这样声明是不是太麻烦，确实有些麻烦，所以可以为这种结构体类型设置<strong>标签</strong>。如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span>&#123;</span><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">char</span> b;<br>    <span class="hljs-type">float</span> c;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> <span class="hljs-title">x</span>,<span class="hljs-title">y</span>[10];</span><br></code></pre></td></tr></table></figure><p>如上，可以起到一样的作用，其中<code>A</code>为该结构体的标签。也有很多人喜欢下面的用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">char</span> b;<br>    <span class="hljs-type">float</span> c;<br>&#125; B;<br>B x,y[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>这种用法其实是用<strong>typedef</strong>为这种结构体类型起了一个<strong>别名</strong>。但是这种类型会有一个局限，就是在结构体内部如果有指向本身的指针的话（链表什么常见的数据结构里经常用到），会不好表达，因为此时别名还未生效，此时就可以使用标签来解决，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span>&#123;</span><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">char</span> b;<br>    <span class="hljs-type">float</span> c;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> *<span class="hljs-title">next</span>;</span><br>&#125; B;<br>B x,y[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><h2 id="c-中的关键字struct与class"><a href="#c-中的关键字struct与class" class="headerlink" title="c++中的关键字struct与class"></a>c++中的关键字struct与class</h2><p>在c++中，关键字struct与class都是用来开始<strong>类</strong>的定义的(注意！c++中关键字struct不再是用来开始结构体的定义，二是类的定义，与ｃ语言中不再一样)。</p><p>那struct与class又有什么区别呢？</p><ol><li><p>我们都知道在类中，成员是有访问属性的，分别是<strong>public</strong>与<strong>private</strong>。这两个关键字唯一的区别就是，使用struct关键字时，如果没有访问说明符，那么成员默认是<strong>public</strong>的；而使用class关键字时，如果没有访问说明符，那么成员默认是<strong>private</strong>的。</p></li><li><p>在定义派生类时，如果没有提供派生访问说明符，则使用<code>struct</code>关键字定义的派生类默认是公有继承，<code>class</code>关键字定义的派生类默认是私有继承。</p></li></ol><blockquote><p>关键字class还可以用在模板定义时修饰类型参数，相当于<code>typename</code>。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] C++ Primer（第5版）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c与c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言和ｃ++语言中函数参数的传递</title>
    <link href="/2018/09/09/2018-09-09-c-cpp-argu-passing/"/>
    <url>/2018/09/09/2018-09-09-c-cpp-argu-passing/</url>
    
    <content type="html"><![CDATA[<p>其实关于函数参数的传递，我一直以来的理解还算到位的。但是经常会有一些稀奇古怪的写法会让我有点懵圈，仔细想清楚了，就会发现都是一样的道理，不过要是我来写我可能会那样写，而不这样写，在这里稍微吐槽一下ｃ语言关于数组指针的很多写法，真是很难理解了。写这个博客希望自己从此不要被很多拗口的写法吓住，抓住本质的东西，写自己的代码。</p><h1 id="1-函数参数传递的本质"><a href="#1-函数参数传递的本质" class="headerlink" title="1 函数参数传递的本质"></a>1 函数参数传递的本质</h1><p>在调用一个函数时进行参数传递（<strong>不只是讲参数列表里的参数，包括函数返回值的参数传递</strong>），其本质上进行的工作都是一样的，即<strong>使用实参初始化形参</strong>。</p><blockquote><p>实参与形参本质上是两个完全不同的变量，它们之间并没有更深入的联系，仅仅只是变量与初始值的关系而已。</p></blockquote><h2 id="1-1-传值参数（包括传指针）"><a href="#1-1-传值参数（包括传指针）" class="headerlink" title="1.1 传值参数（包括传指针）"></a>1.1 传值参数（包括传指针）</h2><p>很普通的那种，大家都了解的差不多。</p><blockquote><p>在此处需要强调一下，所谓<strong>传值</strong>，其实是指在使用实参初始化形参时，将实参的值拷贝一份到形参。此处我将传指针也归纳到了传值这边，因为都有拷贝操作。但是此处需要稍微提一下，有几种类型（也许还有其他？以后遇到会补充）是不能通过这种形式进行拷贝的（也就是<strong>不能进行真正意义上的传值操作</strong>），那就是<strong>数组与函数（还有IO对象如cin、cout等）</strong>。所以当参数列表或者返回值类型中如果出现数组名与函数名（只要参数类型不是引用），编译器会自动将其转换成常量指针类型，然后再使用这个常量指针进行传值操作。</p></blockquote><p>例子（函数指针）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> std::string;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">useBigger</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s1, <span class="hljs-type">const</span> string &amp;s2, <span class="hljs-type">bool</span> (*pf)(<span class="hljs-type">const</span> string &amp;, <span class="hljs-type">const</span> string &amp;))</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">pf</span>(s1,s2);<br>&#125;<br><span class="hljs-comment">//细节：函数的类型只与函数的参数还有返回类型有关，与函数名无关</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lengthCompare</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s1, <span class="hljs-type">const</span> string &amp;s2)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">size</span>()&gt;s2.<span class="hljs-built_in">size</span>())<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//此处自动将函数lengthCompare转换成指向该函数的指针</span><br>    <span class="hljs-built_in">useBigger</span>(<span class="hljs-string">&quot;1234&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>,lengthCompare);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-传引用参数"><a href="#1-2-传引用参数" class="headerlink" title="1.2 传引用参数"></a>1.2 传引用参数</h2><blockquote><p><strong>传引用</strong>的方式也是<strong>使用实参初始化形参</strong>，但是它与<strong>传值</strong>完全不同，它并没有拷贝操作，而是利用引用的特点，将引用类型的形参绑定到实参上。从而达到可以直接操作实参的效果。c语言中不存在引用，所以需要使用指针来完成类似的操作。(多嘴一句，引用在编译器底层其实是通过常量指针实现的)</p></blockquote><p>一个经典的例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;i)</span></span>&#123;<br>    i=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">42</span>;<br>    <span class="hljs-built_in">reset</span>(j);<br>    cout&lt;&lt;<span class="hljs-string">&quot;j=&quot;</span>&lt;&lt;j&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>如上例，在调用<code>reset</code>函数时，使用实参初始化形参实际相当于<code>int j=42; int &amp;i=j;</code>因为形参为一个引用，并且被绑定到变量<code>j</code>上，因此可以通过<code>i</code>对变量<code>j</code>的值进行修改。这样就可以替代指针的部分作用了，而且更简单。　</p><p>同时，使用传引用调用还有其他一些好处：</p><ol><li><p>使用引用避免拷贝，提高效率（进行大的类类型对象的拷贝很低效）；因为引用类型不是一个对象，而仅仅是一种绑定关系，为已存对象另取了一个名字而已。</p></li><li><p>可以传递额外信息，因为引用参数可以改变原变量值，所以并不是只有返回值可以传递信息了，参数也可以（这点指针形参也可以做到）。</p></li></ol><p>注意的问题：</p><ol><li><p>如上<code>int &amp;i</code>类型的形参在传入实参时只能是变量，不能是字面值常量，因为其不能用字面值常量初始化；</p></li><li><p>如果想要使得函数实参可以传入字面值常量，形参需要改成<code>const int &amp;i</code>形式，底层const的引用类型可以使用字面值常量初始化，一般只要不会对参数进行修改，就将其设置成底层const的引用；</p></li></ol><blockquote><p>科普一下，const可以分为顶层const与底层const两种。一般对象只会有顶层const，表示对象本身是常量不能修改；而对于指针与引用变量除了顶层const外（表示自身是常量，一般只对指针而言，引用一般只关心底层const），还有底层const，表示自身指向或者引用的对象是常量。</p></blockquote><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p1 = &amp;i;<span class="hljs-comment">//不能改变p1的值，顶层const</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">42</span>;<span class="hljs-comment">//顶层const</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p2 = &amp;ci;<span class="hljs-comment">//底层const</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r1 = i;<span class="hljs-comment">//底层const,不能通过r1改变i的值</span><br></code></pre></td></tr></table></figure><h2 id="1-3-main函数参数：处理命令行选项"><a href="#1-3-main函数参数：处理命令行选项" class="headerlink" title="1.3 main函数参数：处理命令行选项"></a>1.3 main函数参数：处理命令行选项</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;argc = &quot;</span>&lt;&lt; argc &lt;&lt; endl; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;argc;i++) <br>        cout&lt;&lt;<span class="hljs-string">&quot;argv[&quot;</span>&lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;] = &quot;</span>&lt;&lt; argv[i] &lt;&lt;endl; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br></code></pre></td></tr></table></figure><hr><p>如上，是主函数的带参数形式，此时在将源文件编译生成可执行文件后，运行时可以带参数。举个例子，比如编译生成的可执行文件叫做<code>main_arg</code>，则可以输入如下命令执行：</p><pre><code class="hljs">./main_arg -o -d data0 </code></pre><p>输出如下结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">xhy@ubuntu:~/cpp_learn/6/ch06$ ./main_arg -o -d data0 <br>argc = 4<br>argv[0] = ./main_arg<br>argv[1] = -o<br>argv[2] = -d<br>argv[3] = data0<br>xhy@ubuntu:~/cpp_learn/6/ch06$ <br> <br></code></pre></td></tr></table></figure><hr><p>如上可以知道，其中第一个参数<code>int　argc</code>为命令行中字符串的数量，后面<code>char *argv[]</code>为一个数组，数组元素为一个指向<code>char *</code>类型的指针，指向一个ｃ风格的字符串。最后一个指针之后的元素值保证为０（因此不需要argc其实也能确定是否读完了参数）。</p><p>在这里了要科普一下（引用也一样）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *matrix[<span class="hljs-number">10</span>];<span class="hljs-comment">//10个指针组成的数组</span><br><span class="hljs-built_in">int</span> (*matrix)[<span class="hljs-number">10</span>]<span class="hljs-comment">//一个指向含有十个整数的数组的指针</span><br></code></pre></td></tr></table></figure><p>这两种书写形式含义是不一样的。其中<code>*</code>优先级小于<code>[]</code>，对于<code>int (*matrix)[10]</code>可以按如下顺序来理解该声明的含义：</p><ol><li><p><code>*matrix</code>表示对变量<code>matrix</code>进行解引用操作；</p></li><li><p><code>(*matrix)[10]</code>表示解引用后将得到一个大小为１０的数组；</p></li><li><p><code>int (*matrix)[10]</code>表示数组中的元素是int类型。</p></li></ol><p>同理，对于<code>int *matrix[10]</code>可以按如下顺序来理解该声明的含义：</p><ol><li><p><code>matrix[10]</code>表示matrix是一个大小为１０的数组；</p></li><li><p><code>*matrix[10]</code>表示数组元素是指针类型；</p></li><li><p><code>int *matrix[10]</code>表示数组元素时候int的指针类型。</p></li></ol><p>其实这么写可能比较易读，但是不方便，上述main函数其实还有<strong>一种写法</strong>是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><hr><p>之所以有这第二种写法，是因为前文中提到过，数组是不能使用传值操作的，所以传递数组其实是将数组名转换成了指针，所以<strong>一个指针的数组其实在传值操作时被转换成了一个指针的指针</strong>。并且一般情况下，我写这第二种形式比较习惯一点。指针的指针。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] C++ Primer（第5版）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c与c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言和ｃ++语言中的类型转换</title>
    <link href="/2018/09/08/2018-09-08-c-cpp-type-convert/"/>
    <url>/2018/09/08/2018-09-08-c-cpp-type-convert/</url>
    
    <content type="html"><![CDATA[<p>关于类型转换的问题，本来我并没有如何在意。因为一直都是写的ｃ的代码比较多一点嘛，而ｃ这方面的内容并不多，形式也很简单。所以一直以来都会有一点错觉，觉得这方面自己应该了解的差不多，够用了。偶尔写代码有些关于这部分的内容老是出错，我也都是尽量“绕”过去，没想过深究原因。这段时间的基础学习，真的是学到了很多，也让我意识到自己很多错误的观点。其中关于类型转换，我以前的理解确实是很肤浅的，直到现在我可能了解的也不是那么的到位，所以今天打算写一个这方面的博客，一是总结归纳，免得自己这几天刚刚有的一些了解又丢了；二是加深理解，写的时候也许会有一些收获；三是开启一个这方面的文章，以后如果我有了更深的理解，会在这篇文章里进行更正，希望使得此树之根须越扎越深。</p><p>类型转换主要可以笼统的分为两大类：<strong>隐式类型转换</strong>与<strong>显式类型转换</strong>。</p><blockquote><p>注意：不论是隐式类型转换还是显式类型转换，在进行算术类型转换时，高精度转为低精度都会有精度损失，低精度转为高精度是没有。比如在<strong>有符号的char类型</strong>在与<strong>int类型</strong>进行转换时。将有符号char类型转换成int类型时，值是无损失的（不会发生变化的）。而int类型赋值给有符号char类型时其实进行的是截断式赋值。<br>例子：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">signed</span> <span class="hljs-type">char</span> sc1 = <span class="hljs-number">-128</span>;<br><span class="hljs-comment">//结果i1值为-128，将10000000自动扩展为111...10000000</span><br><span class="hljs-type">int</span> i1 = sc1;<br><span class="hljs-type">int</span> i2 = <span class="hljs-number">-1073741823</span>;<br><span class="hljs-comment">//结果sc2值为１，发生了截断式赋值，将11000...00000001截断为00000001</span><br><span class="hljs-type">signed</span> <span class="hljs-type">char</span> sc2 = i2;<br></code></pre></td></tr></table></figure><h1 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h1><p>隐式类型转换不需要程序员介入，是自动进行的。通常我们注意的比较多的换转换通常是算数类型的隐式类型转。</p><h2 id="算数类型的隐式类型转换"><a href="#算数类型的隐式类型转换" class="headerlink" title="算数类型的隐式类型转换"></a>算数类型的隐式类型转换</h2><p><strong>在表达式求值时</strong>，算数转换的规则定义了一套类型转换的层次，其中的大方向是将运算对象转换成最宽的类型。具体规则如下：</p><ol><li><p>首先会进行整形提升，如果运算对象双方是<code>bool、char、signed char、unsigned char、short、与unsigned short</code>等可以不损失精度的放入int类型中，它们就会提升为int类型。如果它们中有不能用int类型无损存储的，比如<code>unsigned int、long</code>等类型，则会将较小的一方提升为精度较高一方的类型。</p></li><li><p>如果运算对象双方一个为无符号类型，一个为有符号类型，并且无符号类型不小于有符号类型，则将带符号的运算对象转换成无符号的。</p></li><li><p>如果带符号类型大于无符号类型，则结果需要依赖机器。如果此带符号类型可以无损存储此无符号类型，则将无符号类型转换成带符号类型。否则，结果反之。比如两个运算对象分别是<code>long</code>与<code>unsigned int</code>类型，则怎么转换就需要依赖机器中<code>long</code>类型占用空间是否比<code>int</code>多。</p></li></ol><p>总结：表达式求值在根据<code>double&gt;float&gt;int</code>之类的隐式类型转换后求出来的值在<strong>赋值时</strong>还会再进行一次隐式类型转换。例如：<code>int c=5; char d=&#39;0&#39;; char a = c + d;</code></p><h2 id="其他隐式类型转换"><a href="#其他隐式类型转换" class="headerlink" title="其他隐式类型转换"></a>其他隐式类型转换</h2><ol><li><p>数组名转成指针：例如<code>int a[10]; int *p=a;</code>中将数组名转成指针，但是当数组被用作<code>decltype</code>关键字的参数或者作为取地址符（&amp;）、<code>sizeof</code>以及<code>typeid</code>等运算符的运算对象时，上述转换不会发生；</p></li><li><p>指针的转换：比如，第一、常量正数值０或者字面值常量nullptr能转换成任意指针类型；第二、指向任意非常量的指针能转换成<code>void *</code>；第三、指向任意对象的指针能转换成<code>const void*</code>;</p></li><li><p>转成<code>bool</code>类型（通常在判断表达式中）；</p></li><li><p>转换成常量：允许将非常量类型赋值给常量；</p></li></ol><h1 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h1><p>显式类型转换也叫作强制类型转换，除非必须，否则不建议使用。并且在这方面，ｃ语言提供的强制类型转换是及其不完善的，c++对与强制类型转换比之要完善很多，不过依然不建议使用。</p><h1 id="整数类型转换机器码操作"><a href="#整数类型转换机器码操作" class="headerlink" title="整数类型转换机器码操作"></a>整数类型转换机器码操作</h1><ol><li><strong>同位宽的无符号与有符号</strong>的整数类型进行转换时，内存中<strong>机器码形式不变</strong>，变得是<strong>机器码的解读方式</strong>，以补码形式进行解读还是无符号数形式进行解读。</li><li>在进行<strong>扩展位宽</strong>的整数类型转换时，无符号数进行<strong>零扩展</strong>，有符号数进行<strong>符号扩展</strong>。（这两种方式都能保证扩展后原值不变，原理可参考补码原理）</li><li>在进行<strong>截断位宽</strong>的整数类型转换时，采用<strong>截断式转换</strong>。</li><li>同时进行<strong>无符号与有符号和不同位宽</strong>类型转换时，<strong>首先进行位宽变换</strong>。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-comment">//#include &lt;stdlib.h&gt;</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *byte_pointer;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">show_bytes</span><span class="hljs-params">(byte_pointer start, <span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %.2x&quot;</span>, start[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/* $begin extend */</span><br>    <span class="hljs-type">short</span> sx = <span class="hljs-number">-12345</span>;       <span class="hljs-comment">/* -12345 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> usx = sx; <span class="hljs-comment">/*  53191 */</span><br>    <span class="hljs-type">int</span>   x = sx;            <span class="hljs-comment">/* -12345 */</span><br>    <span class="hljs-type">unsigned</span>  ux = usx;      <span class="hljs-comment">/*  53191 */</span><br>    <span class="hljs-type">unsigned</span>  uy = sx;       <span class="hljs-comment">/* Mystery! */</span><br><br>    <span class="hljs-comment">// 16位有符号数-12345与其机器码</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;16位有符号数-12345与其机器码: %d:\t&quot;</span>, sx);<br>    show_bytes((byte_pointer) &amp;sx, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">short</span>));<br>    <br>    <span class="hljs-comment">// 将16位有符号数-12345转换成16位无符号数后其值与机器码</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;将16位有符号数-12345转换成16位无符号数后其值与机器码: %u:\t&quot;</span>, usx);<br>    show_bytes((byte_pointer) &amp;usx, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>));<br>    <br>    <span class="hljs-comment">// 将16位有符号数-12345扩展成32位有符号数后其值与机器码</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;将16位有符号数-12345扩展成32位有符号数后其值与机器码: %d:\t&quot;</span>, x);<br>    show_bytes((byte_pointer) &amp;x, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <br>    <span class="hljs-comment">// 将16位无符号数53191扩展成32位无符号数后其值与机器码</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;将16位无符号数53191扩展成32位无符号数后其值与机器码: %u:\t&quot;</span>, ux);<br>    show_bytes((byte_pointer) &amp;ux, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span>));<br><br>    <span class="hljs-comment">// 将16位有符号数-12345转成32位无符号数后其值与机器码</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;将16位有符号数-12345转成32位无符号数后其值与机器码: %u:\t&quot;</span>, uy);<br>    show_bytes((byte_pointer) &amp;uy, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">unsigned</span>));<br>    <span class="hljs-comment">/* $end extend */</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    test();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><p>运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">xhy@ubuntu:~/c_learn/datatype_int_convert$ ./test <br>16位有符号数-12345与其机器码: -12345: c7 cf<br>将16位有符号数-12345转换成16位无符号数后其值与机器码: 53191: c7 cf<br>将16位有符号数-12345扩展成32位有符号数后其值与机器码: -12345: c7 cf ff ff<br>将16位无符号数53191扩展成32位无符号数后其值与机器码: 53191: c7 cf 00 00<br>将16位有符号数-12345转成32位无符号数后其值与机器码: 4294954951: c7 cf ff ff<br></code></pre></td></tr></table></figure><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] C++ Primer（第5版）</li><li>[2] 深入理解计算机系统（第三版）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c与c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言和ｃ++语言中的几种运算符</title>
    <link href="/2018/09/02/2018-09-02-c-cpp-operator/"/>
    <url>/2018/09/02/2018-09-02-c-cpp-operator/</url>
    
    <content type="html"><![CDATA[<p>ｃ与c++中的运算符种类繁多，虽然大多数都很简单，且用法明确。但是也有很多需要注意的地方。很早之前我就想将其中的一些注意点写下来了，但是总觉得每个点都很小，写一篇博客似乎篇幅太小了。今天一合计，不如就写一个关于运算符的合集吧。这篇博客里不会写的很详细，但是都是一些容易让人困惑的点。</p><h1 id="i-与-i"><a href="#i-与-i" class="headerlink" title="i++ 与++i"></a>i++ 与++i</h1><ol><li><p><code>i++</code>: 首先将ｉ的值进行拷贝，然后将ｉ值加１，最后返回拷贝；</p></li><li><p><code>++i</code>: 首先将ｉ值加１，然后返回ｉ值；</p></li></ol><blockquote><p>　由上述描述，我们会发现<code>i++</code>与<code>++i</code>相比，除了返回值不同外，似乎还多进行了一个拷贝的操作，所以是否<code>++i</code>的运行效率要高一些呢？答案是：是也不是。首先，在标准库里，编译器都会对这个额外的操作进行优化，因此二者其实性能一致。但是对于一些相对复杂的迭代器模型等还有用户自己重载的前置与后置的递增递减运算符，确实是有性能差距的，所以这种操作多了以后，性能差距就明显了。此处推荐尽量使用前置版本的递增递减运算符。 </p></blockquote><h1 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h1><p>首先讲一下移位运算符。分别是<code>&gt;&gt;（右移运算符）</code>与<code>&lt;&lt;（左移运算符）</code>。</p><ol><li><p>首先需要说明的是如果移位运算符的操作对象是位数比较小的整形，比如说<code>unsigned char</code>，在进行移位操作前，会先将其提升为整形（寄存器的位数，一般３２位）。最后，表达式返回的也是一个整形（３２位）的值。</p></li><li><p>移位运算符的操作对象为无符号数时，程序是可移植的。此时无论右移还是左移都是补零。</p></li><li><p>移位运算符的操作对象为有符号数时，此时程序是不可移植的。在不同的机器上有可能会出现不同的结果，其中有的机器上使用的是<code>逻辑移位</code>，也就是不考虑符号位，移位时另一边直接补零。还有一种是<code>算术移位</code>（尽量保持只对无符号数进行移位操作）。注意：逻辑移位的话不需多讲，算术移位在做左移时其实与逻辑移位操作一样，但是它在右移时会在最高位补与符号位相同的值。</p></li><li><p>移位运算符（包括重载的ＩＯ运算符），满足左结合律，且本身优先级不高不低。比算数运算符低，但比关系运算符、赋值运算符还有条件运算符优先级高。</p></li></ol><h1 id="运算符的求值顺序"><a href="#运算符的求值顺序" class="headerlink" title="运算符的求值顺序"></a>运算符的求值顺序</h1><p>我们都知道运算符有优先级、结合律还有求值顺序。这三者共同决定代码的确切执行。但是其中优先级与结合律都是比较清晰地，但是求值顺序这个属性一直不是很清晰。其实这是有原因的，很多运算符求值顺序都没有明确规定，据统计，明确规定了求值顺序的运算符只有４种运算符。</p><ol><li><p><code>逻辑与(&amp;&amp;)</code>：满足<strong>短路求值</strong>。<code>a &amp;&amp; b</code>首先判断a是否为<code>true</code>，只有在a为<code>true</code>的前提下才会对b进行求值，否则直接返回<code>false</code>;</p></li><li><p><code>逻辑或(||)</code>：满足<strong>短路求值</strong>。<code>a || b</code>首先判断a是否为<code>false</code>，只有在a为<code>false</code>的前提下才会对b进行求值，否则直接返回<code>true</code>；</p></li><li><p><code>条件(?:)运算符</code>：比如<code>a? c:d</code>首先对ａ进行求值，当ａ为<code>true</code>时，接下来对ｃ进行求值；当ａ为<code>false</code>时，接下来对ｄ进行求值；</p></li><li><p><code>逗号运算符(,)</code>：比如<code>a=0,b=1;</code>首先对左侧表达式(a&#x3D;0)进行求值，然后将求值结果(0)丢弃，对右侧表达式（ｂ&#x3D;1）进行求值，并返回右侧表达式的求值结果（１）；</p></li></ol><h1 id="除法操作符（-x2F-）与取余操作符（％）"><a href="#除法操作符（-x2F-）与取余操作符（％）" class="headerlink" title="除法操作符（&#x2F;）与取余操作符（％）"></a>除法操作符（&#x2F;）与取余操作符（％）</h1><blockquote><p>如果ｍ与ｎ是整数，并且ｎ非０,则表达式<code>(m/n)*n+m%n</code>的结果与ｍ相等。</p></blockquote><h3 id="表达式m-n"><a href="#表达式m-n" class="headerlink" title="表达式m/n"></a>表达式<code>m/n</code></h3><ol><li>参与运算的ｍ与ｎ可以是任意实数，但ｎ非０；</li><li>整数相除时所得结果还是整数，也就是说，若商中含有小数部分，直接丢弃，即向０取整。</li></ol><h3 id="表达式m-n-1"><a href="#表达式m-n-1" class="headerlink" title="表达式m%n"></a>表达式<code>m%n</code></h3><ol><li>参与运算的ｍ与ｎ<strong>一定得是整数</strong>，且ｎ不能等于０；</li><li>如果<code>m%n</code>的结果不为０，则其符号与ｍ相同，与ｎ无关，即<code>m%(-n)等于m%n，(-m)%n等于-(m%n)</code>（此例中ｍ与ｎ都为正整数）；</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] C++ Primer（第5版）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c与c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言中的变长数组与零长数组</title>
    <link href="/2018/08/29/2018-08-29-c-ArrayOfVariableLength/"/>
    <url>/2018/08/29/2018-08-29-c-ArrayOfVariableLength/</url>
    
    <content type="html"><![CDATA[<p>编程确实是需要在实践中提高，这段时间一直在学习ｃ++，同时刷刷leetcode。遇到了很多问题，也搞清楚了很多原本模糊不清的概念，今天主要写一下ｃ语言中的变长数组与零长数组。尤其是其中的变长数组，可是困扰了我一段时间了。</p><h1 id="c语言中的变长数组"><a href="#c语言中的变长数组" class="headerlink" title="c语言中的变长数组"></a>c语言中的变长数组</h1><p>想必很多学习c++的人都会在书上看到，数组在初始化时一定得确定维度，也就是说定义数组时，维度一定要用常量。但是在编程中很多人肯定发现了，如下程序也能正常运行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> size;<br>cin&gt;&gt;size;<br><span class="hljs-type">int</span> data[size];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++)<br>cin&gt;&gt;data[i];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是怎么回事？难道以前我学的是错的吗？当然不是。这个问题需要仔细说明一下。</p><p>在ｃ++的标准中确实规定了：定义数组时，元素个数必须确定，因此维度一定要用常量。上面的程序之所以能编译运行成功，是因为<strong>c++11对c99的编译器扩展</strong>。</p><blockquote><p>c99中引入了变长数组的概念，在<a href="https://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html">ｃ99的技术手册</a>中说明了数组的长度可以为变量的，称为变长数组（VLA，variable length array）。（注：这里的变长指的是数组的长度是在运行时才能决定，但一旦决定在数组的生命周期内就不会再变。）</p></blockquote><blockquote><p>在 GCC 标准规范的 6.19 Arrays of Variable Length 中指出，作为编译器扩展，GCC 在 C90 模式和 C++ 编译器下遵守 ISO C99 关于变长数组的规范。</p></blockquote><p>变长数组肯定是有好处的，它可以实现与<code>alloca</code>一样的效果，在栈上进行动态的空间分配，并且在函数返回时自动释放内存，无需手动释放。但是记住，<strong>这个是c99的标准，不是c++的</strong>，也就是说有的ｃ++编译器上并不支持。而且<strong>谷歌的c++编程规范</strong>中说:</p><p>![c++](&#x2F;assets&#x2F;img&#x2F;array_length&#x2F;googlecpp.png)</p><blockquote><p>注意：其实变长数组与<code>alloca()</code>函数，这两种<strong>在栈空间上进行动态的内存分配</strong>本身是很酷的一件事，这部分内存函数返回时自动释放，而且运行效率很高。但是目前并未得到广泛引用，而且在很多平台上没有得到支持，因此可移植性很差。因此，不推荐在一些项目开发中使用，平时刷刷leetcode时使用倒是无伤大雅。</p></blockquote><h1 id="c语言中的零长数组"><a href="#c语言中的零长数组" class="headerlink" title="c语言中的零长数组"></a>c语言中的零长数组</h1><blockquote><p>首先说明，零长数组在ISO C与C++的规格说明书中是不允许的，gcc 为了预先支持C99的这种玩法，所以，让“零长度数组”这种玩法合法了。关于GCC对于这个事的文档在这里：“<a href="https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html">Arrays of Length Zero</a>”。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span>&#123;</span><br><span class="hljs-type">int</span> length;<br><span class="hljs-type">char</span> data[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>如上定义了一个结构体，其中第二个元素为一个长度为零的数组。</p><p>学习过ｃ语言的同学都知道数组，但是长度为０的数组你们可能很少看到。这样有什么用处呢？其实这样做是为了使得这个结构体的长度可以随着程序动态的变化，十分的灵活，比如如下形式使用这个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span> *<span class="hljs-title">exa</span> =</span> (<span class="hljs-keyword">struct</span> line *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> line)+<span class="hljs-number">10</span>);<br>exa-&gt;length = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>其中，第一个元素<code>length</code>标志着下面数据的长度。<code>sizeof(struct line)</code>的结果为<code>sizeof(int)</code>，因为另一个元素零长数组不占空间，<strong>数组名data是一个指针常量，标识着成员变量<code>length</code>后面的那个地址，但其本身并不占空间</strong>。</p><p>这与下面这种形式的结构体是有区别的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span>&#123;</span><br><span class="hljs-type">int</span> length;<br><span class="hljs-type">char</span> *data;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个结构体中，<code>sizeof(struct line)</code>的结果为<code>sizeof(int)+sizeof(char *)</code>。</p><p>第一种的方法会有一些好处：</p><ol><li>方便内存释放。比如在我们为别人提供的函数接口中返回了一个结构体。如果是第二种结构体，其实在结构体的构造中是进行了两次的内存分配的，一次是为line这个结构体进行的内存申请，一次是为<code>line-&gt;data</code>这个指针指向的内存进行的内存申请。这时我们如果要进行这部分的内存释放，其实是需要分先后进行两次内存释放的。但是如果是第一种结构体，只需要释放(free)一次就行。本来对于这个结构体的构建者来说，这不是什么问题，但是对于仅仅是调用这个函数获取一个结构体的人来说，他们会方便很多。而且我们也不能指望着用户自己发现需要对这个数据结构进行两次free。</li><li>这样有利于访问速度。连续的内存有益于提高访问速度，也有益于减少内存碎片。（其实，我个人觉得也没多高了，反正你跑不了要用做偏移量的加法来寻址）</li></ol><p>最后附一个完整代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span> &#123;</span><br>   <span class="hljs-type">int</span> length;<br>   <span class="hljs-type">char</span> contents[<span class="hljs-number">0</span>]; <span class="hljs-comment">// C99的玩法是：char contents[]; 没有指定数组长度</span><br>&#125;;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> this_length=<span class="hljs-number">10</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span> *<span class="hljs-title">thisline</span> =</span> (<span class="hljs-keyword">struct</span> line *)<span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> line) + this_length);<br>    thisline-&gt;length = this_length;<br>    <span class="hljs-built_in">memset</span>(thisline-&gt;contents, <span class="hljs-string">&#x27;a&#x27;</span>, this_length);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码的意思是：我想分配一个不定长的数组，于是我有一个结构体，其中有两个成员，一个是length，代表数组的长度，一个是contents，代表数组的内容。后面代码里的this_length（长度是10）代表是我想分配的数据的长度。（这看上去是不是像一个C++的类？）这种玩法英文叫：Flexible Array，中文翻译叫：<strong>柔性数组</strong>。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] c和指针</li><li>[2] C++ Primer（第5版）</li><li>[3] <a href="http://dev.kecq.com/artic-99677605.html">http://dev.kecq.com/artic-99677605.html</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c与c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言与c++语言中关键字auto的使用</title>
    <link href="/2018/08/26/2018-08-26-auto-c-cpp/"/>
    <url>/2018/08/26/2018-08-26-auto-c-cpp/</url>
    
    <content type="html"><![CDATA[<p>最近一直在读c++方面的书籍，虽然每天看的页数不多，但是收获很多，我时间不是很充裕，只能挑拣着一点我觉得我已经掌握的还可以了，有一定把握写好的记录下来。之前写了两篇博客都是讲解c++与C中的一些关键字的差别，这一篇也是，讲的是关键字auto在c与c++中的差异。</p><h1 id="c语言中的auto"><a href="#c语言中的auto" class="headerlink" title="c语言中的auto"></a>c语言中的auto</h1><p>大家都学过ｃ语言，但是可能很多人都不知道ｃ语言中还有个关键字叫做auto。其实很正常，这个关键字在ｃ语言中确实没什么存在感。在讲解之前，我们先来了解一下ｃ语言中变量的存储类型。</p><h3 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h3><p>变量的存储类型是指存储变量值的内存类型。变量的内存类型决定了变量何时创建、何时销毁、以及它的值将保持多久。</p><p>一般有三个地方可以存储变量：静态普通内存、运行时堆栈、硬件寄存器。</p><ol><li>其中静态变量存储在静态普通内存，这种变量在程序运行之前创建，在程序的整个执行期间始终存在。它始终保持原先的值，除非赋给它一个不同的值或者程序结束。</li><li>自动变量存储在堆栈中，代码块中的变量在缺省情况下就是自动变量。在程序执行到声明自动变量的代码块时，自动变量才创建，当程序执行离开该代码块时，这些自动变量便会自行销毁。</li><li>寄存器变量存储在硬件寄存器中，需要用关键字register来声明。这种变量访问效率更高，一般用于对效率要求高的地方，同时由于寄存器有限，编译器只会理睬有限少数几个register声明，甚至不理睬（有的编译器）。寄存器变量的创建与销毁和自动变量相同，但它需要一些额外操作，在一个使用寄存器变量的函数返回之前，这些寄存器先前存储的值需要恢复，确保调用者的寄存器变量未被破坏。</li></ol><h3 id="auto的作用"><a href="#auto的作用" class="headerlink" title="auto的作用"></a>auto的作用</h3><p>上面讲解了ｃ语言中变量的存储类型，这关auto什么事情呢？细心地人可能会发现，三种存储类型的变量中有一种叫做自动变量，auto刚好有自动的意思。这不是巧合，ｃ语言中auto关键字就是用来修饰这种类型的。</p><p>但是在ｃ语言中auto极少使用，因为代码块中的变量在缺省情况下就是自动变量。实在是找不到用它的场合。</p><h1 id="c-中的auto"><a href="#c-中的auto" class="headerlink" title="c++中的auto"></a>c++中的auto</h1><p>相比较于ｃ语言中auto关键字打酱油一般的角色，在c++中，auto关键字的地位简直是天差地别，当然，关键字的含义也是天差地别。</p><p>在c++中，auto是一种类型说明符，用它就会使编译器替我们分析表达式所属于的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span> j=i;<br></code></pre></td></tr></table></figure><p>在上述代码中，编译器会根据初始值分析并未变量j选择int类型作为初始化类型。也因为这个特性，auto定义的变量<strong>必须有初始值（不然编译器不好分析啊）</strong>。阅读相关代码时，大家可以简单的把auto替换成合适的类型说明符（比int,float等）。</p><p>在c++中，经常会将auto用于基于范围的for语句，用于遍历string对象或者vector的每个元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">&quot;some string&quot;</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : str)<br>c = <span class="hljs-built_in">toupper</span>(c);<br>cout&lt;&lt;str&lt;&lt;endl;<br></code></pre></td></tr></table></figure><p>还有一种场合，在你不知道或者不确定一个元素的类型时，比如使用迭代器时，迭代器的类型很难记，又长，可以直接用auto代替。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">auto</span> b = v.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">//代表ｖ的第一个元素</span><br></code></pre></td></tr></table></figure><p>其中auto就相当于<code>vector&lt;int&gt;::iterator</code>，明显省事了很多，而且迭代器的类型实在难记。类似的还有string和vector的size_type成员到底是什么类型一样等。</p><h3 id="题外话-decltype"><a href="#题外话-decltype" class="headerlink" title="题外话 decltype"></a>题外话 decltype</h3><p>在c++还有一个与auto功能类似的符号，就是decltype。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ci = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">decltype</span>(ci) x = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>上述代码中<code>decltype(ci)</code>返回变量ci的类型，并将ｘ声明为这种类型。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] C++ Primer（第5版）</li><li>[2] c和指针</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c与c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言与c++语言中关键字extern的使用</title>
    <link href="/2018/08/15/2018-08-15-c-cpp-extern/"/>
    <url>/2018/08/15/2018-08-15-c-cpp-extern/</url>
    
    <content type="html"><![CDATA[<p>相比static关键字，可能大家对于extern更是陌生一些。我有段时间就是这样，看到static，觉得自己好像知道一点，虽然其实是半知半解。看到extern，我通常会心里一虚，确实很陌生啊。记得查过几次，但是似乎看完就又忘记了，原因就是根本没理解。所以，在昨天把曾让自己半知半解的static关键字讲解完毕后，今天再来写曾经让我半知半解都没有的extern关键字。</p><h2 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h2><p>我们知道一个程序中的多个源文件是分别被编译，最后通过链接器将多个目标文件还有库文件链接起来才形成一个单一完整的可执行文件的。那么如果相同的标识符出现在几个不同的源文件中，它们是代表同一个实体，还是不同的实体呢？</p><p>其实，这个问题的答案是由标识符的链接属性决定的。链接属性一共有三种，分别是external（外部）、internal（内部）和none（无）。</p><ol><li>none代表没有链接属性，这种标识符有多少个声明就有多少个独立不同的实体；</li><li>internal代表内部链接，这种标识符在同一个文件内的所有声明都指向同一实体，但是位于不同源文件的多个声明代表不同实体。</li><li>external代表外部链接，这种标识符无论声明多少次，都表示同一个实体。</li></ol><p>一般缺省情况下，文件作用域定义的变量都是external属性。代码块作用域声明的变量都是none属性。同时用extern与static可以修改变量的链接属性，static只在变量缺省为external的时候可以将链接属性修改为internal。</p><h2 id="extern关键字"><a href="#extern关键字" class="headerlink" title="extern关键字"></a>extern关键字</h2><p>关于链接属性的问题，已经讲得很清楚了。按理说，只要是在代码块之外的声明，默认都是external属性。那么我们只需要在代码块里使用extern关键字来声明那些要用到的在别的源文件中定义好的的外部链接的变量不就好了。事实有这么简单吗？</p><h3 id="c中的extern"><a href="#c中的extern" class="headerlink" title="c中的extern"></a>c中的extern</h3><p>在c语言中确实就是这么简单。请看如下代码,首先是<code>a.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">char</span> a = <span class="hljs-string">&#x27;A&#x27;</span>; <span class="hljs-comment">// global variable</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">msg</span><span class="hljs-params">()</span> <br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello\n&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是<code>main.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">char</span> a;                <span class="hljs-comment">// 1.直接在文件作用域声明a，具有external属性</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;    <br>    <span class="hljs-comment">//extern char a;   // 2.在代码块中使用extern关键字修改链接属性 </span><br>    a = <span class="hljs-string">&#x27;B&#x27;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, a);<br>    <span class="hljs-comment">//(void)msg();</span><br>    msg();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述两个文件联合编译，可以通过（只是会有一个msg函数隐式声明的警告）生成可执行文件，运行可得：</p><pre><code class="hljs">B B Hello</code></pre><p>如上我们可以发现，1与2两种声明方式其实效果是一样的，都是可以达到我们想要的结果的。</p><h3 id="c-中的extern"><a href="#c-中的extern" class="headerlink" title="c++中的extern"></a>c++中的extern</h3><p>首先，c++中希望每一份代码的作用尽量清晰。所以c++中规定，定义与声明是不一样的。一个<strong>变量</strong>可以在多个文件中声明，被使用，但是，定义它的举动只能出现在一个源文件中。c++作者认为这样可以更好地支持分离式编译。</p><p>在c++中，<strong>声明</strong>使得名字为程序所知，一个文件如果想要使用别处定义的名字必须包含对那个名字的声明。而<strong>定义</strong>则负责与名字关联的实体的创建和改动。所以如果我们想要在文件之间共享一个变量，记得一定要在声明这个变量时加上<code>extern</code>关键字，告诉编译器，这个变量已经在别处定义好了，定义变量时加与不加const关键字都可以。</p><p>当然会有例外：</p><ol><li><p>如果想要在多个文件间共享一个const常量，并且这个常量的初始值不是一个常量表达式，则不论是定义还是声明，都需要加上extern关键字。</p></li><li><p>因为函数的声明与定义形式上是有区别的(有无函数体)，所以可以将<code>extern</code>关键字省去，但是不省当然也不会有问题。同时，如果函数返回值是const类型的，则不论是声明还是定义，都需要加上<code>extern</code>。</p></li></ol><blockquote><p>总结一下，如果你拿不准，加上<code>extern</code>关键字就行，肯定不会出错。</p></blockquote><p>所以可以参考一下如下代码，首先是<code>a.cpp</code>文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">char</span> a = <span class="hljs-string">&#x27;A&#x27;</span>; <span class="hljs-comment">// global variable</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">msg</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello\n&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>然后是<code>main.cpp</code>文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">char</span> a;              <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, a);<br>    <span class="hljs-built_in">msg</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将这两个源文件进行联合编译，如果是c语言，那肯定是通过了，但是c++嘛！报了两个错误！</p><ol><li>第一个错误是<code>msg这个函数未在此作用域内声明</code>，没错，c++就是这么严格，c语言的隐式声明在c++中是不存在的。</li><li>第二个错误是<code>变量a被多次定义</code>！怎么会呢，原来c++规定，如果想要声明一个变量而不是定义一个变量，一定要在变量名前添加关键字extern。必须加extern，否则就是又定义了一个a，extern关键字告诉编译器a在别处已经定义，此处只是声明。否则就是在一个程序中同时<strong>定义两个外部链接的变量</strong><code>a</code>，就会报错。</li></ol><p>然后我们将<code>main.cpp</code>文件改为如下形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> a;          <span class="hljs-comment">//1. 必须加extern，否则就是又定义了一个a，用extern的话告诉编译器a在别处已经定义，此处只是声明</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">msg</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//如果没有这个声明，会报错</span><br><span class="hljs-comment">//char a;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;    <br>    <span class="hljs-comment">//extern char a;   //2. 不同位置，作用一样，只是声明作用域不一样</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, a);<br>    <span class="hljs-built_in">msg</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以编译通过了，执行编译得到的可执行文件生成如下结果：</p><pre><code class="hljs">A Hello</code></pre><p>在c++语言中，还有两点需要注意：</p><ol><li>在头文件中只进行声明，不进行定义。这个原因是因为，包含头文件其实就是把头文件内容复制到包含的地方，如果在头文件中有定义，那每包含一次，就会定义一次，铁定炸。</li><li>一个文件如果因为需要使用某个变量而声明了它，在这个文件中千万不要对这个变量进行改动（对同一个变量的改动只能出现在一个文件中）！比如一个文件中如果有对这个赋值操作，其实就是对这个变量进行重新定义，也铁定炸。</li></ol><blockquote><p>注意！这里extern是用来进行变量的声明的，变量是一个类型的实例。因此在进行跨文件的声明时，类定义与声明并不需要用extern关键字，而一个对象的声明需要用到。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] C++ Primer（第5版）</li><li>[2] c和指针</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c与c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言与c++语言中关键字static的使用</title>
    <link href="/2018/08/14/2018-08-14-c-cpp-static/"/>
    <url>/2018/08/14/2018-08-14-c-cpp-static/</url>
    
    <content type="html"><![CDATA[<p>想必很多人对c语言的static都不是很熟悉，我有段时间就是，经常看到一些代码中这个关键词出现的频率很高，但是并不是很懂，大概的了解过几次，还是半知半解。最近在对c语言和c++进行基础重翻，终于是弄懂了这部分。</p><h2 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h2><p>我们知道一个程序中的多个源文件是分别被编译，最后通过链接器将多个目标文件还有库文件链接起来才形成一个单一完整的可执行文件的。那么如果相同的标识符出现在几个不同的源文件中，它们是代表同一个实体，还是不同的实体呢？</p><p>其实，这个问题的答案是由标识符的链接属性决定的。链接属性一共有三种，分别是external（外部）、internal（内部）和none（无）。</p><ol><li>none代表没有链接属性，这种标识符有多少个声明就有多少个独立不同的实体；</li><li>internal代表内部链接，这种标识符在同一个文件内的所有声明都指向同一实体，但是位于不同源文件的多个声明代表不同实体。</li><li>external代表外部链接，这种标识符无论声明多少次，都表示同一个实体。</li></ol><p>一般缺省情况下，代码块之外（文件作用域）定义的变量都是external属性。代码块作用域声明的变量都是none属性。同时用extern与static可以修改变量的链接属性，static只在变量缺省为external的时候可以将链接属性修改为internal。</p><h2 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h2><p>变量的存储类型是指存储变量值的内存类型。变量的内存类型决定了变量何时创建、何时销毁、以及它的值将保持多久。</p><p>一般有三个地方可以存储变量：静态普通内存、运行时堆栈、硬件寄存器。</p><ol><li>其中静态变量存储在静态普通内存，这种变量在程序运行之前创建，在程序的整个执行期间始终存在。它始终保持原先的值，除非赋给它一个不同的值或者程序结束。在代码块之外（文件作用域）的变量，缺省情况下便是静态的。</li><li>自动变量存储在堆栈中，代码块中的变量在缺省情况下就是自动变量。在程序执行到声明自动变量的代码块时，自动变量才创建，当程序执行离开该代码块时，这些自动变量便会自行销毁。</li><li>寄存器变量存储在硬件寄存器中，需要用关键字register来声明。这种变量访问效率更高，一般用于对效率要求高的地方，同时由于寄存器有限，编译器只会理睬有限少数几个register声明，甚至不理睬（有的编译器）。寄存器变量的创建与销毁和自动变量相同，但它需要一些额外操作，在一个使用寄存器变量的函数返回之前，这些寄存器先前存储的值需要恢复，确保调用者的寄存器变量未被破坏。</li></ol><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>由于不同的上下文环境，static会有不同的含义。</p><blockquote><p>当它用于<strong>函数定义，或者代码块之外（文件作用域）的变量声明</strong>时，static关键字用于修改标识符的链接属性，从external到internal，但是标识符的存储类型与作用域都不会改变。用这种方式声明的函数与变量将只能在声明他们的源文件中访问，对其它源文件隐藏。</p></blockquote><p>如下为源文件<code>a.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">msg</span><span class="hljs-params">()</span> <br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello\n&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>如下为<code>main.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;      <br>    (<span class="hljs-type">void</span>)msg();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将这两个源文件联合编译，会发现报错找不到msg()函数。</p><blockquote><p>当它用于<strong>代码块内部的变量声明</strong>时，static关键字用于修改变量的存储类型，从自动变量修改为静态变量，但变量的链接属性（还是none）与作用域（还是代码块作用域）不会受到影响。用这种方式声明的变量在程序执行之前创建，并在程序的整个执行期间一直存在。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>[1] C++ Primer（第5版）</li><li>[2] c和指针</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c与c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机中register、cache、memory的区别</title>
    <link href="/2018/07/02/2018-07-02-register-cache-memory/"/>
    <url>/2018/07/02/2018-07-02-register-cache-memory/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li>register：寄存器。cpu中的基本单元，与cpu中的运算单元是一个级别的。运算单元直接处理的数据存储器。从普通单片机到intel的cpu全都存在寄存器。</li><li>cache：缓存。一般普通MCU是没有缓存的，一些强大的个人电脑或者手机芯片才会有缓存，缓存的一般用的是<strong>SRAM静态随机存储器</strong>，速度很快。通常情况是电脑在工作时将从内存中读入的用过的数据放入缓存，以便下次用时可以快速找到它。不过cpu一般不会直接访问缓存，而是先将缓存放入寄存器，再操作。</li><li>memory：内存。一般普通MCU也是没有内存的，而且内存一般是外置的，而缓存与寄存器通常集成在cpu内部。内存一般使用<strong>DRAM动态随机存储器</strong>，速度稍慢。已经工作的cpu首先会到cache寻找自己想要的数据，如果没有才会到内存读。</li></ol><p>好比医院，医生对面的椅子就是寄存器，要看病的病人(data)就座这个椅子(register)；已经挂号的(data)进入诊室(cache)排队，其他的就在医院里（memory）。医生可以操作的就是面对面的病人，其他人要看病（如急病）也需先坐上这个位置，这是最快的。如果医生找一个人，会现在诊室(cache)里找，如果找不到，才会到医院大厅里找（memory）。</p><blockquote><p>DRAM动态随机访问存储器是集成电路形式的存储器，可随机访问任何地址的内存，花费时间基本相同。SRAM静态随机访问存储器，也是集成电路形式的存储器，比DRAM更快并且集成度更低，价格更贵。上述都是易失性存储器，掉电丢失存储内容。</p></blockquote><h2 id="访问速度差异原因"><a href="#访问速度差异原因" class="headerlink" title="访问速度差异原因"></a>访问速度差异原因</h2><ol><li>晶体管存储构造的不同是一个原因。SRAM静态随机存储器比较DRAM动态随机存储器速度更快，支持频率更高，但是也不易于把容量做的很大。</li><li>同时内存（memory）在cpu外部，距离运算单元比较远，也算是一个原因吧。</li><li>还有一个原因，就是访问方式的差异。一般寄存器（register）按位进行直接访问，速度最快；缓存（cache）与内存（memory）的访问方式一般差不多，但是缓存比较小（寻址空间小），且内存构造速度更快。</li></ol><h2 id="缓存与内存的访问方式"><a href="#缓存与内存的访问方式" class="headerlink" title="缓存与内存的访问方式"></a>缓存与内存的访问方式</h2><ol><li>找到数据的指针。（指针可能存放在寄存器内，所以这一步就已经包括寄存器的全部工作了。）</li><li>将指针送往内存管理单元（MMU），由MMU将虚拟的内存地址翻译成实际的物理地址。</li><li>将物理地址送往内存控制器（memory controller），由内存控制器找出该地址在哪一根内存插槽（bank）上。</li><li>确定数据在哪一个内存块（chunk）上，从该块读取数据。</li><li>数据先送回内存控制器，再送回CPU，然后开始使用。</li></ol><blockquote><p>现代多核处理器中会存在三级缓存（L1、L2与L3高速缓存）。如下是典型的多核心处理器的组织结构。</p></blockquote><p><img src="/img/data_store/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.JPG" alt="多核处理器的组织结构"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CPU本身只负责运算，不负责储存数据。数据一般储存在内存(memory)之中，CPU要用的时候就去内存读写数据。但是，CPU的运算速度远高于内存的读写速度，为了避免被拖慢，CPU一般都会自带一级缓存与二级缓存甚至三级缓存（cache）。基本上，CPU缓存可以看作是读写速度较快的内存。</p><p>但是，CPU缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU每次读写还需要做寻址操作，这会明显的拖慢速度。因此，除了缓存之外，CPU还自带了寄存器（register），寄存器不依靠地址区分数据，而是依靠名称来按位访问，速度最快，有的人称它为<strong>零级缓存</strong>。寄存器常常用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU优先读写寄存器，再由寄存器跟内存交换数据。</p><p><img src="/img/data_store/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.jpg" alt="存储器层次结构"></p><blockquote><p>存储器结构的基本思想是上一级的存储器作为下一级的高速缓存。即金字塔越往上，容量越小、速度越快、每字节造价越昂贵。</p></blockquote><hr><blockquote><p>在现代计算机中，数据的读写一般是严格按照存储器层次结构进行的．比如处理器的运算单元从寄存器读取数据，寄存器从缓存读取数据，缓存从内存读取数据，内存从硬盘读取数据．当运算单元需要的数据寄存器中没有时，寄存器便会从缓存中请求该数据；如果缓存中也没有该数据，缓存便会从内存中请求该数据；如果内存中也没有该数据，内存便会从硬盘上请求该数据；然后再逐层向上返回．</p></blockquote><blockquote><p>上述内存、缓存、寄存器都是易失性存储器，硬盘属于<strong>非易失性存储器</strong>。非易失性存储器主要有闪存与磁盘磁带等，闪存flash单位价格和速度均低于DRAM，高于磁盘。目前电脑中主要使用的是磁盘与固态硬盘，固态硬盘是基于闪存芯片的存储设备，使用方式与磁盘基本相同。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ResNet论文笔记</title>
    <link href="/2018/06/25/2018-06-25-resnet/"/>
    <url>/2018/06/25/2018-06-25-resnet/</url>
    
    <content type="html"><![CDATA[<h2 id="退化问题"><a href="#退化问题" class="headerlink" title="退化问题"></a>退化问题</h2><p>2013年以来cnn飞速发展，从比较简单的LeNet、AlexNet,到结构对称美观的VGGNet（经典结构之一，SegNet、SSD等都使用它作为基础网络），再到可以大量减少参数的GoogleNet（Inception），一直到本文主角ResNet的出现，它们都有一个共同的特点：网络层数在不断加深。</p><p>按理说，深度cnn网络集成了特征提取器与特征分类器，并且特征水平可以通过层数的堆砌来提升。层数越深，网络的学习能力应该越强，网络的准确度也应该越高，那只要不断加深cnn网络的层数不就好了？确实是这样的，但是，总归没有那么简单。<br><img src="/img/resnet/issue.png" alt="issue"></p><p>从上图我们可以看到，56层网络的训练错误率与测试错误率反而比20层的（在CIFAR-10上）要高。没错，<strong>传统cnn网络随心所欲的增加层数是不行的,当更深的网络开始收敛时，会出现退化问题。（层数增多，准确率反而下降，因为深层网络会出现梯度消失）</strong></p><h2 id="ResNet的做法"><a href="#ResNet的做法" class="headerlink" title="ResNet的做法"></a>ResNet的做法</h2><p>ResNet为了解决cnn网络层数增加，学习能力反而下降的问题，提出了一种 residual 结构。<br><img src="/img/resnet/residual.png" alt="residual"></p><p>如上图，增加了一个恒等映射（identity mapping），将原始需要学习的函数<code>H(X)</code>转换成<code>F(x)+x</code>。作者认为对残差<code>F(x)</code>做优化会比直接对<code>H(x)</code>做优化要简单很多。这个公式的实现是通过上图的<code>shortcut connections</code>，这并不会增加额外参数和计算复杂性。</p><p>其中，<code>H(x) = y = F(x)+x</code>,<code>F(x)</code>为要学习的残差映射。但是，我们都知道输入与输出的维度很有可能会发生变化，因此<code>shortcut</code>的方式，需要认真考虑。针对深度增加的情况，论文中提出了两种解决方法：</p><ol><li>zero_padding:依然是恒等映射，对于增加的层填充0,这样不会有额外的参数;</li><li>projection:采用<code>1×1</code>卷积核来增加维度。</li></ol><h2 id="实际效果"><a href="#实际效果" class="headerlink" title="实际效果"></a>实际效果</h2><p>如下图，为普通 VGG-19 网络与34层普通cnn网络还有34层的残差网络结构图：<br><img src="/img/resnet/net.png" alt="net"></p><p>结果对比</p><p><img src="/img/resnet/result.png" alt="result"></p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>我们可以发现， ResNet 确实有效的解决了深度网络的退化问题。</p><p>但是虽然 ResNet 在深度网络的退化问题上取得了一定的效果，但是参数数量是不变的。这使得 ResNet 工作在更高的层数时依然吃力。为了减少参数数量，提高效率，作者又提出了以下结构：</p><p><img src="/img/resnet/newres.png" alt="newres"></p><p>使用<code>1×1</code>卷积核来分别进行降维与升维，使得<code>3×3</code>卷积核工作在较低维度，大大减少参数数量，作者基于此又提出了 ResNet 的50、101、152层网络。</p><h2 id="ResNet原理探讨"><a href="#ResNet原理探讨" class="headerlink" title="ResNet原理探讨"></a>ResNet原理探讨</h2><p>纵观全文，作者在引入新的结构时几乎没有进行原理上的分析，用到最多的词反而是：实验结果表明。ResNet是不可解释的吗？其实不然，下面就将尝试进行解释。</p><p>深层网络会出现梯度消失的问题，进而导致退化现象的产生。梯度消失的出现主要是由神经网络的求解方式—梯度下降法导致的，在进行梯度链式求导时，由于每一层梯度求导的值都会很小，当层数很深依次链式求导时，就会出现梯度消失。</p><p>而残差网络中，会有一条identity分支。<code>H(x) = F(x) + x</code>在反向传播求导(此处是对x求导)时，会得到<code>(1 + F&#39;(x)) d H(x)</code>，此式可以保证与<code>d H(x)</code>保持在一个数量级，从而有效的减小了梯度消失。</p><p>另外，有一篇论文认为残差网络就是大量的不同长度的神经网络组成的组合函数，从而可以有效缓解梯度消失。</p>]]></content>
    
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DHCP 实现动态 IP 上网简析</title>
    <link href="/2018/06/22/2018-06-22-dhcp/"/>
    <url>/2018/06/22/2018-06-22-dhcp/</url>
    
    <content type="html"><![CDATA[<p>首先，我们需要知道计算机是如何上网的。</p><p>计算机之间的通信是建立在五层架构上的，一台计算机要想实现与互联网中另外一台台计算机之间的通信，计算机至少需要知道下面四个参数：</p><pre><code class="hljs">*本机的IP地址*子网掩码*网关的IP地址*DNS服务器的IP地址</code></pre><p><strong>其中本机的 IP 地址和子网掩码</strong>的作用与来历已经在<a href="https://xhy3054.github.io/computer-network-overview/">互联网分层结构实现</a>博客中说明了。</p><p><strong>网关的 IP 地址</strong>也是必须知道的，这个是因为一般情况下我们访问的主机都和我们不在一个子网中。所以需要把数据包先发给本机所处子网的网关，再由网关转发给目标主机（一般情况一次通信会转发很多次，直到抵达目标主机）。大致如下图示：<br><img src="/img/dhcp/gateway.jpg" alt="gateway"></p><p><strong>DNS 服务器的 IP 地址</strong>也是必须知道的，因为我们一般直接获得的都是域名，比如（<a href="http://www.google.com).dns/">www.google.com）。DNS</a> （域名系统）协议的作用是将域名转换成 IP 地址，我们向 DNS 服务器发送 DNS 数据包， DNS 服务器会做出响应告知我们该域名对应的 IP 地址是多少。</p><p>知道了上述四个参数，一台计算机就可以上网了。</p><h2 id="静态-IP-上网"><a href="#静态-IP-上网" class="headerlink" title="静态 IP 上网"></a>静态 IP 上网</h2><p>大家都用过 Windows 系统，想必对于这个界面应该不会陌生</p><p><img src="/img/dhcp/static.png" alt="static"></p><p>这是windows系统的一个设置窗口，可以指定上网必需的四个参数。指定以后，每次开机都会固定同样的 IP 地址，因此这种上网方式被称为<strong>静态 IP 上网</strong>。</p><p>但是，我们可以发现这种设置是具备一定专业性的。连上网线，我们还需要知道所处子网的网关 IP、子网掩码、固定可用不会被占用的本机 IP、还有可访问的 DNS 服务器 IP。可以说相当专业了。而且这样做了以后，此台电脑的 IP 地址会保持不变，其他电脑就不能使用了，会使得资源利用不够灵活。所以现在基本上大家都是采用动态 IP 上网。</p><h2 id="动态-IP-上网"><a href="#动态-IP-上网" class="headerlink" title="动态 IP 上网"></a>动态 IP 上网</h2><p>所谓的动态 IP 上网，就是开机连上网线后，会自动分配到一个可用的 IP 地址，不需要再认为设定，这样就方便了好多。它使用了 DHCP 协议。</p><h3 id="DHCP-协议（Dynamic-Host-Configuration-Protocol）"><a href="#DHCP-协议（Dynamic-Host-Configuration-Protocol）" class="headerlink" title="DHCP 协议（Dynamic Host Configuration Protocol）"></a>DHCP 协议（Dynamic Host Configuration Protocol）</h3><p>这是一种应用层协议，建立在 UDP 协议之上，整个数据包如下：<br><img src="/img/dhcp/dhcp.png" alt="dhcp"></p><p>其中协议规定：</p><ol><li>最前面的以太网标头，设置发出方（本机）的 MAC 地址和接收方（DHCP服务器）的 MAC 地址。前者是本地网卡的 MAC 地址，后者此时尚不知，就填入一个广播地址：<code>FF-FF-FF-FF-FF-FF</code>。</li><li>接下来的 IP 标头，设置发出方的 IP 地址与接收方的 IP 地址。这是，这些都还不知道，于是发出方的 IP 地址设置为<code>0.0.0.0</code>，接收方的 IP 地址设置为<code>255.255.255.255</code>。</li><li>最后的 UDP 标头，设置发出方的端口和接收方的端口。这一部分 DHCP 协议规定好的是，发出方是68端口，接收方是67端口。</li></ol><p>数据包构造完成后便可以发出了。这是是以太网广播发送，同一个子网络的每台计算机都会收到这个包。因为接收方地址为<code>FF-FF-FF-FF-FF-FF</code>，看不出是发给谁的，于是每台收到此包的计算机还必须再分析这个包的 IP 地址。当看到发出方为<code>0.0.0.0</code>，接收方为<code>255.255.255.255</code>时， DHCP 服务器便知道是发给自己的包，而其他计算机会丢弃这个包。</p><p>然后，DHCP 服务器读出这个包，履行自己的职能，分配好一个 IP 地址，并发送一个 DHCP 响应包。这个响应包的相关设置类似，以太网标头为双方 MAC 地址， IP 标头 发送方为 DHCP 服务器 IP 地址，接收方为<code>255.255.255.255</code>。 UDP 端口为 67 （发出方）和 68 （接收方），<strong>分配给请求项的 IP 地址和本网路的具体参数</strong>包含在数据部分。</p><h3 id="动态上网全流程总结"><a href="#动态上网全流程总结" class="headerlink" title="动态上网全流程总结"></a>动态上网全流程总结</h3><ol><li>电脑开机，接上网线，连入网络;</li><li>利用 DHCP 协议动态获取本机 IP 与本网络参数（子网掩码、网关IP、DNS的IP等）;</li><li>打开浏览器，输入<code>www.google.com</code>并回车;</li><li>利用 DNS 协议获得<code>www.google.com</code>的 IP ;</li><li>将数据包依次通过互联网的五层架构发送出去，并接收返回数据屏幕显示，完成一次网络通信。<br><img src="/img/dhcp/surf.jpg" alt="surf"></li></ol><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html">http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互联网分层结构实现</title>
    <link href="/2018/06/21/2018-06-21-computer-network-overview/"/>
    <url>/2018/06/21/2018-06-21-computer-network-overview/</url>
    
    <content type="html"><![CDATA[<p>本科时不是计算机专业，虽然学过计算机网络之类的课程，但是不上心，也没学懂。</p><p>自己看了些计算机网络方面的资料也做过些项目，算是一知半解，前些日子读了<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">阮老师的一篇博客</a>，真是通俗易懂。趁着现在有时间，边回忆边写出自己的学习笔记。</p><h2 id="一、五层模型"><a href="#一、五层模型" class="headerlink" title="一、五层模型"></a>一、五层模型</h2><p>互联网的分层有 OSI 的七层模型和 TCP&#x2F;IP 的五层模型，本质上实现的功能大同小异，只不过五层模型更加精简一些。这篇博客就是在五层模型的基础上进行分析。 </p><p><img src="/img/network/tcp_model.png" alt="tcp_model"></p><p>如上图所示，其中每一层都是为了实现不同的功能，为了实现这些功能，就需要大家（通信双方）都遵守共同的规则，这些规则就是协议。互联网每一层都有很多协议，它们加起来就叫做<strong>互联网协议（Intelnet Protocol Suite）</strong>。五层模型中，越下面的层，越靠近硬件;越上面的层，越靠近用户。</p><h2 id="二、物理层（Physical-Layer）"><a href="#二、物理层（Physical-Layer）" class="headerlink" title="二、物理层（Physical Layer）"></a>二、物理层（Physical Layer）</h2><p>物理层是最底下的一层，负责实现的是将电脑之间连接起来的物理实现。比如可以用光缆、电缆、双绞线、无线电波等方式。<strong>它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号</strong></p><p><img src="/img/network/phy_layer.png" alt="phy_layer"></p><h2 id="三、链接层（Link-Layer）"><a href="#三、链接层（Link-Layer）" class="headerlink" title="三、链接层（Link Layer）"></a>三、链接层（Link Layer）</h2><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p>首先我们知道，下一层物理层负责的是传递0和1的电信号，但是单纯的0和1是没有任何意义的，必须为它们规定解读方式：比如多少个电信号算一组？每个信号位代表了什么意义？</p><p>上述就是<strong>链接层</strong>的功能，它在<strong>物理层</strong>上方，确定0和1的分组方式，也就是说电脑在物理层收到电信号后，是在链接层将这些0和1信号转换成一个个数据包的格式。当然，它还有其他深层作用，马上会讲。</p><h3 id="3-2-以太网协议"><a href="#3-2-以太网协议" class="headerlink" title="3.2 以太网协议"></a>3.2 以太网协议</h3><p>本来在早期的时候，几乎每家公司都有自己的电信号分组方式。后来逐渐的，一种叫做<strong>以太网（Ethernet）</strong>的协议，占据了主导地位。</p><p>在以太网协议中规定，一组电信号构成一个数据包，叫做<strong>帧（Frame）</strong>。每一帧分成两个部分：帧头（Head）与数据（Data）。如下：</p><p><img src="/img/network/link.png" alt="link"></p><p>其中，Head 中包含了数据包的一些说明项，比如发送者、接受者、数据类型等等; Data 则是数据包的具体内容。</p><p>Head 的长度，固定为18字节。Data 的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p><h3 id="3-3-MAC地址"><a href="#3-3-MAC地址" class="headerlink" title="3.3 MAC地址"></a>3.3 MAC地址</h3><p>上面提到，以太网数据包中的 Head ，包含了发送者和接收者的信息。那么，发送者与接受者是如何标识的呢？</p><p>以太网规定，连入网络的所有设备，都必须具有“网卡接口”。数据包必须是从一块网卡，传送到另一块网卡的。网卡具有地址，就是 MAC 地址，可作为接收与发送地址。</p><p><img src="/img/network/wangka.jpg" alt="wangka"></p><p>上图为一网卡照片，每块网卡在出厂时，都会拥有一个MAC地址，长度是48个二进制位，通常用12个十六进制数表示。如下</p><p><img src="/img/network/mac.png" alt="mac"></p><p>前6个十六进制是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡与数据包的路径了。按理说，每一个 MAC 地址应该是独一无二的。但是事实并不是这样。不过一般情况下，我们很少会遇到两个网卡MAC地址一样的情况（概率很小），如果遇到了，只要两个设备不在一个子网也不会有什么影响。如果遇到了，还在同一个子网中，那么有两种解决方案：</p><ol><li>网卡厂商提供有配置程序，可以直接修改硬件 MAC 地址。</li><li>操作系统会提供伪造MAC地址的方式来解决冲突。</li></ol><h3 id="3-4-因特网基于MAC地址的信息传播方式"><a href="#3-4-因特网基于MAC地址的信息传播方式" class="headerlink" title="3.4 因特网基于MAC地址的信息传播方式"></a>3.4 因特网基于MAC地址的信息传播方式</h3><p>在这里需要提前说明一下，链路层的以太网基于 MAC 地址进行通信是只能实现子网内的通信的。即两台电脑需要在一个子网内。</p><p>定义了地址只是第一步，下面一块网卡如何知道另一块网卡的MAC地址呢？</p><p>回答是通过 ARP 协议来解决这个问题的，这个协议建立在网络层协议的基础上，过会儿会在网络层部分进行解释。</p><p>其次我们需要考虑的是就算有了 MAC 地址，系统如何日才能把数据包准确送到接收方呢？</p><p>回答是以太网采用了很<strong>原始</strong>的一种手段，它并不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己进行判断，自己是否为接收方。</p><p><img src="/img/network/boardcast.png" alt="boardcast"></p><p>上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。</p><h3 id="3-5-小节"><a href="#3-5-小节" class="headerlink" title="3.5 小节"></a>3.5 小节</h3><p>讲到这里，我们发现，链路层可以将物理层传来的0和1信号转成数据包的格式，并能通过网卡的 MAC 地址，实现一个子网内多台计算机之间的数据传送了。</p><h2 id="四、网络层（Network-Layer）"><a href="#四、网络层（Network-Layer）" class="headerlink" title="四、网络层（Network Layer）"></a>四、网络层（Network Layer）</h2><h3 id="4-1-网络层的由来"><a href="#4-1-网络层的由来" class="headerlink" title="4.1 网络层的由来"></a>4.1 网络层的由来</h3><p>从上文我们知道，到链路层已经可以实现子网内设备间的通信了，但是不同子网里的设备还不能通信。因为首先我们知道一个子网不可能将所有的设备都包含进去，互联网是一个由无数子网络共同组成的一个巨型网络。</p><p><img src="/img/network/int.png" alt="int"></p><p>如图，因此首先需要找到一种方法可以区分两个机器是否属于同一个子网，如果是，那就直接<strong>广播</strong>方式（上一节中提到的发送方式）发送就可以了。如果不是，就采用<strong>路由</strong>方式发送（路由方法本博客暂不涉及）。遗憾的是，MAC 地址本身无法做到这一点，因为它只与厂商有关，与所处网络无关。</p><p><strong>由此导致了网络层的诞生，它的做法是引入一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址叫做网络地址，简称网址</strong>。</p><p>于是，网络层的诞生使得每台计算机有了两个地址，一个是 MAC 地址，一个是网络地址。它们之间没有任何联系，MAC 地址绑定在网卡上，网络地址则是管理员分配的，它们只是随机的组合在了一起。</p><p>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p><h3 id="4-2-IP协议"><a href="#4-2-IP协议" class="headerlink" title="4.2 IP协议"></a>4.2 IP协议</h3><p>规定网络地址的协议叫做IP协议。它所定义的地址，被称为IP地址。</p><p>目前在我国，广泛采用的是IP协议第四版，简称 IPv4 。这个版本规定，网络地址由32个二进制位组成。<br><img src="/img/network/ip.png" alt="ip"></p><p>习惯上，我们会将其分成四段的十进制数表示。从0.0.0.0一直到255.255.255.255。</p><p>互联网上每一台计算机都会分配到一个 IP 地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。</p><p>但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。</p><p>那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数<strong>子网掩码（subnet mask）</strong>。</p><p>所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p><p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。这里网络是分级的，不会出现错误的检测，等到我以后对于这一块理解的更加透彻了，会再专门写一篇博客进行说明。这里只需要理解到这里就足够了。</p><p>比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。</p><p>总结一下，<strong>IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</strong></p><p>有了网络层、链路层、物理层，我们已经可以实现世界上接入互联网上任意两台机器的互联<br>互通了。</p><h3 id="4-3-IP数据包"><a href="#4-3-IP数据包" class="headerlink" title="4.3 IP数据包"></a>4.3 IP数据包</h3><p>根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定会包含IP地址信息。前文说过以太网数据包的格式，而IP数据包正是占据了以太网数据包的数据部分。</p><p>这充分体现了互联网分层的优势：上层的变动完全不会影响下层的结构。比如，数据链路层使用了以太网协议，网络层即可以使用 IP 协议，即把 IP 数据包塞入以太网数据包的数据部分，也可以使用其他种类的网络层协议替换 IP 协议，即将其他种类的网络层协议数据包塞入以太网数据包的数据部分。</p><p>具体来说，IP 数据包也分为包头与数据两个部分。<br><img src="/img/network/ip1.png" alt="ip1"></p><p>包头部分主要包括版本、长度、IP 地址等信息，数据部分则是 IP 数据包的具体内容。将 IP 数据包放入以太网数据包后，以太网数据包就变成了如下这样。</p><p><img src="/img/network/int1.png" alt="int1"></p><p>IP 数据包的包头部分的长度为20到60字节，整个数据包的总长度最大为65535字节。因此，理论上，一个 IP 数据包的数据部分，最长为65515字节。前面讲过，以太网数据包的数据部分，最长只有1500字节。因此，如果 IP 数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p><h3 id="4-4-APR-协议"><a href="#4-4-APR-协议" class="headerlink" title="4.4 APR 协议"></a>4.4 APR 协议</h3><p>讲到这里，我们知道，如果想要实现两台计算机的通信，我们必须同时知道两个地址，一个是对方的 MAC 地址，另一个是对方的 IP 地址。通常情况下，对方的 IP 地址是已知的（一般通过 DNS 协议获得），而 MAC 地址，我们一般通过 APR 协议获得。</p><p>其实这里是分两种情况的，一种情况是，两台机器不在同一个子网络，这时是无法得到对方的 MAC 地址的，只能把数据包发送给网关，让网关去处理。</p><p>另一种情况，两台计算机处于同一个子网络，那么我们就可以使用 APR 协议了，得到对方的 MAC 地址。</p><p>APR 协议（基于 IP 协议）是这么做的，发送一个数据包（包含在以太网数据包中），其中包含它所要查询的主机的 IP 地址，在对方的 MAC 地址一栏填<code>FF：FF：FF：FF：FF：FF</code>，这表示一个广播地址。即子网络的每个主机收到这个包都要这样做：从中取出 IP 地址，与自身的 IP 地址进行比对。如果两者相同，做出回应，向对方报告自己的 MAC 地址，否则丢弃这个包。</p><p>有了 APR协议之后，我们就可以查询得到子网内任意机器的 MAC 地址了。一般情况下只有第一次通信时才会需要查询，以后会将用过的 MAC 地址缓冲下来，下次直接本地查找缓冲，没有才会广播查询。</p><h3 id="4-5-小节"><a href="#4-5-小节" class="headerlink" title="4.5 小节"></a>4.5 小节</h3><p>有了网络层、链路层、物理层，我们已经可以实现世界上接入互联网上任意两台机器的互联互通了。</p><h2 id="五、传输层"><a href="#五、传输层" class="headerlink" title="五、传输层"></a>五、传输层</h2><h3 id="5-1-传输层的由来"><a href="#5-1-传输层的由来" class="headerlink" title="5.1 传输层的由来"></a>5.1 传输层的由来</h3><p>由上节我们知道，有了网络层、链路层、物理层，我们已经可以实现世界上接入互联网上任意两台机器的互联互通了。但是，同一台主机上有很多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当收到一个数据包时，你需要判断它表示的是网页的内容还是在线聊天的内容。</p><p>于是，传输层诞生了。<strong>网络层实现的是主机与主机之间的通信，传输层实现的是程序与程序间的交流。</strong></p><p>在传输层中，表示一个数据包到底供哪个程序使用的参数叫做<strong>端口（port）</strong>。它的本质更像是使用网卡的程序的编号。每个数据包都发送到主机的特定端口，所以不同程序可以取走自己所需要的数据。</p><p>端口是0到65535之间的一个整数，刚好16个二进制位。其中0到1023端口被系统占用，用户只能选择大于1023的端口。</p><p>网络层定义主机位置，传输层定义端口位置。确定了主机与端口，便能实现程序之间的交流。因此，在 Unix 系统中，把<code>主机+端口</code>叫做<strong>套接字（socket）</strong>。有了它，便可以进行网络应用程序的开发了。</p><p>下面讲讲两个传输层协议，UDP 协议与 TCP 协议。</p><h3 id="5-2-UDP-协议"><a href="#5-2-UDP-协议" class="headerlink" title="5.2 UDP 协议"></a>5.2 UDP 协议</h3><p>UDP 协议就是在数据包中加入了端口信息，它也是标头+数据的格式，如下：<br><img src="/img/network/udp.png" alt="udp"></p><p>其中， Head 部分主要定义了发出端口和接收端口， Data 部分是具体的内容。将整个 UDP 数据包放入 IP 数据包的数据部分，结合前面说的，IP 数据包放进以太网数据包的数据部分，最后整个以太网数据包是这个样子的：<br><img src="/img/network/int2.png" alt="int2"></p><p>UDP 数据包十分简单， Head 部分一共只有8个字节，总长度不超过65535字节。</p><h3 id="5-3-TCP-协议"><a href="#5-3-TCP-协议" class="headerlink" title="5.3 TCP 协议"></a>5.3 TCP 协议</h3><p>UDP 协议简单有效，容易实现，但是可靠性差，因为一旦它的数据包发出，无法确定对方能否收到。</p><p>为了解决这个问题，提高网络可靠性， TCP 协议诞生了。这个协议十分复杂，此处可以简单的认为，它是有确认机制的 UDP 协议，即它的每一个数据包发出后，都会收到一个 ACK 响应包。如果一个数据包丢失，就收不到 ACK，发出方就知道有必要重新发送这个数据包了。</p><p>因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p><p>TCP 数据包与 UDP 数据包一样内嵌在 IP 数据包的 Data 部分。 TCP 数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常 TCP 数据包的长度不会超过 IP 数据包的长度，以确保单个 TCP 数据包不必再分割。</p><h2 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层"></a>六、应用层</h2><p>上节中提到，传输层可以使得应用程序之间进行数据传输。这时，我电脑上的应用程序接收到了数据包，并逐层去掉包头，最后只剩下一个数据部分。<strong>应用层的作用就是规定应用程序的数据格式。使得客户端可以将收到的数据包转换成自己想要的格式，并呈现给用户。</strong></p><p>举例来说，通过 TCP&#x2F;IP 协议，各种各样的程序可以传递数据，比如 Email、WWW、FTP等等。应用层的各种程序协议便规定了电子邮件、网页、 FTP 数据的格式，这些应用程序共同构成了应用层。</p><p>应用层是最高的一层，直接面向用户。它的数据就放在 TCP 数据包的数据部分。因此，最终的以太网数据包是如下格式的。</p><p><img src="/img/network/int3.png" alt="int3"></p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>上面就是对互联网整个分层结构的解析，总结一下，一台主机在发出一个数据包时需要经历一下步骤：</p><ol><li>应用层将数据信息按照标准的格式（如http报文的格式）组织好，然后向下给到传输层;</li><li>传输层为应用层的数据包添加包头（比如UDP就是端口信息），变成 UDP 数据包格式，向下给到网络层;</li><li>网络层为传输层的数据包添加包头（ip地址等信息），组装成 IP 数据包的格式，向下给到链路层;</li><li>链路层为网络层的数据包添加包头（MAC地址等信息），组装成 以太网数据包的格式，向下给到物理层;</li><li>物理层将以太网数据包转换成0和1电信号，发出去。</li></ol><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>阮一峰老师的博客<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Inception概念解析</title>
    <link href="/2018/06/20/2018-06-20-Inception/"/>
    <url>/2018/06/20/2018-06-20-Inception/</url>
    
    <content type="html"><![CDATA[<h2 id="Inception-由来"><a href="#Inception-由来" class="headerlink" title="Inception 由来"></a>Inception 由来</h2><p>2014年，<strong>GoogLeNet</strong>在ImageNet竞赛上击败<strong>VGGNet</strong>一举夺魁。其中，GooLeNet首次提出Iception结构，早期的Iception-v1结构借鉴了NIN（Network in Network）的设计思想，对网络的传统卷积层进行了修改，并一直改进到v4,改进过程中主要是针对以下限制神经网络性能的主要问题：</p><ol><li>参数空间大，容易过拟合，且训练数据集有限;</li><li>网络结构复杂，计算资源不足，导致难以应用;</li><li>深层次网络结构容易出现梯度弥散，模型性能下降。</li></ol><h2 id="Inception"><a href="#Inception" class="headerlink" title="Inception"></a>Inception</h2><p>首先，一开始提出Inception为的是<strong>增加网络的适应能力</strong>。应用到图像领域，层级越高，所对应的原始图像的视野就越大，同样大小的卷积核往往难以捕捉到不同的特征。因而层级越高，卷积核的数目也应该增加，即使用不同尺寸的卷积核共同进行特征提取。<br><img src="/img/Inception/naive.png" alt="naive"></p><p>如上图所示，分别使用了<strong>1×1、3×3、5×5</strong>的卷积核，并且加入了<strong>3×3</strong>的<strong>max pooling</strong>。但是这样的结构存在着明显的问题：每一层的Inception结构上的参数量为所有分支上参数量的总和，多层Inception最终会导致模型的参数数量庞大，对计算资源需求巨大。</p><h3 id="Inception-v1"><a href="#Inception-v1" class="headerlink" title="Inception_v1"></a>Inception_v1</h3><p>为了减少计算量，在不损失模型特征表示能力的前提下，在v1中又提出了使用<strong>1×1</strong>卷积核进行降维，达到降低模型复杂度的目的：<br><img src="/img/Inception/v1.png" alt="v1"></p><p>如图，在<strong>3×3、5×5</strong>的卷积核之前，使用<strong>1×1</strong>卷积核进行降维，大大减少了参数量。</p><ul><li>1×1卷积核降维原理：比如100×100×3的图片，直接3×3卷积核卷积共进行<code>a=100×100×3×3×3</code>此运算。而使用1×1卷积核首先进行<code>b=100×100×3</code>次运算，然后再与3×3卷积核卷积进行<code>c=100×100×3×3</code>次运算,明显<code>a&gt;b+c</code>（计算运算量时只考虑了乘法数量）。</li></ul><h3 id="Inception-v2"><a href="#Inception-v2" class="headerlink" title="Inception_v2"></a>Inception_v2</h3><h3 id="Inception-v3"><a href="#Inception-v3" class="headerlink" title="Inception_v3"></a>Inception_v3</h3><h3 id="Inception-v4"><a href="#Inception-v4" class="headerlink" title="Inception_v4"></a>Inception_v4</h3>]]></content>
    
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CNN基础回顾</title>
    <link href="/2018/06/20/2018-06-20-cnn-base/"/>
    <url>/2018/06/20/2018-06-20-cnn-base/</url>
    
    <content type="html"><![CDATA[<h2 id="从神经网络到卷积神经网络（cnn）"><a href="#从神经网络到卷积神经网络（cnn）" class="headerlink" title="从神经网络到卷积神经网络（cnn）"></a>从神经网络到卷积神经网络（cnn）</h2><p>学过模式识别课程的都知道神经网络，它是一种重要的模式识别手段。基本结构如下：</p><p><img src="/img/cnn_base/neural_network.jpg" alt="neural_network"></p><p>卷积神经网络（Convolutional neural network，CNN），听名字就可以猜到，没错，这是一种特殊的神经网络。至于它特殊在哪？下面我们慢慢来说。</p><p>首先，由神经网络的结构图我们可以发现，神经网络中每个节点都与相邻层上的所有节点有一条权重连接。比如上图，输入层3个节点，隐藏层1、2各有4个节点，输出层1个节点，所以这个神经网络总共有<code>12+16+4=32</code>个权重。若是扩大神经网络比如输入层为<code>100×100</code>图片，下一层为<code>50×50</code>大小，则仅仅这一层便有<code>100×100×50×50=25000000</code>个权重！多的可怕！如此大的数据量，使用神经网络来做图像的分析处理，计算量不敢想象，基本不现实。</p><p>为了<em><strong>削减计算量</strong></em>，后来有人提出了卷积神经网络。卷积神经网络对于数据的处理模式与图像处理中对一幅图像加滤波器的操作是一样的。主要有以下两个特点：</p><ol><li><strong>局部关联</strong>：每个点的取值只与上一层中附近的点关联，比如<code>3×3</code>的卷积核表示此点取值只与周围8个点还有自身加起来9个点的取值有关，而传统神经网络中每个点的取值是与上一层所有的点关联的。</li><li><strong>权值共享</strong>：我们都知道，cnn主要是用来提取特征的，而一般提取同样的特征需要的卷积核是相同的，即对每个点的取值进行计算时使用相同的卷积核。</li></ol><h2 id="卷积神经网络的层级结构"><a href="#卷积神经网络的层级结构" class="headerlink" title="卷积神经网络的层级结构"></a>卷积神经网络的层级结构</h2><p>一般卷积神经网络由以下功能层组成：</p><ol><li>数据输入层（input layer）</li><li>卷积计算层（CONV layer）</li><li>（非线性）激励层（Relu layer等）</li><li>池化层（Pooling layer）</li><li>全连接层（FC layer）</li></ol><p>一个典型的CNN结构如下：</p><pre><code class="hljs">input layer +[n×(卷积层+Relu)+pooling层]*m+（全连接层+Relu）*k +全连接层</code></pre><h3 id="数据输入层（input-layer）"><a href="#数据输入层（input-layer）" class="headerlink" title="数据输入层（input layer）"></a>数据输入层（input layer）</h3><p>该层主要是对原始图像数据进行预处理，包括：</p><ul><li>去均值：即把输入数据的各个维度都中心化为0,目的是把样本中心拉回到坐标系原点。</li><li>归一化：幅度归一化到同样的范围，即减少各个维度数据取值范围差异带来的干扰，比如，我们有两个维度的特征A和B，A范围是0到10,而B范围是0到10000,如果直接使用这两个特征效果肯定不好，好的做法就是先归一化，比如将A和B的数据都变为0到1的范围。</li><li>PCA：用PCA降维。</li></ul><p>去均值与归一化图解：</p><p><img src="/img/cnn_base/pretreat.jpg" alt="pretreat"></p><h3 id="卷积计算层（CONV-layer）"><a href="#卷积计算层（CONV-layer）" class="headerlink" title="卷积计算层（CONV layer）"></a>卷积计算层（CONV layer）</h3><p>这一层是卷积神经网络最关键的一层，上文中讲到的cnn的特点局部关联与权值共享就体现在这一层，权重参数的减少也主要是在这一步完成的。如果有图像处理空域的一些知识，理解起来会比较轻松。这一层操作与图像处理中空域滤波操作是一样的，即使用固定的权重和不同窗口数据做内积，这一层主要要理解以下几个参数概念：</p><ol><li>卷积核（窗函数）</li><li>填充值（一般为0）</li><li>步长</li><li>深度（卷积核的深度必须和输入图像的深度一致。比如彩色图像三通道深度为3）</li></ol><p>卷积的计算过程如下：</p><p><img src="/img/cnn_base/conv.gif" alt="conv"></p><h3 id="激励层"><a href="#激励层" class="headerlink" title="激励层"></a>激励层</h3><p>学习过神经网络都知道激励层的作用是<strong>非线性</strong>，如果没有这一层那神经网络每个层都是线性的，而多个线性层其实可以合为一个线性层的。这样神经网络的层级深度就成了一个笑话。卷积神经网络同样如此。</p><p>CNN采用的激励函数一般为RELU（the rectified linear unit：修正线性单元），它的特点是收敛快，求梯度简单，但是比较脆弱，如下图：</p><p><img src="/img/cnn_base/relu.png" alt="relu"></p><h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><p>池化层一般夹在连续的卷积层中间，用于压缩数据和参数量，减小过拟合。个人觉得池化层其实与卷积层计算方式一样，都是使用固定的权重和不同窗口数据做内积，只是池化层可以是非线性的，比如MAX Pooling等，因此这一层也会有人用它代替激励层。</p><p>池化层的作用与意义是很明显的：</p><ol><li>特征不变性。也就是图像处理中常说的特征的尺度不变性，举例说明就是一张1080p的人脸图像和一张320p的人脸图像我们都可以看出这是一张人脸。因此在对图像进行resize时去掉的信息大多是一些无用的信息，留下来的往往都是具有尺度不变特征的。</li><li>特征降维。我们都知道一张图像所包含的信息量是巨大的，但是其中大部分的信息量对于我们来说是无用的，池化操作具有将重要的特征抽取出来的作用。</li><li>一定程度上可以防止过拟合，方便于优化。</li></ol><p>池化层用的方法有 Max pooling 和 average pooling 等，一般用的较多的是 max pooling 。</p><h3 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h3><p>全连接层两层之间所有的神经元都有权重连接，也就是开头处讲过的传统神经网络的层级连接方式。通常全连接层在卷积神经网络的尾部，当然，也有的网络根本没有全连接层。</p><h3 id="各层总结"><a href="#各层总结" class="headerlink" title="各层总结"></a>各层总结</h3><p>总的来说，上述各种层都有自己的作用，各司其职，使得卷积神经网络的效果更好。但是其实一个cnn网络中不是必须具备上面每一个层的。比如说有些没有全连接层，有些没有激励层（用非线性的pooling也能起到相同效果），当然，一般卷积层是肯定有的。分开学习各个层主要是对每层起到的作用都有了解，这样在自己搭建新的cnn架构时可以因地制宜选取合适的层，同时看到新论文中新的cnn网络结构时可以理解作者为什么要这么做。比如googlenet中就提出了新的inception的结构，后面也会写相关的笔记博客的。</p><h2 id="卷积神经网络基本知识"><a href="#卷积神经网络基本知识" class="headerlink" title="卷积神经网络基本知识"></a>卷积神经网络基本知识</h2><h3 id="训练方法"><a href="#训练方法" class="headerlink" title="训练方法"></a>训练方法</h3><p>同一般机器学习方法类似，先定义<strong>loss function</strong>,然后通过梯度下降法不断对权重进行调整进行训练。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>共享卷积核，对高维数据处理无压力</li><li>无需手动选取特征，且训练好后得到的特征分类效果好<br>缺点：</li><li>需要调参，需要大量样本，计算量庞大，需要GPU</li><li>物理含义不明确，对于cnn提取的特征，我们并不清楚其物理含义，因此不好调整。</li></ol><h3 id="典型CNN"><a href="#典型CNN" class="headerlink" title="典型CNN"></a>典型CNN</h3><ol><li>LeNet</li><li>AlexNet</li><li>VGGNet</li><li>GoogleNet</li><li>ResNet</li><li>DenseNet</li></ol><h3 id="fine-tuning"><a href="#fine-tuning" class="headerlink" title="fine-tuning"></a>fine-tuning</h3><p>fine-tuning就是将别人已经训练好的权重作为初始值，在此基础上进行训练，这样可以比较快的收敛，并且不容易出现问题。省时省心。具体做法是：</p><ol><li>复用相同层的权重，新定义的层取随即权重初始值;</li><li>调大新定义层的学习率，调小复用层的学习率。</li></ol><h3 id="CNN-常用框架"><a href="#CNN-常用框架" class="headerlink" title="CNN 常用框架"></a>CNN 常用框架</h3><ol><li>Caffe</li><li>Pytorch</li><li>Tensorflow</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一般也有一种说法是cnn主要负责提取图像的特征，至于分类器可以与前部分网络分开来看。但是实际应用时cnn的参数与分类器的参数最好是一起训练确定的。原因是cnn提取的特征是没有明确的物理含义的，这样分类器类型的选取就会变得很纠结。确定分类器类型后，将他们一起训练得到参数其实有助于实现，使得cnn提取的特征适合此种分类器进行分类操作。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.cnblogs.com/skyfsm/p/6790245.html">https://www.cnblogs.com/skyfsm/p/6790245.html</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译问题讨论－－make与cmake已经静态动态链接库</title>
    <link href="/2018/05/12/2018-05-13-make/"/>
    <url>/2018/05/12/2018-05-13-make/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很早之前就接触过makefile的语法，但是没有深入的学习下去。本来以为自己了解这方面的知识了，谁知道最近做项目时，各种形式接连丢过来，我竟是懵了。这才发现自己其实根本没有形成系统的理解，稍微变形就使得我不知所云。想来想去还是写一篇博客吧，把自己的理解梳理一遍，以后如果有更深入、更清晰的理解，我会对这篇博客进行补充，尽量使得自己的知识见解有条理，系统化。</p><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>首先，拿c语言为例，我们先写出了代码。通过编译器可以利用这些c代码（源文件）生成可执行文件。整个的编译流程可以分成四步：</p><ol><li>预处理阶段：进行预处理器处理（用实际值替代#define、读入#include指令包含的头文件等）；</li><li>编译阶段：将<code>.c</code>文件转换成<code>.s</code>文件，即将ｃ语言代码转换成汇编语言代码；</li><li>汇编阶段：将<code>.s</code>文件转换成<code>.o</code>文件，即将汇编语言代码转换成机器语言指令；</li><li>链接阶段：最后将各个目标文件由链接器捆绑起来形成单一完整的可执行文件，链接器同时也会引入标准c函数库中任何被该程序用到的函数。</li></ol><p>我在网上看到一张图，对于整个编译流程归纳的特别详细：<br><img src="/img/make/make.png" alt="make"></p><p>假设生成可执行文件<code>excute</code>在当前目录下，我们可以通过如下shell命令将<code>excute</code>载入内存执行。</p><pre><code class="hljs">./excute</code></pre><p>一般情况下，当输入一条命令，shell会检测第一个单词是不是一个内置的shell命令，如果不是就会把它当成一个可执行文件的名字，并加载运行这个可执行文件。</p><h3 id="gcc编译方式（bash）"><a href="#gcc编译方式（bash）" class="headerlink" title="gcc编译方式（bash）"></a>gcc编译方式（bash）</h3><p>编译<code>main.c</code>、<code>1.c</code>、<code>1.h</code>，生成可执行文件<code>excute</code></p><pre><code class="hljs">gcc -o excute main.c 1.c 1.h </code></pre><p>注1：如果不<code>-o</code>指定生成<code>excute</code>，将默认生成<code>a.out</code>。</p><p>注2：如果源文件不止一个，第二步产生的<code>.o</code>文件将会保留，以待重新编译只编译改动过的代码。</p><h2 id="make与cmake"><a href="#make与cmake" class="headerlink" title="make与cmake"></a>make与cmake</h2><p>由上，我们知道了整个编译过程，但是如果一个项目很大，使用上述方式输入命令，似乎就很不灵活了。于是产生了<strong>make</strong>工具，它是一个自动化编译工具，规定好编译规则（<strong>Makefile</strong>），一条命令<code>make</code>，便能将整个工程编译完毕。</p><p>对于一个合格的程序员来说，编写Makefile是必备技能。</p><p>但是对于一个很大的项目，自己编写Makefile无疑是一件及其吃力的事情。于是又出现了<strong>cmake</strong>，它可以读入所有源文件后，自动生成Makefile文件。当然，cmake也有自己的规则文件（<strong>CmakeLists.txt</strong>）。不过比较而言，编写<code>CmakeLists.txt</code>却是简单多了。</p><p>一般只需要输入<code>cmake</code>，整个项目会自动编译完成。cmake时大体流程如下：</p><pre><code class="hljs">`cmake(CmakeLists.txt) --&gt; Makefile``make(Makefile) --&gt; 编译完成`</code></pre><p>注：make一般在windows下效果不好，camke跨平台比较常见</p><h3 id="make选项"><a href="#make选项" class="headerlink" title="make选项"></a>make选项</h3><p>我们也会经常看到<code>make install</code>、<code>make distribute</code>等形式，这些都是什么意思呢？</p><p><code>make install</code>:有些程序需要源码安装，<strong>make install</strong>在编译完程序源码后，会接着往系统写入一些配置，完成程序安装。</p><p><code>make distribute</code>:感觉应该是使当前项目可以被外部项目依赖？</p><h3 id="大工程-make-编译流程"><a href="#大工程-make-编译流程" class="headerlink" title="大工程 make 编译流程"></a>大工程 make 编译流程</h3><pre><code class="hljs">./configuremakemake install</code></pre><p>一般会是如上的顺序进行大工程的编译（c与c++）。</p><ol><li><p>configure脚本：这个脚本的作用有获取编译参数（当前的系统环境，比如标准库在哪里、软件的安装位置在哪里、需要安装哪些组件）;确定标准库与头文件的位置;确定依赖关系，生成makefile;</p></li><li><p>make：编译;</p></li><li><p>make install：将编译器在内存中生成的可执行文件保存到用户事先指定的安装目录（创建目录、保存文件、设置权限等，并告知操作系统，即在操作系统中，登记这个程序的元数据：文件名、文件描述、关联后缀名等等。Linux系统中，这些信息通常保存在&#x2F;usr&#x2F;share&#x2F;applications目录下的.desktop文件中。）</p></li></ol><h3 id="动态连接与静态连接"><a href="#动态连接与静态连接" class="headerlink" title="动态连接与静态连接"></a>动态连接与静态连接</h3><p>开发者可以在编译阶段选择可执行文件连接外部函数库的方式，到底是静态连接（编译时连接），还是动态连接（运行时连接）。所以，最后还要提一下，什么叫做动态连接。</p><p><strong>静态连接就是把外部函数库，拷贝到可执行文件中</strong>。所以在编译链接完成后，就不需要静态库文件了。</p><ul><li>好处是，适用范围比较广，不用担心用户机器后来删掉某个库文件；</li><li>缺点是安装包会比较大，而且多个应用程序之间，无法共享库文件；并且在链接时如果静态链接库之间存在依赖关系，需要考虑链接顺序问题。</li></ul><p><strong>动态连接的做法正好相反，外部函数库不进入安装包，只在运行时动态引用</strong>。在运行可执行文件时，动态库文件必须存在于指定的位置，否则出错。</p><ul><li>好处是安装包会比较小，多个应用程序可以共享库文件；</li><li>缺点是用户必须事先安装好库文件，而且版本和安装位置都必须符合要求，否则就不能正常运行。</li></ul><p>现实中，大部分软件采用动态连接，共享库文件。这种动态共享的库文件，Linux平台是后缀名为.so的文件，Windows平台是.dll文件，Mac平台是.dylib文件。</p>]]></content>
    
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APT包管理简析</title>
    <link href="/2018/05/01/2018-05-01-apt-simple/"/>
    <url>/2018/05/01/2018-05-01-apt-simple/</url>
    
    <content type="html"><![CDATA[<h2 id="Advanced-Packaging-Tool-APT"><a href="#Advanced-Packaging-Tool-APT" class="headerlink" title="Advanced Packaging Tool(APT)"></a>Advanced Packaging Tool(APT)</h2><blockquote><p>高级打包工具（英语：Advanced Packaging Tools，缩写为APT）是Debian及其派生发行版的软件包管理器。APT可以自动下载，配置，安装二进制或者源代码格式的软件包，因此简化了Unix系统上管理软件的过程。——维基百科</p></blockquote><p>Debian是ubuntu的母版系统，Advanced Packaging Tools(APT)是各种基于Debian的发行版通用的一种<strong>软件包管理工具</strong>。借助这个包管理工具，用户可以方便的为自己电脑上的Linux安装各种程序软件包。注意：此处的APT与shell的apt命令是不一样的哦</p><h2 id="ubuntu软件源的选择"><a href="#ubuntu软件源的选择" class="headerlink" title="ubuntu软件源的选择"></a>ubuntu软件源的选择</h2><p>Ubuntu是用的APT进行包管理的,而这种管理方式是基于软件源的。软件源，顾名思义，就是各种软件包的集合。用户在软件源里查找自己需要的包进行安装十分方便。全世界有很多的Ubuntu软件源服务器，对于普通用户来讲，每个软件源上的包资源基本都是一样的，因为自己想找的包无论在哪个软件源上，基本都会存在。安装完Ubuntu后，其默认的软件源是Ubuntu官方提供的软件源服务器。由于这个服务器是在美国，而我国又有一些网络因素存在，使得用这个软件源安装软件时速度十分的慢。想要解决这个问题，换一个软件源就好了。</p><p>如何更换软件源呢？系统的软件源列表就是<code>/etc/apt/sources.list</code>文件，打开我们会发现里面大多是如下形式：</p><pre><code class="hljs">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricteddeb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial multiverse universe main restricted </code></pre><blockquote><p><code>mirrors.tuna.tsinghua.edu.cn</code>代表我使用的是清华的软件源，修改软件源其实只要修改这个域名就好了。上面每一项的含义是什么呢？具体apt又是怎么工作的呢？</p></blockquote><p>首先，每个软件源服务器上都会将各个版本各种类型的ubuntu的软件库列表区分开来，在这里指明了软件源列表的网络位置，其中一些单词的含义下面列出。（其中，<code>deb-src</code>代表的是二进制包。）</p><ol><li>xenial - 代表适用ubuntu16.04系统的软件。（一般此项xenial代表的不同版本系统存储路径下会有以下Main、Universe等路径）</li><li>Main - Canonical支持的免费和开源软件。</li><li>Universe - 社区维护的免费和开源软件。</li><li>restricted - 设备的专有驱动程序。</li><li>Multiverse - 受版权或法律问题限制的软件</li></ol><p>上述这些进入Ubuntu桌面的<em><strong>设置-软件和更新</strong></em>可以看的更加直观方便些。用户可以根据自己的需要添加自己可能会用到的软件服务选项。<br><img src="/img/apt/apt-gui.PNG" alt="gui-apt"></p><p>上面其实是指明了清华的源上可用软件列表的网络存储位置，软件列表存储的信息有哪些软件包可用、以及去哪里可以获取它。如果想要安装一个软件，就可以到这个网络位置上对软件列表进行索引，如果能索引到这个软件包便能定位它并下载安装。但是每次安装软件都要去访问这个网络位置是很耗时费力的，因此系统实际的做法是会在本地存储一份源的软件列表，在要安装软件时直接索引本地的软件列表。所以，在你更换了自己的软件源后一定要记得<code>sudo apt update</code>，这个命令会重新从<code>source.list</code>上的网络位置上更新本地的软件列表，不更新的话你的新软件源是不生效的。同时为了始终安装最新的软件包，建议每隔一段时间便执行一次<code>sudo apt update</code>，这样可以使得自己本地的软件列表的软件版本一直是最新的。</p><p>想要替换软件源，可以直接修改<code>sources.list</code>，也可以在<code>系统设置/软件和更新</code>里进行选择。替换哪个软件源呢？其实也很容易选择，<code>ping</code>一下看看速度，选择最快的一个便好，下面是我选择的过程。因为校园网的问题，不知为什么ping不通阿里的源，然后可以ping通中科大与清华的源，因为清华的源速度更快，我选择了它。友情提醒：用虚拟机的朋友，直接在虚拟机下ping，由于虚拟机的网络是在本机的局域网内的重映射，没有进行特殊设置的话，一般只能ping通主机，是ping不通任何软件源的。所以我ping是在本机Windows上进行的。</p><p><img src="/img/apt/ping_ustc.png" alt="ping_ustc"></p><p>清华比中科大快一些</p><p><img src="/img/apt/ping_tsinghua.png" alt="ping_tsinghua"></p><blockquote><p>注意：<code>apt update</code>与<code>apt upgrade</code>是不一样的，前一个只是<strong>更新本地存储的软件列表</strong>，后一个会将本地系统安装的软件与软件列表中的版本进行比对，如果有更新的版本，就会<strong>升级软件</strong>。</p></blockquote><h2 id="apt命令与apt-get命令"><a href="#apt命令与apt-get命令" class="headerlink" title="apt命令与apt-get命令"></a>apt命令与apt-get命令</h2><p>上文提到了Debian及其派生发行版使用的是Advanced Packaging Tool(APT)进行包管理的。同时，Debian及其派生发行版也提供了一些不同的工具用来与APT进行交互，使得用户可以进行包的安装与卸载。而<code>apt-get</code>是系统提供用户使用来与APT进行交互，使得用户可以实现安装、删除、更新软件的命令行工具。相似的命令还有<code>apt-cache</code>与<code>apt-config</code>，另外还有Aptitude（既有图形界面又有命令行选项）。这三个命令里都会有一些用户特别常用的包管理命令，说的直白点，就是用户最常用的命令分散在了<strong>apt-get</strong>、<strong>apt-cache</strong>、<strong>apt-config</strong>里。它们三个每个里面大部分的命令用户都不会用到。</p><p>到Ubuntu16.04里，出现了<code>apt</code>命令。<strong>apt</strong>里包含了原本<code>apt-get</code>、<code>apt-cache</code>与<code>apt-config</code>里常用的命令和一些自己的命令，更加方便用户的使用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell启动流程</title>
    <link href="/2018/04/26/2018-04-26-shell-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2018/04/26/2018-04-26-shell-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是shell"><a href="#什么是shell" class="headerlink" title="什么是shell"></a>什么是shell</h2><blockquote><p>在计算机科学中，<strong>壳层</strong>（英语：shell）指“为用户提供用户界面”的软件，通常指的是命令行界面的解析器。一般来说，这个词是指操作系统中，提供访问内核所提供之服务的程序。——维基百科</p></blockquote><p>shell是一种应用程序，它提供了用户交互界面，并且在这个交互界面上人们可以访问内核服务。shell大致分为两类，命令行界面的shell(<strong>CLI-Shell</strong>)和图形界面的shell(<strong>GUI-Shell</strong>)。<strong>CLI-Shell</strong>最典型的就是linux的bash与windows的cmd，<strong>GUI-Shell</strong>包括我们常用的windows与linux的图形用户界面软件。</p><p>我会写出来的肯定是<strong>CLI-Shell</strong>,以我的这个Ubuntu为例，可以通过<code>cat /etc/shells</code>查看现有的shell种类：</p><pre><code class="hljs"># /etc/shells: valid login shells/bin/sh/bin/dash/bin/bash/bin/rbash</code></pre><p>在各个Linux的发行版中，默认的都是bash，所以以下讲解都是基于<strong>bash</strong>（一种CLI-Shell）。</p><h2 id="shell的运行模式"><a href="#shell的运行模式" class="headerlink" title="shell的运行模式"></a>shell的运行模式</h2><h3 id="交互式shell与非交互式shell"><a href="#交互式shell与非交互式shell" class="headerlink" title="交互式shell与非交互式shell"></a>交互式shell与非交互式shell</h3><p>这个很简单，直接按照字面理解便可以想清楚。交互式shell就是terminal。非交互式shell就是<code>shell script</code>。</p><p>检验：</p><ol><li>命令行输入<code>echo $-</code><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">xhy<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>echo <span class="hljs-variable">$-</span><br>himBH <span class="hljs-comment">#代表是交互式shell</span><br></code></pre></td></tr></table></figure></li></ol><hr><ol start="2"><li>在一个shell脚本中写入<code>echo $-</code>,然后运行这个脚本<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">xhy<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>./test.sh<br>hB <span class="hljs-comment">#代表是非交互式shell</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="登录shell与非登录shell"><a href="#登录shell与非登录shell" class="headerlink" title="登录shell与非登录shell"></a>登录shell与非登录shell</h3><p>其实我们平时用到的都是非登录shell，比如在Linux桌面里<code>Ctrl+Alt+T</code>打开的bash终端，就是非登录的shell，包括你在这个终端里进行用户切换，比如说切换到root账户，其实还是非登录shell。那什么时候才是登录shell呢？</p><p>很简单，判断是登录shell，还是非登录shell是通过启动bash时的命令选项决定的。<code>Ctrl+Alt+T</code>其实就是执行了一个<code>bash</code>命令，没有参数，默认是非登录shell。而登录shell在启动时执行的是<code>bash -login</code>。</p><p>怎么判断是登录shell还是非登录shell呢？首先<code>Ctrl+Alt+T</code>打开bash终端，通过下面两个办法检验非登录shell的结果；再在bash终端里输入<code>bash -login</code>进入登录shell，再试一次。查看区别。</p><ol><li><p>可以通过<code>echo $0</code>命令查看</p></li><li><p><code>logout</code>命令可以退出登录shell，不能退出登录shell，<code>exit</code>命令都可以退出</p></li></ol><blockquote><p>此处之所以介绍这些，是因为系统在启动登录与非登录shell时读取的配置文件数据是不一样的。</p></blockquote><h2 id="shell启动时的脚本读取情况"><a href="#shell启动时的脚本读取情况" class="headerlink" title="shell启动时的脚本读取情况"></a>shell启动时的脚本读取情况</h2><p>其实在Linux系统启动时（开机）以图形模式登录时是以<code>bash -login</code>模式的。随后我们打开终端的都是<code>bash</code>模式。</p><p><strong>登录shell</strong>在启动时会进行如下初始化读取操作：</p><blockquote><ol><li>首先执行 &#x2F;etc&#x2F;profile</li><li>然后<strong>依次</strong>查找 ~&#x2F;.bash_profile, ~&#x2F;.bash_login, ~&#x2F;.profile 三个文件，找到第一个存在且可读的文件来执行。</li><li>如果存在 ~&#x2F;.bash_logout，退出时会执行这个脚本。</li></ol></blockquote><div style="text-align: center"><img src="/assets/img/shell_init/loginshell.png"/></div><blockquote><p>我们知道，~&#x2F;目录下的是用户配置文件（每个用户不一定相同），是可以覆盖 &#x2F;etc&#x2F;profile 中的全局设置的。这几个配置文件如果修改了，只有重启才会在接下来所有新开的bash终端中生效，source只会在当前终端中生效。</p></blockquote><p><strong>非登录shell</strong>在启动时进行如下初始化操作</p><blockquote><ol><li>先执行 &#x2F;etc&#x2F;bash.bashrc</li><li>后执行 ~&#x2F;.bashrc</li></ol></blockquote><blockquote><p>这个配置文件如果修改了，对接下来新开的终端都会有效果，source一下对当前终端也生效。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>补码，原码，反码</title>
    <link href="/2018/04/24/2018-04-24-%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81/"/>
    <url>/2018/04/24/2018-04-24-%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="写作缘由"><a href="#写作缘由" class="headerlink" title="写作缘由"></a>写作缘由</h2><p>昨天室友忽然问起老师布置的作业里有关补码的问题，我竟然忘了，张口结舌说了半天不知所云。事后想到这是最基础的内容了，不由老脸一红。赌气般的把这个问题又梳理了一遍。想来想去觉得还是写出来吧，加深记忆，随时翻阅，省的再给忘了。</p><h2 id="有符号数与无符号数"><a href="#有符号数与无符号数" class="headerlink" title="有符号数与无符号数"></a>有符号数与无符号数</h2><p>首先，无符号数是最简单的，例如一个八位的无符号数取值范围为<code>0～255</code>。</p><p>而有符号数最高位为符号位，下文中讲的<strong>原码、反码、补码</strong>都是指<strong>有符号数</strong>的编码方式。以八位有符号数为例进行讲解。</p><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><blockquote><p>m位二进制<strong>原码的定义</strong>与其他编码形式稍有不同，它最高位并没有权值，而是一个系数，所以在由原码求十进制整数式，是最高位的确定的系数乘以低m-1位累加各位值与权值的积的和。</p></blockquote><p>原码：符号位 + 绝对值</p><p>所以八位机器数的原码范围为<code>11111111 ～ 01111111</code>，也就是<code>-127～127</code>（0有两种表示）。</p><p>这种形式（原码）极其符合人们脑海中对于有符号数的第一印象，看到这里都会觉得理所当然，确实，这是人脑最容易理解与计算的形式。但，对电脑不是。</p><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><blockquote><p>首先提一下，m位<strong>反码的定义</strong>，即最高位的权值为<code>-2^(m-1)-1</code>，其他第n位权值为<code>2^(n-1)</code>，在由反码求十进制整数时，直接累加各位值与权值的积即可。</p></blockquote><p>反码：</p><ul><li>正数的反码与原码相同</li><li>负数的反码是其绝对值的原码按位取反</li></ul><p>比如-1的反码<code>11111110</code>是其绝对值1的原码<code>00000001</code>按位取反的结果。反码有什么用呢？</p><p>计算机只会做加法，不会做减法，反码可以用来实现机器减法，没错，而且这个减法是完备的，在负数域，可用的，只是有一个小小的缺点而已，如：</p><pre><code class="hljs">1 - 1 = 1 + （-1） = 反[00000001] + 反[11111110] = 反[11111111] = 原[10000000] = -0</code></pre><p>其他的数大家也可以试试，在结果是负数或0时都成立的，但是在结果是正数时，我们会发现结果刚好小1。例如</p><pre><code class="hljs">3 - 1 = 3 + （-1）=反[00000011] + 反[11111110] = 反[00000001] = 原[00000001] = 1</code></pre><p>这个原因我们仔细考虑一下会发现，在采用反码的减法中，负数通过加正数得0时得到的是<code>-0</code>，而且刚好<code>-0 +1 = +0（本来应该是1的）</code>。如何解决这个问题呢？我们来看补码。</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><blockquote><p>首先提一下，m位<strong>补码的定义</strong>，即最高位的权值为<code>-2^(m-1)</code>，其他第n位权值为<code>2^(n-1)</code>，在由补码求十进制整数时，直接累加各位值与权值的积即可。</p></blockquote><p>补码：</p><ul><li>补码表示范围<code>-128~127</code></li><li>正数的补码为与原码相同</li><li>负数的补码是其正数绝对值补码（也就是原码）按位取反再加1（也就是反码的基础上加1）</li></ul><p>比如-1的补码<code>11111111</code>是其绝对值1的原码<code>00000001</code>按位取反再加1的结果。</p><p>下面来讨论上面的问题，用补码来实现机器减法：如：</p><pre><code class="hljs">1 - 1 = 1 + （-1） = 补[00000001] + 补[11111111] = 补[00000000] = 原[00000000] = 0</code></pre><p>由于补码实现的减法得到的结果不是-0而是0了，反码的那个问题便解决了。只是需要说明的是原来的<code>-0</code>即<code>10000000</code>现在干嘛去了呢？对，它现在是<code>-128</code>，而这个数（-128）只存在补码表示，不存在原码和反码表示。编程里常用的32位有符号int取值范围是<code>[-2^31 ～ 2^31 -1]</code>，没错，都是补码存储的。</p><p><code>10000000</code>看作原码是-0;求反码是<code>11111111</code>，再求补码是<code>10000000</code>（求补码时加一是不进最高位的，但是补码还有反码减法时最高位符号位是会进位的），不过此时代表-128。</p><blockquote><p>此处说明一下，由于补码的定义，使得对于一个补码表示的有符号数x来说，<strong>按位取反再加１</strong>是一种用来求<code>-x</code>补码的手段。这个手段一直有效，无论x是正数还是负数还是0。(最小的那个负数的<code>-x</code>是本身)</p></blockquote><h3 id="神奇补码背后思考"><a href="#神奇补码背后思考" class="headerlink" title="神奇补码背后思考"></a>神奇补码背后思考</h3><blockquote><p>由补码的定义可知，一个m位有符号数（假设值为x，x为一个负值）的补码如果表示的是一个无符号数，则这个无符号数的值为<code>x+2^m</code>，这个结果可以由上面补码的定义推断出，因为补码的最高位权值是<code>-2^(m-1)</code>。同理，一个m位无符号数（假设值为x，x&gt;&#x3D;2^(m-1)）的二进制编码如果用来表示的是一个有符号数的补码，则这个有符号数值为<code>x-2^m</code>。</p></blockquote><p>我们都知道加法减法是满足结合率的，所以要想知道做减法需要用到的负数机器码应该如何定义可以这样想：</p><pre><code class="hljs">原数 + a - a = 原数+a + （-a) = 0</code></pre><ul><li>所以会有<code>1 + （-1）= 0</code>，我们知道1为<code>00000001</code>，所以-1应该为<code>11111111</code></li><li>同理，2为<code>00000010</code>，-2应该为<code>11111110</code></li><li>。。。依次类推，补码也诞生了，这种实现减法的思想依靠的是有限位数进位导致的循环来实现的。在8位二进制数中，减1也就等于加255，刚好是求补的感觉，所以这种编码方式叫做补码（我猜的，但是其实一种运算在一个集合上形成的这种奇妙现象有一个数学名字－－<strong>阿贝尔群</strong>）。</li></ul><blockquote><p>亮点：计算机中数都是补码存储的，计算机的加法计算也没有什么弯弯绕绕，就是很耿直的进位加法，补码这种形式刚好可以使得加法计算的结果正确无误，无非就是靠进位导致的循环来实现罢了。很多人只是不熟悉而已，熟悉了在分析此类问题时会自动先将数据切换成补码形式，任何问题都会一目了然。</p></blockquote><p><strong>现在我们可以想一下并发现，如果8位计算溢出了，大于127比如结果为<code>127+n</code>（n&gt;0且n&lt;&#x3D;256），8位存储的数会变成<code>-129+n</code>（从-128到127）;小于-128比如结果为<code>-128-n</code>（n&gt;0且n&lt;&#x3D;256）,8位存储的数会变成<code>128-n</code>（从127到-128）。这就是一个完美循环。</strong></p><p>其实这没有什么不好理解的，你只需要想清楚，在计算机中，数据都是补码形式存储的。计算机做加法操作其实就是不断进位喽。如果你还是觉得不太直观，写个c语言程序验证一下，我的<code>c_learn</code>文件夹下<code>ch3</code>目录就写了一个很简短的验证。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般情况下，以上这些已经足够了，为了不会闹笑话，我们来检验一下：</p><p>-8的补码是多少？</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单理解应用AWK</title>
    <link href="/2018/04/21/2018-04-22-AWK-script/"/>
    <url>/2018/04/21/2018-04-22-AWK-script/</url>
    
    <content type="html"><![CDATA[<h1 id="what’s-AWK"><a href="#what’s-AWK" class="headerlink" title="what’s AWK"></a>what’s <em><strong>AWK</strong></em></h1><blockquote><p>AWK是一种优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一。这种编程及数据操作语言（其名称得自于它的创始人阿尔佛雷德·艾侯、彼得·温伯格和布莱恩·柯林汉姓氏的首个字母）的最大功能取决于一个人所拥有的知识。——维基百科</p></blockquote><p>由上可知，<strong>AWK</strong>是一种强大的用于文本分析处理的工具。很多人简单的把它看作<strong>linux</strong>下的一个命令，这种观点是浅显的，<strong>AWK</strong>实际上也是一个脚本解释器（与shell一样），通过下文，我们可以逐渐发现<strong>AWK</strong>的强大。</p><h2 id="AWK：基本知识汇总"><a href="#AWK：基本知识汇总" class="headerlink" title="AWK：基本知识汇总"></a><em><strong>AWK：</strong></em>基本知识汇总</h2><p>实际上AWK的确拥有自己的语言：AWK程序设计语言，三位创建者已将它正式定义为“样式扫描和处理语言”。AWK提供了极其强大的功能：可以进行正则表达式的匹配，样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。它具备了一个完整的语言所应具有的几乎所有精美特性。</p><p>AWK在处理文本时，一次读入一个记录，每行为一条记录。每条记录会划分成多个域，最终将一个文件规划成一个表格类型的数据结构。</p><h2 id="AWK的内置变量"><a href="#AWK的内置变量" class="headerlink" title="AWK的内置变量"></a>AWK的内置变量</h2><ul><li>$0：当前记录，这个变量存放了当前整行的内容。</li><li>$n：当前记录的第n个域的内容。（由FS进行分隔）</li><li>FS：域分隔符”。其默认值为“空白字符”，即空格和制表符。FS可以替换为其它字符，从而改变域分隔符。</li><li>NF：当前记录中的域个数，也就是总列数。</li><li>NR：已经读出的记录的条数，也就是行号，如果多个文件的话，这个变量会一直累计。</li><li>FNR：也是行号，不过刚开始读每个文件时会清零，因此只代表这条记录在当前文件中的行号。</li><li>RS：“记录分隔符”。默认为换行符。</li><li>OFS：“输出域分隔符”，默认空格。</li><li>ORS：“输出记录分隔符（行）”默认换行符。</li><li>FILENAME：当前输入文件名。</li></ul><h2 id="AWK：作为一个命令用"><a href="#AWK：作为一个命令用" class="headerlink" title="AWK：作为一个命令用"></a><em><strong>AWK：</strong></em>作为一个命令用</h2><p>假设有一段文本<code>test.log</code>，文本内容如下：</p><pre><code class="hljs">Proto    Recv-Q   Send-Q   Local-Address      Foreign-Address        Statetcp      0        0        0.0.0.0:3306       0.0.0.0:*              LISTENtcp      0        0        0.0.0.0:80         0.0.0.0:*              LISTENtcp      0        0        127.0.0.1:9000     0.0.0.0:*              LISTENtcp      0        0        coolshell.cn:80    124.205.5.146:18245    TIME_WAITtcp      0        0        coolshell.cn:80    61.140.101.185:37538   FIN_WAIT2tcp      0        0        coolshell.cn:80    110.194.134.189:1032   ESTABLISHEDtcp      0        0        coolshell.cn:80    123.169.124.111:49809  ESTABLISHEDtcp      0        0        coolshell.cn:80    116.234.127.77:11502   FIN_WAIT2tcp      0        0        coolshell.cn:80    123.169.124.111:49829  ESTABLISHEDtcp      0        0        coolshell.cn:80    183.60.215.36:36970    TIME_WAITtcp      0        4166     coolshell.cn:80    61.148.242.38:30901    ESTABLISHEDtcp      0        1        coolshell.cn:80    124.152.181.209:26825  FIN_WAIT1tcp      0        0        coolshell.cn:80    110.194.134.189:4796   ESTABLISHEDtcp      0        0        coolshell.cn:80    183.60.212.163:51082   TIME_WAITtcp      0        1        coolshell.cn:80    208.115.113.92:50601   LAST_ACKtcp      0        0        coolshell.cn:80    123.169.124.111:49840  ESTABLISHEDtcp      0        0        coolshell.cn:80    117.136.20.85:50025    FIN_WAIT2tcp      0        0        :::22              :::*                   LISTEN</code></pre><p>输入命令<code>awk &#39;$3&gt;0 || NR==1 &#123;print $0&#125;&#39; test.log &gt; record.log</code>,查看<code>record.log</code>中输出如下：</p><pre><code class="hljs">Proto Recv-Q Send-Q Local-Address          Foreign-Address             Statetcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHEDtcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK</code></pre><p>输入命令<code>awk &#39;$6 ~ /TIME_WAIT|State/ &#123;printf&quot;%02d %10s %30s %20s \n&quot;,NR,$1,$4,$6&#125;&#39; test.log &gt; record.log</code>，查看<code>record.log</code>中输出如下：</p><pre><code class="hljs">01      Proto                  Local-Address                State 05        tcp                coolshell.cn:80            TIME_WAIT 11        tcp                coolshell.cn:80            TIME_WAIT 15        tcp                coolshell.cn:80            TIME_WAIT </code></pre><p>如上我们可以发现，是如下模式：</p><pre><code class="hljs">    pattern &#123; action &#125;</code></pre><p>上面是AWK的基础命令模式，AWK将对输入的文本进行逐记录（行）处理，在遇到符合<code>pattern</code>的记录时，执行<code>action</code>。所以，如果有10行符合pattern，则action会执行10次。</p><h2 id="AWK：脚本编写"><a href="#AWK：脚本编写" class="headerlink" title="AWK：脚本编写"></a><em><strong>AWK：</strong></em>脚本编写</h2><p>有<code>score.log</code>，内容如下：</p><pre><code class="hljs">Marry   2143 78 84 77Jack    2321 66 78 45Tom     2122 48 77 71Mike    2537 87 97 95Bob     2415 40 57 62</code></pre><p>编写一个后缀名为<code>.awk</code>的脚本，内容如下：</p><pre><code class="hljs">#!/bin/awk -f#运行前BEGIN &#123;    math = 0    english = 0    computer = 0     printf &quot;NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n&quot;    printf &quot;---------------------------------------------\n&quot;&#125;#运行中&#123;    math+=$3    english+=$4    computer+=$5    printf &quot;%-6s %-6s %4d %8d %8d %8d\n&quot;, $1, $2, $3,$4,$5, $3+$4+$5&#125;#运行后END &#123;    printf &quot;---------------------------------------------\n&quot;    printf &quot;  TOTAL:%10d %8d %8d \n&quot;, math, english, computer    printf &quot;AVERAGE:%10.2f %8.2f %8.2f\n&quot;, math/NR, english/NR, computer/NR&#125;</code></pre><p>在终端输入<code>awk -f score.awk score.txt</code>，输出结果如下：</p><pre><code class="hljs">NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL---------------------------------------------Marry  2143     78       84       77      239Jack   2321     66       78       45      189Tom    2122     48       77       71      196Mike   2537     87       97       95      279Bob    2415     40       57       62      159---------------------------------------------  TOTAL:       319      393      350 AVERAGE:     63.80    78.60    70.00</code></pre><p>如上便是AWK的脚本方式，如果想要将脚本嵌入shell中，只需要把AWK代码放入<code>&#39;&#39;</code>中便可以了，而且这样做不需要<code>-f</code>参数。方式：<code>awk &#39;代码&#39;</code></p><h3 id="AWK脚本的流程控制"><a href="#AWK脚本的流程控制" class="headerlink" title="AWK脚本的流程控制"></a>AWK脚本的流程控制</h3><ul><li>if语句控制：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span> (condition)<br>&#123;<br>    body<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (condition)<br>&#123;<br>    body<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    body<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>for语句控制</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">for</span> (initialization; condition; increment)<br>&#123;<br>    body<br>&#125; <br><br> <br><br><span class="hljs-keyword">for</span> (var <span class="hljs-keyword">in</span> array)<br></code></pre></td></tr></table></figure><ul><li>while语句控制</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">while</span> (condition)<br>&#123;<br>    body<br>&#125;<br>  <br><span class="hljs-keyword">do</span><br>&#123;<br>    body<br>&#125;<br><span class="hljs-keyword">while</span> (condition)<br></code></pre></td></tr></table></figure><ul><li>swith语句控制</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">switch (expression) <br>&#123;<br>case value or regular expression:<br>    case-body<br>default:<br>    default-body<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell脚本快速入门</title>
    <link href="/2018/04/20/2018-04-20-shell-script/"/>
    <url>/2018/04/20/2018-04-20-shell-script/</url>
    
    <content type="html"><![CDATA[<p>转自一个<a href="https://github.com/qinjx/30min_guides/blob/master/shell.md">github</a></p><h2 id="什么是Shell脚本"><a href="#什么是Shell脚本" class="headerlink" title="什么是Shell脚本"></a>什么是Shell脚本</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>看个例子吧：</p><pre><code class="hljs">#!/bin/shcd ~mkdir shell_tutcd shell_tutfor ((i=0; i&lt;10; i++)); do    touch test_$i.txtdone</code></pre><h3 id="示例解释"><a href="#示例解释" class="headerlink" title="示例解释"></a>示例解释</h3><ul><li>第1行：指定脚本解释器，这里是用&#x2F;bin&#x2F;sh做解释器的</li><li>第2行：切换到当前用户的home目录</li><li>第3行：创建一个目录shell_tut</li><li>第4行：切换到shell_tut目录</li><li>第5行：循环条件，一共循环10次</li><li>第6行：创建一个test_0…9.txt文件</li><li>第7行：循环体结束</li></ul><p>mkdir, touch都是系统自带的程序，一般在&#x2F;bin或者&#x2F;usr&#x2F;bin目录下。for, do, done是sh脚本语言的关键字。</p><h3 id="shell和shell脚本的概念"><a href="#shell和shell脚本的概念" class="headerlink" title="shell和shell脚本的概念"></a>shell和shell脚本的概念</h3><p>shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson的sh是第一种Unix Shell，Windows Explorer是一个典型的图形界面Shell。</p><p>shell脚本（shell script），是一种为shell编写的脚本程序。业界所说的shell通常都是指shell脚本，但读者朋友要知道，shell和shell script是两个不同的概念。由于习惯的原因，简洁起见，本文出现的“shell编程”都是指shell脚本编程，不是指开发shell自身（如Windows Explorer扩展开发）。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>shell编程跟java、php编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><h3 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h3><p>当前主流的操作系统都支持shell编程，本文档所述的shell编程是指Linux下的shell，讲的基本都是POSIX标准下的功能，所以，也适用于Unix及BSD（如Mac OS）。</p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>Linux默认安装就带了shell解释器。</p><h4 id="Mac-OS"><a href="#Mac-OS" class="headerlink" title="Mac OS"></a>Mac OS</h4><p>Mac OS不仅带了sh、bash这两个最基础的解释器，还内置了ksh、csh、zsh等不常用的解释器。</p><h4 id="Windows上的模拟器"><a href="#Windows上的模拟器" class="headerlink" title="Windows上的模拟器"></a>Windows上的模拟器</h4><p>windows出厂时没有内置shell解释器，需要自行安装，为了同时能用grep, awk, curl等工具，最好装一个cygwin或者mingw来模拟linux环境。</p><ul><li><a href="http://www.cygwin.com/">cygwin</a></li><li><a href="http://www.mingw.org/">mingw</a></li></ul><h3 id="脚本解释器"><a href="#脚本解释器" class="headerlink" title="脚本解释器"></a>脚本解释器</h3><h4 id="sh"><a href="#sh" class="headerlink" title="sh"></a>sh</h4><p>即Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是&#x2F;bin&#x2F;sh，由Bell Labs开发。</p><p>本文讲的是sh，如果你使用其它语言用作shell编程，请自行参考相应语言的文档。</p><h4 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h4><p>Bash是Bourne shell的替代品，属GNU Project，二进制文件路径通常是&#x2F;bin&#x2F;bash。业界通常混用bash、sh、和shell，比如你会经常在招聘运维工程师的文案中见到：熟悉Linux Bash编程，精通Shell编程。</p><p>在CentOS里，&#x2F;bin&#x2F;sh是一个指向&#x2F;bin&#x2F;bash的符号链接:</p><pre><code class="hljs">[root@centosraw ~]# ls -l /bin/*sh-rwxr-xr-x. 1 root root 903272 Feb 22 05:09 /bin/bash-rwxr-xr-x. 1 root root 106216 Oct 17  2012 /bin/dashlrwxrwxrwx. 1 root root      4 Mar 22 10:22 /bin/sh -&gt; bash</code></pre><p>但在Mac OS上不是，&#x2F;bin&#x2F;sh和&#x2F;bin&#x2F;bash是两个不同的文件，尽管它们的大小只相差100字节左右:</p><pre><code class="hljs">iMac:~ wuxiao$ ls -l /bin/*sh-r-xr-xr-x  1 root  wheel  1371648  6 Nov 16:52 /bin/bash-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/csh-r-xr-xr-x  1 root  wheel  2180736  6 Nov 16:52 /bin/ksh-r-xr-xr-x  1 root  wheel  1371712  6 Nov 16:52 /bin/sh-rwxr-xr-x  2 root  wheel   772992  6 Nov 16:52 /bin/tcsh-rwxr-xr-x  1 root  wheel  1103984  6 Nov 16:52 /bin/zsh</code></pre><h4 id="高级编程语言"><a href="#高级编程语言" class="headerlink" title="高级编程语言"></a>高级编程语言</h4><p>理论上讲，只要一门语言提供了解释器（而不仅是编译器），这门语言就可以胜任脚本编程，常见的解释型语言都是可以用作脚本编程的，如：Perl、Tcl、Python、PHP、Ruby。Perl是最老牌的脚本编程语言了，Python这些年也成了一些linux发行版的预置解释器。</p><p>编译型语言，只要有解释器，也可以用作脚本编程，如C shell是内置的（&#x2F;bin&#x2F;csh），Java有第三方解释器Jshell，Ada有收费的解释器AdaScript。</p><p>如下是一个PHP Shell Script示例（假设文件名叫test.php）：</p><pre><code class="hljs">#!/usr/bin/php&lt;?phpfor ($i=0; $i &lt; 10; $i++)        echo $i . &quot;\n&quot;;</code></pre><p>执行：</p><pre><code class="hljs">/usr/bin/php test.php</code></pre><p>或者：</p><pre><code class="hljs">chmod +x test.php./test.php</code></pre><h2 id="如何选择shell编程语言"><a href="#如何选择shell编程语言" class="headerlink" title="如何选择shell编程语言"></a>如何选择shell编程语言</h2><h3 id="熟悉-vs-陌生"><a href="#熟悉-vs-陌生" class="headerlink" title="熟悉 vs 陌生"></a>熟悉 vs 陌生</h3><p>如果你已经掌握了一门编程语言（如PHP、Python、Java、JavaScript），建议你就直接使用这门语言编写脚本程序，虽然某些地方会有点啰嗦，但你能利用在这门语言领域里的经验（单元测试、单步调试、IDE、第三方类库）。</p><p>新增的学习成本很小，只要学会怎么使用shell解释器（Jshell、AdaScript）就可以了。</p><h3 id="简单-vs-高级"><a href="#简单-vs-高级" class="headerlink" title="简单 vs 高级"></a>简单 vs 高级</h3><p>如果你觉得自己熟悉的语言（如Java、C）写shell脚本实在太啰嗦，你只是想做一些备份文件、安装软件、下载数据之类的事情，学着使用sh，bash会是一个好主意。</p><p>shell只定义了一个非常简单的编程语言，所以，如果你的脚本程序复杂度较高，或者要操作的数据结构比较复杂，那么还是应该使用Python、Perl这样的脚本语言，或者是你本来就已经很擅长的高级语言。因为sh和bash在这方面很弱，比如说：</p><ul><li>它的函数只能返回字串，无法返回数组</li><li>它不支持面向对象，你无法实现一些优雅的设计模式</li><li>它是解释型的，一边解释一边执行，连PHP那种预编译都不是，如果你的脚本包含错误(例如调用了不存在的函数)，只要没执行到这一行，就不会报错</li></ul><h3 id="环境兼容性"><a href="#环境兼容性" class="headerlink" title="环境兼容性"></a>环境兼容性</h3><p>如果你的脚本是提供给别的用户使用，使用sh或者bash，你的脚本将具有最好的环境兼容性，perl很早就是linux标配了，python这些年也成了一些linux发行版的标配，至于mac os，它默认安装了perl、python、ruby、php、java等主流编程语言。</p><h2 id="第一个shell脚本"><a href="#第一个shell脚本" class="headerlink" title="第一个shell脚本"></a>第一个shell脚本</h2><h3 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h3><p>打开文本编辑器，新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell 脚本，扩展名就用php好了。</p><p>输入一些代码，第一行一般是这样：</p><pre><code class="hljs">#!/bin/bash#!/usr/bin/php</code></pre><p>“#!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>运行Shell脚本有两种方法：</p><h4 id="作为可执行程序"><a href="#作为可执行程序" class="headerlink" title="作为可执行程序"></a>作为可执行程序</h4><pre><code class="hljs">chmod +x test.sh./test.sh</code></pre><p>注意，一定要写成.&#x2F;test.sh，而不是test.sh，运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有&#x2F;bin, &#x2F;sbin, &#x2F;usr&#x2F;bin，&#x2F;usr&#x2F;sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用.&#x2F;test.sh告诉系统说，就在当前目录找。</p><p>通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。</p><p>这里的”系统”，其实就是shell这个应用程序（想象一下Windows Explorer），但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用&#x2F;bin&#x2F;sh作为解释器的脚本是不是可以省去第一行呢？是的。</p><h4 id="作为解释器参数"><a href="#作为解释器参数" class="headerlink" title="作为解释器参数"></a>作为解释器参数</h4><p>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如：</p><pre><code class="hljs">/bin/sh test.sh/bin/php test.php</code></pre><p>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>定义变量时，变量名不加美元符号（$），如：</p><pre><code class="hljs">your_name=&quot;qinjx&quot;</code></pre><p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。</p><p>除了显式地直接赋值，还可以用语句给变量赋值，如：</p><pre><code class="hljs">for file in `ls /etc`</code></pre><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p><pre><code class="hljs">your_name=&quot;qinjx&quot;echo $your_nameecho $&#123;your_name&#125;</code></pre><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p><pre><code class="hljs">for skill in Ada Coffe Action Java; do    echo &quot;I am good at $&#123;skill&#125;Script&quot;done</code></pre><p>如果不给skill变量加花括号，写成echo “I am good at $skillScript”，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p><p>推荐给所有变量加上花括号，这是个好的编程习惯。IntelliJ IDEA编写shell script时，IDE就会提示加花括号。</p><h3 id="重定义变量"><a href="#重定义变量" class="headerlink" title="重定义变量"></a>重定义变量</h3><p>已定义的变量，可以被重新定义，如：</p><pre><code class="hljs">your_name=&quot;qinjx&quot;echo $your_nameyour_name=&quot;alibaba&quot;echo $your_name</code></pre><p>这样写是合法的，但注意，第二次赋值的时候不能写$your_name&#x3D;”alibaba”，使用变量的时候才加美元符。</p><h3 id="变量-数学-运算"><a href="#变量-数学-运算" class="headerlink" title="变量 数学 运算"></a>变量 数学 运算</h3><ol><li>Linux shell 中使用 let , [ ] ,(( )) 三种运算符操作 shell 变量进行简单的基本运算；</li><li>Linux shell 中使用 expr 与 bc 两个程序实现高级运算；</li></ol><h4 id="Linux-shell-变量的基本运算"><a href="#Linux-shell-变量的基本运算" class="headerlink" title="Linux shell 变量的基本运算"></a>Linux shell 变量的基本运算</h4><p>数值作为常规变量直接赋值给变量，并且以字符串形式保存。</p><pre><code class="hljs">a=7b=8let c=a+becho d=$[a+b]echo e=$((a+b))</code></pre><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>以“#”开头的行就是注释，会被解释器忽略。</p><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>sh里没有多行注释，只能每一行加一个#号。就像这样：</p><pre><code class="hljs">#--------------------------------------------# 这是一个自动打ipa的脚本，基于webfrogs的ipa-build书写：https://github.com/webfrogs/xcode_shell/blob/master/ipa-build# 功能：自动为etao ios app打包，产出物为14个渠道的ipa包# 特色：全自动打包，不需要输入任何参数#--------------------------------------------##### 用户配置区 开始 ######## 项目根目录，推荐将此脚本放在项目的根目录，这里就不用改了# 应用名，确保和Xcode里Product下的target_name.app名字一致###### 用户配置区 结束  #####</code></pre><p>如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了，哈哈），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。</p><h3 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h3><pre><code class="hljs">str=&#39;this is a string&#39;</code></pre><p>单引号字符串的限制：</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</li><li>单引号字串中不能出现单引号（对单引号使用转义符后也不行）</li></ul><h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><pre><code class="hljs">your_name=&#39;qinjx&#39;str=&quot;Hello, I know your are \&quot;$your_name\&quot;! \n&quot;</code></pre><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><h4 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h4><pre><code class="hljs">your_name=&quot;qinjx&quot;greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;echo $greeting $greeting_1</code></pre><h4 id="获取字符串长度："><a href="#获取字符串长度：" class="headerlink" title="获取字符串长度："></a>获取字符串长度：</h4><pre><code class="hljs">string=&quot;abcd&quot;echo $</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSH简要教程</title>
    <link href="/2018/04/16/2018-04-16-ssh-instruction/"/>
    <url>/2018/04/16/2018-04-16-ssh-instruction/</url>
    
    <content type="html"><![CDATA[<h2 id="what’s-SSH"><a href="#what’s-SSH" class="headerlink" title="what’s SSH"></a>what’s SSH</h2><p>通俗来讲，<strong>SSH</strong>是一种网络协议，主要用于远程登陆。由于这种登陆中信息是加密的，所以即使被中途拦截，也不会泄露密码。</p><h2 id="SSH基本用法"><a href="#SSH基本用法" class="headerlink" title="SSH基本用法"></a>SSH基本用法</h2><p><strong>username</strong>为你登陆的远程主机用户名（若本地用户名与远程用户名一致，可省略<code>username@</code>），<strong>host</strong>为你登陆的远程主机ip，此命令默认使用远程主机的<strong>22</strong>端口进行登陆。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh username@host<br></code></pre></td></tr></table></figure><p>若想指定端口号,可用<strong>p</strong>参数（例如指定<strong>33</strong>端口发送登陆请求）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh -p 33 username@host<br></code></pre></td></tr></table></figure><h2 id="SSH免密登陆"><a href="#SSH免密登陆" class="headerlink" title="SSH免密登陆"></a>SSH免密登陆</h2><p>每次登陆都需要输入密码会比较麻烦，可以设置免密登陆。</p><p>免密登陆的原理是：</p><blockquote><p>用户将自己的公钥存储在远程主机上,在登陆时,远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p></blockquote><p>因此,用户首先需要提供自己的公钥,可以进入目录<code>~/.ssh</code>查看一下,<code>id_rsa.pub</code>为私钥,<code>id_rsa</code>为公钥。如果没有,可以用如下方式生成:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen<br></code></pre></td></tr></table></figure><p>然后用如下命令,可以将公钥传送给远程主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-copy-id username@host<br></code></pre></td></tr></table></figure><p>正常情况至此应该已经大公告成,如果没有,请查看远程主机的<code>/etc/ssh/sshd_config</code>文件,将下面几行的注释取消</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">　　RSAAuthentication <span class="hljs-built_in">yes</span><br>　　PubkeyAuthentication <span class="hljs-built_in">yes</span><br>　　AuthorizedKeysFile .ssh/authorized_keys<br></code></pre></td></tr></table></figure><p>然后重启远程主机的<em><strong>SSH</strong></em>服务(ubuntu)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ service ssh restart<br></code></pre></td></tr></table></figure><p>大功告成!</p><h2 id="本机与远程主机之间文件传输"><a href="#本机与远程主机之间文件传输" class="headerlink" title="本机与远程主机之间文件传输"></a>本机与远程主机之间文件传输</h2><p>由本机往远程主机路径<code>~/picture/</code>传输文件<strong>a</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ scp a username@host:~/picture/<br></code></pre></td></tr></table></figure><p>由远程主机往本机路径<code>~/picture/</code>传输文件<strong>b</strong>(本机<strong>localhost</strong>可以由<code>ifconfig</code>命令查看)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ scp b localusername@localhost:~/picture/<br></code></pre></td></tr></table></figure><h2 id="配置config便捷登录"><a href="#配置config便捷登录" class="headerlink" title="配置config便捷登录"></a>配置<code>config</code>便捷登录</h2><p>在目录<code>~/.ssh/</code>下新建<code>config</code>文件，输入如下信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs config">Host s1<br>HostName 10.20.41.20<br>User xhy<br>Port 25000<br><br>Host s2<br>HostName 10.20.41.21<br>User xhy<br>Port 25000<br></code></pre></td></tr></table></figure><p>则再使用<code>ssh</code>命令登录服务器s1时只需要输入<code>ssh s1</code>即可。</p><h2 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h2><p>一般我们都是使用ssh连接服务器，而服务器一般都会预装了ssh服务，所以以上操作不会出现问题，但是也有偶尔我们是想要使用ssh连接任意两台主机，此时也许会出现</p><pre><code class="hljs">connect to host xxx.xxx.xxx.xxx port 22:Connection refused</code></pre><h2 id="这有可能是因为目前ubuntu主机一般都是默认安装了openssh-client，但是没有安装openssh-server，可以使用如下命令解决"><a href="#这有可能是因为目前ubuntu主机一般都是默认安装了openssh-client，但是没有安装openssh-server，可以使用如下命令解决" class="headerlink" title="这有可能是因为目前ubuntu主机一般都是默认安装了openssh-client，但是没有安装openssh-server，可以使用如下命令解决"></a>这有可能是因为目前ubuntu主机一般都是默认安装了<strong>openssh-client</strong>，但是没有安装<strong>openssh-server</strong>，可以使用如下命令解决<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#首先使用如下命令查看看是否有sshd进行(注意：ssh-agent客户端程序是不行的，sshd是server线程)</span><br>$ ps -e | grep ssh<br><span class="hljs-comment">#如果没有基本就是得自己安装了</span><br>$ sudo apt-get install openssh-server<br></code></pre></td></tr></table></figure></h2><blockquote><p>此处一定要查看有没有sshd服务正在运行，一般有些linux桌面发行版都是只有ssh的客户端agent服务程序的。当然，也有可能是其他原因，比如说你的ip被人屏蔽了等，但是一般我们遇到其他情况可能性比较低。</p></blockquote><h2 id="SSH登陆知识常识"><a href="#SSH登陆知识常识" class="headerlink" title="SSH登陆知识常识"></a>SSH登陆知识常识</h2><p>SSH之所以能够保证安全，原因在于它采用了公钥加密。</p><p>整个过程是这样的：</p><blockquote><ul><li>远程主机收到用户的登录请求，把自己的公钥发给用户。</li><li>用户使用这个公钥，将登录密码加密后，发送回来。</li><li>远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</li></ul></blockquote><p>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。</p><p>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）。</p><p>其实到目前为止并没有有效阻止“中间人攻击的方法”，因此在用户尝试登陆远程主机时，SSH会做出如下提示（非免密登录）：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ ssh user@host<br><br>　　The authenticity of host &#x27;host (12.18.429.21)&#x27; can&#x27;t be established.<br><br>　　RSA key fingerprint is 98:2e:d7:e0:<span class="hljs-keyword">de</span>:9f:<span class="hljs-keyword">ac</span>:67:28:c2:42:2d:37:16:58:4d.<br><br>　　Are you sure you want to <span class="hljs-keyword">continue</span> connecting (yes/<span class="hljs-keyword">no</span>)?<br></code></pre></td></tr></table></figure><p>即无法确定host主机的真实性，只知道它的公钥指纹，如果你可以核对这个公钥指纹，即可确保安全登陆。</p>]]></content>
    
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git与Github简要教程</title>
    <link href="/2018/04/12/2018-04-12-git-simple/"/>
    <url>/2018/04/12/2018-04-12-git-simple/</url>
    
    <content type="html"><![CDATA[<p>由于本人对于git的理解尚且粗浅，本文主要简单的介绍使用<code>git</code>的必要功能的详细步骤。比如说自己开发一个git仓库，并托管在github上可能需要用到的操作。附带了实例命令演示。但是，本教程仅仅限于个人简单的git的使用，如果想要使用git与人协同工作，或者git管理一个大型的开源项目，这个教程是远远不够的。以后在我对于git有了更加深刻的理解后，也许会再写一些系统的git笔记。但是如果你忘记了git的一些简单命令，可以来这里温习一遍。</p><h1 id="what’s-Git-and-what’s-Github"><a href="#what’s-Git-and-what’s-Github" class="headerlink" title="what’s Git and what’s Github"></a>what’s Git and what’s Github</h1><p>Git是一种分布式版本控制系统，具体学习可以参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰的git教程</a>,讲解清晰易懂，本文主要介绍如何运用git与github进行基本上手操作。</p><p>GitHub是通过Git进行版本控制的软件源代码托管服务。</p><h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get install git<br></code></pre></td></tr></table></figure><h1 id="git与github基本使用"><a href="#git与github基本使用" class="headerlink" title="git与github基本使用"></a>git与github基本使用</h1><h2 id="git与github远程库交互"><a href="#git与github远程库交互" class="headerlink" title="git与github远程库交互"></a>git与github远程库交互</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>本地创建版本库<strong>learngit</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> learngit<br>$ <span class="hljs-built_in">cd</span> learngit<br>$ git init<br></code></pre></td></tr></table></figure><h3 id="将修改结果添加到仓库并提交"><a href="#将修改结果添加到仓库并提交" class="headerlink" title="将修改结果添加到仓库并提交"></a>将修改结果添加到仓库并提交</h3><p>编辑完文件<strong>readme</strong>添加到仓库并提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add readme        <span class="hljs-comment"># git add --all 提交所有改动</span><br>$ git commit -m <span class="hljs-string">&#x27;first commit&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="配置个人信息"><a href="#配置个人信息" class="headerlink" title="配置个人信息"></a>配置个人信息</h3><p>如果是第一次使用git，那么<code>git commit</code>可能报错，所以需要你配置一些个人信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global user.email <span class="hljs-string">&quot;you@example.com&quot;</span><br>$ git config --global user.name <span class="hljs-string">&quot;Your Name&quot;</span><br></code></pre></td></tr></table></figure><h3 id="上传到github"><a href="#上传到github" class="headerlink" title="上传到github"></a>上传到github</h3><p>上传到github,首先登陆自己的github帐号，然后新建一个<strong>repository</strong>并取名为<strong>learngit</strong>,然后执行下面命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote add origin https://github.com/xhy3054/learngit.git  <span class="hljs-comment">#与远程库建立链接,只有第一次上传需要执行</span><br>$ git push -u origin master<br></code></pre></td></tr></table></figure><h3 id="克隆远程库到本地"><a href="#克隆远程库到本地" class="headerlink" title="克隆远程库到本地"></a>克隆远程库到本地</h3><p>将一个github上的版本库克隆到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/xhy3054/learngit.git  <span class="hljs-comment">#也可以指定本地目录名 git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</span><br></code></pre></td></tr></table></figure><h3 id="远程库修改过，更新本地库（将远程库拉下来与本地库合并）"><a href="#远程库修改过，更新本地库（将远程库拉下来与本地库合并）" class="headerlink" title="远程库修改过，更新本地库（将远程库拉下来与本地库合并）"></a>远程库修改过，更新本地库（将远程库拉下来与本地库合并）</h3><pre><code class="hljs">git pull #此命令用时需保证本地库没有修改未提交，</code></pre><h3 id="查看本地分支列表"><a href="#查看本地分支列表" class="headerlink" title="查看本地分支列表"></a>查看本地分支列表</h3><pre><code class="hljs">git branch</code></pre><h3 id="查看本地仓库工作状态"><a href="#查看本地仓库工作状态" class="headerlink" title="查看本地仓库工作状态"></a>查看本地仓库工作状态</h3><pre><code class="hljs">git status</code></pre><h3 id="查看本地库关联的远程库（即push与pull推送与拉取的那个远程库）"><a href="#查看本地库关联的远程库（即push与pull推送与拉取的那个远程库）" class="headerlink" title="查看本地库关联的远程库（即push与pull推送与拉取的那个远程库）"></a>查看本地库关联的远程库（即push与pull推送与拉取的那个远程库）</h3><pre><code class="hljs">git remote -v</code></pre><h3 id="修改本地库关联的远程库"><a href="#修改本地库关联的远程库" class="headerlink" title="修改本地库关联的远程库"></a>修改本地库关联的远程库</h3><pre><code class="hljs">git remote -v set-url origin https://github.com/xhy3054/ssdcaffe.git</code></pre><h2 id="git版本管理"><a href="#git版本管理" class="headerlink" title="git版本管理"></a>git版本管理</h2><h3 id="查看历史版本git-log"><a href="#查看历史版本git-log" class="headerlink" title="查看历史版本git log"></a>查看历史版本<code>git log</code></h3><pre><code class="hljs">$git logcommit 85c18305998dc282973a21513aa1893567a52e33Author: xhy3054 &lt;1076170656@qq.com&gt;Date:   Mon May 7 14:31:42 2018 +0800    bumacommit fd2bc5b0c3d2bbb06a51ec757c34f27a20ca1e8fAuthor: xhy3054 &lt;1076170656@qq.com&gt;Date:   Sat May 5 20:51:53 2018 +0800    add a image</code></pre><h3 id="回退到版本add-a-image"><a href="#回退到版本add-a-image" class="headerlink" title="回退到版本add a image"></a>回退到版本<code>add a image</code></h3><pre><code class="hljs">git reset --hard fd2bc5</code></pre><h3 id="查看当前分支"><a href="#查看当前分支" class="headerlink" title="查看当前分支"></a>查看当前分支</h3><pre><code class="hljs">git branch</code></pre><h3 id="新建分支dev"><a href="#新建分支dev" class="headerlink" title="新建分支dev"></a>新建分支<code>dev</code></h3><pre><code class="hljs">git branch dev</code></pre><h3 id="切换到分支dev"><a href="#切换到分支dev" class="headerlink" title="切换到分支dev"></a>切换到分支<code>dev</code></h3><pre><code class="hljs">git checkout dev</code></pre><h3 id="如果dev上的工作想合并到master"><a href="#如果dev上的工作想合并到master" class="headerlink" title="如果dev上的工作想合并到master"></a>如果<code>dev</code>上的工作想合并到<code>master</code></h3><pre><code class="hljs">git checkout mastergit merge dev</code></pre><h3 id="删除分支dev"><a href="#删除分支dev" class="headerlink" title="删除分支dev"></a>删除分支<code>dev</code></h3><pre><code class="hljs">git branch -d dev</code></pre><h3 id="循环克隆带子模块的仓库"><a href="#循环克隆带子模块的仓库" class="headerlink" title="循环克隆带子模块的仓库"></a>循环克隆带子模块的仓库</h3><ol><li><p>在克隆整个仓库时指定：<code>git clone --recursive https://github.com/xhy3054/ssdcaffe.git</code></p></li><li><p>项目已经克隆到了本地，需要把子模块也克隆下来：</p><ul><li>初始化本地子模块配置文件：<code>git submodule init</code></li><li>更新项目，抓取子模块内容：<code>git submodule update</code></li></ul></li></ol><p>其他git命令请<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">查询</a>.</p>]]></content>
    
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda简要教程与jupyter book的安装</title>
    <link href="/2018/04/12/2018-04-12-anaconda-simple/"/>
    <url>/2018/04/12/2018-04-12-anaconda-simple/</url>
    
    <content type="html"><![CDATA[<h3 id="what’s-Anaconda"><a href="#what’s-Anaconda" class="headerlink" title="what’s Anaconda"></a>what’s Anaconda</h3><p><strong>Anaconda</strong>,是用于python编程环境管理的一个工具。它让你可以为每一个项目单独的构建自己的python编程环境，因此很好的解决了不同项目之间的串扰问题。并且使得你的工作更加清晰有条理。</p><h3 id="install-Anaconda"><a href="#install-Anaconda" class="headerlink" title="install Anaconda"></a>install Anaconda</h3><p>从<a href="https://www.anaconda.com/download/">官网</a>下载安装文件，在linux下是一个类似<code>Anaconda2-5.1.0-Linux-x86_64.sh</code>文件，安装只需运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ bash Anaconda2-5.1.0-Linux-x86_64.sh <br></code></pre></td></tr></table></figure><h3 id="Anaconda启用与停用"><a href="#Anaconda启用与停用" class="headerlink" title="Anaconda启用与停用"></a>Anaconda启用与停用</h3><p>安装的过程中会有两次让你确认的交互，第一次是让你同意他的协议，输入yes即可；第二次是问你是否将anaconda&#x2F;bin添加到环境变量中，一般来说点击yes是没问题的，这样安装完，就直接和你的python3命令绑定了。如果这一步输入了no，相当于默认没有启动anaconda,需要去环境变量中添加，方法如下：</p><ol><li><p>打开终端并输入<code>gedit ~/.bashrc</code></p></li><li><p>在<code>.bashrc</code>文件末尾输入<code>export PATH=/home/xhy/anaconda3/bin:$PATH </code>,路径换为<strong>自己的</strong>，然后保存。</p></li><li><p>终端输入<code>source~/.bashrc</code>，使得立即生效。</p></li></ol><p>若想停用anaconda，方法如下：</p><ol><li><p>打开终端并输入<code>gedit ~/.bashrc</code></p></li><li><p>找到刚才添加的那行路径注释掉</p></li><li><p>终端输入<code>source~/.bashrc</code>，使得立即生效。</p></li><li><p>重开一终端即可看到效果。</p></li></ol><h3 id="使用Anaconda"><a href="#使用Anaconda" class="headerlink" title="使用Anaconda"></a>使用Anaconda</h3><p>列出已有的环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ conda <span class="hljs-built_in">env</span> list<br></code></pre></td></tr></table></figure><p>基于<strong>python2</strong>创建一个名为<strong>tensorflow</strong>的环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ conda create -n tensorflow python=2 <br></code></pre></td></tr></table></figure><p>进入环境<strong>tensorflow</strong>（source可用conda替换）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">source</span> activate tensorflow<br></code></pre></td></tr></table></figure><p>列出此<strong>python</strong>环境下已有的包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ conda list<br><span class="hljs-comment">#或者 </span><br>$ pip list<br></code></pre></td></tr></table></figure><p>查询某一个包(比如numpy)的版本信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ conda search numpy<br></code></pre></td></tr></table></figure><p>此<strong>python</strong>环境下安装<strong>tensorflow</strong>（其他包类似）（也可以用<strong>pip</strong>安装）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ conda install tensorflow <br><span class="hljs-comment">#也可以pip管理</span><br>$ pip install tensorflow<br></code></pre></td></tr></table></figure><p>卸载包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ conda remove tensorflow<br><span class="hljs-comment">#如果pip管理</span><br>$ pip uninstall tensorflow<br></code></pre></td></tr></table></figure><p>离开<strong>tensorflow</strong>环境（source可用conda替换）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">source</span> deactivate<br></code></pre></td></tr></table></figure><p>删除<strong>tensorflow</strong>环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ conda <span class="hljs-built_in">env</span> remove -n tensorflow<br></code></pre></td></tr></table></figure><p>如果换了一台新电脑，想要将旧电脑上配置的这个<strong>tensorflow</strong>环境搬过去，先将此环境下的配置信息导出到一个<code>.yaml</code>文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ conda <span class="hljs-built_in">env</span> <span class="hljs-built_in">export</span> &gt; ~/environment.yaml <br></code></pre></td></tr></table></figure><p>然后在新电脑上新建<strong>tensorflow</strong>环境，然后根据<code>.yaml</code>文件更新环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ conda <span class="hljs-built_in">env</span> update -f /path/to/environment.yml <br></code></pre></td></tr></table></figure><h3 id="anaconda的小毛病"><a href="#anaconda的小毛病" class="headerlink" title="anaconda的小毛病"></a>anaconda的小毛病</h3><ul><li><p>如果你用pip安装的包发现也装在了系统Python下，是因为使用了系统python的pip，指定路径就好了<code>/home/xhy/anaconda3/bin/pip install 包名 </code></p></li><li><p>anaconda并不是完美的，虽然anaconda提供conda与pip方式在独立的env下安装Python包，但是我们知道有些包一般是用apt安装的。比如说pillow包是一个常用的Python图像处理包。但是一般安装这个包是用<code>sudo apt-get install python-imaging</code>命令安装。而apt安装的Python包默认安装在系统Python目录下，所以在anaconda的此env下的Python并不能import到（当然你可以在import时指定路径我猜测），于是就很烦，查了一下原来这种情况也是可以安装的，虽然直接Pip和conda都找不到python-imaging包，但是可以用命令<code>conda install -c anaconda pillow </code>安装。（可以google下anaconda如何安装××包，前提你得知道包名）</p></li></ul><h2 id="安装jupyter-lab"><a href="#安装jupyter-lab" class="headerlink" title="安装jupyter lab"></a>安装jupyter lab</h2><ul><li>安装：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda install -c conda-forge jupyterlab<br><span class="hljs-comment"># 或者</span><br>pip install jupyterlab<br></code></pre></td></tr></table></figure><ul><li><p>启动服务</p><p>  jupyter lab –ip&#x3D;0.0.0.0 –port&#x3D;8080</p></li></ul><blockquote><p>windows的话直接安装anaconda，然后在navigator里便可以找到jupyter</p></blockquote><h2 id="切换清华镜像源"><a href="#切换清华镜像源" class="headerlink" title="切换清华镜像源"></a>切换清华镜像源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/<br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/<br>conda config --<span class="hljs-built_in">set</span> show_channel_urls <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
